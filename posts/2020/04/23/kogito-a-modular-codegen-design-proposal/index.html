<!doctype html><html lang=en-us><head><title>Kogito: A Modular Codegen Design Proposal | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="My favorite topic of discussion last year was moving computations to compile-time.
In fact, I went to a few conferences explaining how moving processing out of your run-time and into build-time, is a conceptually simple but extremely effective way to make your applications lighter. This was sometimes received with little enthusiasm: the idea itself is in fact far from new. Yet, it is key to a lot of the most interesting recent innovations in the Java ecosystem."><meta name=generator content="Hugo 0.116.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Kogito: A Modular Codegen Design Proposal</h1><div class=tip><time datetime="2020-04-23 00:00:00 +0000 UTC">Apr 23, 2020</time>
<span class=split>¬∑</span>
<span>1762 words</span>
<span class=split>¬∑</span>
<span>9 minute read</span></div><div class=content><p>My favorite topic of discussion last year was <em>moving computations to compile-time</em>.</p><div style=float:right><img src=https://i.imgur.com/cHmSoB8.png title=Reflection></div><p>In fact, I went to <a href=https://youtu.be/TWfigR9wGsA target=_blank rel=noopener>a few</a> <a href="https://www.youtube.com/watch?v=BUrY6On1SxM" target=_blank rel=noopener>conferences</a> explaining how <strong>moving processing out of your run-time and into build-time</strong>, is a <strong>conceptually simple</strong> but <strong>extremely effective way</strong> to make your applications lighter. This was sometimes received with <strong>little enthusiasm</strong>: the idea itself is in fact far from new. Yet, it is key to a lot of the most interesting recent innovations in the Java ecosystem.</p><p>For better or worst, <strong>run-time reflection</strong> is a peculiarity of the Java ecosystem. However, today <strong>a lot of modern Java frameworks are embracing code generation</strong>; which is ironic, because, as far as I know, run-time reflection was often embraced as a reaction to slow code generation procedures.</p><p>In <strong><a href=https://kogito.kie.org target=_blank rel=noopener>Kogito</a></strong>, we are using code generation to <strong>pre-process</strong> and <strong>compile</strong> so-called &ldquo;business assets&rdquo; into <strong>executable code</strong>. In the following we will explore the history and the motivations for embracing code generation instead of run-time reflection, and how we plan to bring our approach to codegen forward, by <strong>taking hints from compiler design</strong>.</p><h2 id=run-time-vs-build-time-meta-programming>Run-Time vs. Build-Time Meta-Programming <a href=#run-time-vs-build-time-meta-programming class=anchor>üîó</a></h2><p>I believe there are many reasons why often we reach for run-time reflection, but I will name two;</p><ol><li><p>the reflection API is &ldquo;standard&rdquo;: it is bundled with the JDK and it is relatively easy to use; it allows developers to implement some meta-programming logic with the tools they already know.</p></li><li><p>run-time reflection keeps <strong>build time low</strong> and it allows for <strong>more degrees of freedom at run-time</strong>.</p></li></ol><p>But the JDK <em>does</em> support compile-time manipulation: although there is no &ldquo;proper&rdquo; macro support, there <em>are</em> compile-time meta-programming facilities in the <a href=https://docs.oracle.com/en/java/javase/11/docs/api/java.compiler/javax/annotation/processing/package-summary.html target=_blank rel=noopener><strong>annotation processing framework</strong></a>. But then, although the annotation processor framework provides way to hook into the Java compiler and <em>process</em> code, is does not provide a standardized set of tools to <em>generate</em> code. Some people use <a href=https://asm.ow2.io/ target=_blank rel=noopener>ASM</a> for bytecode generation; other generate source code using <a href=https://github.com/square/javapoet target=_blank rel=noopener>JavaPoet</a>, <a href=https://javaparser.org/ target=_blank rel=noopener>JavaParser</a> or other similar libraries.</p><p>And I believe, this is another reason, why people choose reflection: you don&rsquo;t need to <em>generate</em> code at all.</p><h3 id=the-price-of-run-time-reflection>The Price of Run-Time Reflection <a href=#the-price-of-run-time-reflection class=anchor>üîó</a></h3><p>For this and other reasons code-generation has become a lesser citizen of the Java ecosystem. However, <strong>run-time reflection comes at a price</strong>. From the top of my head:</p><ul><li><strong>your reflection logic <em>must</em> be rock-solid</strong>: otherwise many compile-time errors will turn into run-time errors; i.e. errors into your reflective logic</li><li><strong>moving meta-programming logic in the run-time</strong> of your application <a href=https://www.optaplanner.org/blog/2018/01/09/JavaReflectionButMuchFaster.html target=_blank rel=noopener><strong>impacts performance</strong></a>: not only are reflective invocations usually slower than direct invocations, but also meta-programming logic will run as part of your main program logic, inevitably adding overhead to execution.</li></ul><p>Traditionally, this was not regarded as a huge burden: in fact, Java programs used to be long-running and often server-side; the overhead of run-time reflection, being usually paid at application configuration and startup time, was considered irrelevant, because it was tiny, compared to the time they would run.</p><h3 id=rediscovering-code-generation>Rediscovering Code Generation <a href=#rediscovering-code-generation class=anchor>üîó</a></h3><div style=float:right;padding-left:2em><img src=https://i.imgur.com/mgInxYI.png title="The Dragon Book"></div><p>Today <strong><a href=https://micronaut.io target=_blank rel=noopener>a lot</a> of <a href=https://quarkus.io target=_blank rel=noopener>frameworks</a></strong> are actually going back to build-time code generation: <strong>Kogito</strong> is one of those.</p><p>In the last few years, <strong>the programming landscape <a href=http://www.cdi-spec.org/news/2020/03/09/CDI_for_the_future/ target=_blank rel=noopener>has changed</a></strong>; for instance, constrained platforms such as Android used to have more limited support for runtime reflection different performance requirements: applications should be small and quick to start. People started to develop <strong>microservices</strong> and <strong>serverless applications</strong>: these services need to start very quickly, to elastically scale with the number of incoming requests. <strong>GraalVM&rsquo;s native image compiler</strong> is another run-time platform with additional constraints: it allows to compile a Java program into a native executable, but originally, it posed a few limitations on run-time reflection. Moreover, whereas in the past fat, long-running application servers hosted several, possibly mutable applications in a single process space, today we deploy <strong>separate, stand-alone, immutable, containerized applications</strong> on Kubernetes. For all these, and other reasons, in the last few years <strong>the Java ecosystem is rediscovering code-generation</strong>.</p><p>The Kogito code-generation procedure elaborates all the &ldquo;knowledge assets&rdquo; in a codebase and produces equivalent Java code that plugs into our core engines on one side, and into the Quarkus or Spring APIs to expose automatically generated REST service endpoints on the other.</p><p>Let&rsquo;s see more in detail how this procedure works.</p><h2 id=staged-compilation-in-kogito>Staged Compilation in Kogito <a href=#staged-compilation-in-kogito class=anchor>üîó</a></h2><p>In Kogito, the code-generation procedure is designed in <strong>stages</strong>.</p><div style=margin:auto;text-align:center><img src=https://i.imgur.com/YvzSkJT.png alt=Stages width=70%></div><p>First, <strong>processes</strong> (BPMN files) are analyzed, then <strong>rules</strong> (DRLs), then <strong>decisions</strong> (DMNs). Each stage, as a result, generates Java source code; compilation is delegated to the Java compiler. In modern parlance, this would be called a <em>&ldquo;transpiler&rdquo;</em>; a term that I despise, because it makes it sound like compilers do not just generate code but do some kind of magic mumbo-jumbo. But that&rsquo;s another story. Whatever you want to call it, our current architecture of this procedure is rigid, and does not allow for extension</p><p>In fact, albeit we are processing each type of asset in a <em>separate stage</em>, each stage is effectively a <strong>single-pass compiler</strong>, because each it always terminates with the generation of the compilation target. This is the reason why it is generally better to <strong>break down compilation into more passes</strong>. Each compilation pass usually produces what is called an <strong>intermediate representation</strong>; the input to one stage is the output of the previous, and so on up to the final stage, where target code is actually produced.</p><h3 id=compilers-and-compilation-phases>Compilers and Compilation Phases <a href=#compilers-and-compilation-phases class=anchor>üîó</a></h3><p>In a traditional compiler, usually, one of the first stages is <strong>parsing</strong> the input source code and transforming it into an internal tree representation (the <em>Abstract Syntax Tree</em>); then usually is the <strong>name resolution</strong> phase, where the names of the values and symbols that are used throughout the program are resolved; then the <strong>type-checking phase</strong> verifies and validates the correctness of the program; finally <strong>code</strong> is actually <strong>generated</strong>.</p><p>In Kogito, we <strong>parse</strong> knowledge assets, then we associate <strong>names</strong> to each assets, and we resolve their internal structure, which may <strong>cross-reference</strong> other existing assets. <strong>Type-checking our assets means validating</strong> the models according to specifications and verifying these cross-references. For instance, a BPMN file may reference a Rule Unit definition and a service implementation written in Java.</p><h3 id=compilers-and-mini-phases>Compilers and Mini-Phases <a href=#compilers-and-mini-phases class=anchor>üîó</a></h3><p>So far, our code-generation procedure has been pretty simplistic: we generated code regardless of potential errors, delegating compilation errors to the downstream Java compiler; worse, sometimes they would be caught later at run-time! This in general works, but it either produces pretty obscure compilation errors, or it moves validation too late in the pipeline: which is something that we wanted to avoid in the first place. We want to <strong>catch errors early</strong> and only <strong>generate valid code</strong>.</p><p>By refactoring our compilation phases to a staged, modular compilation architecture we will be able to catch resolution and validation errors early and present them to users in a meaningful way: only when the validation phase will be completed successfully, then we will actually generate code. But we also want our stages to be smaller, so that it is easier to <strong>add more compilation stages</strong> at different points in the pipeline.</p><p>Processes, Rules, Decisions:</p><div style=margin:auto><img src=https://i.imgur.com/2ffP9Sl.jpg alt="Processes, Rules, Decisions"></div><p>For instance, suppose you want to synthesize some elements (e.g. data models) that are inferred from the structure of a process. In our current architecture, the only way to produce additional assets would be to patch the existing code. By de-composing the phases as shown above, you would be able to <strong>plug your additional <a href=https://nanopass.org/ target=_blank rel=noopener>mini-phase</a></strong> right after &ldquo;Model Validation&rdquo;, so that you can be sure that all the names have been resolved, and that only valid models will be processed: you will produce an intermediate representation for the data model that you want to synthesize, and make it available during the &ldquo;Cross-Referencing&rdquo; phase.</p><h2 id=pre-processing-assets-vs-code-scaffolding>Pre-Processing Assets vs. Code Scaffolding. <a href=#pre-processing-assets-vs-code-scaffolding class=anchor>üîó</a></h2><p>As briefly mentioned in the introduction, in our current architecture we are also conflating code-generation for two very different purposes.</p><p>The <strong>first</strong> is to <strong>pre-process</strong> assets to generate their <strong>stand-alone run-time representation</strong>: the goal is both to reduce run-time processing and support native compilation. The output of this code-generation procedure are objects that interface directly with the internal programmatic APIs of our engines. This programmatic API, in Kogito, is currently considered an implementation detail, not supposed to be consumed by end-users. The reason is that this API is still unstable: we want to make sure to get it right, before making it public. Now, for the sake of explanation, consider a BPMN process definition: this is compiled into a class that implement the <code>Process&lt;T></code> interface of the programmatic API. By instantiating this class, you get an exact 1:1 representation of the process definition, minus parsing and preliminary analysis.</p><p>The <strong>second</strong> purpose of code-generation is implemented as a <strong>layer</strong> on top of these run-time representations; here we exposes calls into the programmatic API as <strong>REST endpoints</strong>. For example, consider a process called <code>MyProcess</code>; the REST endpoints we generate expose REST APIs to start, execute and terminate an instance of that process. You can imagine that code to look a but like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@Path(<span style=color:#a31515>&#34;/MyProcess&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>MyProcessResource</span> {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  @Inject
</span></span><span style=display:flex><span>  Process&lt;MyProcess&gt; p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  @POST
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> MyProcess start(MyProcess data) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> p.create(data).start();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  @DELETE(<span style=color:#a31515>&#34;/{id}&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> MyProcess abort(String id) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> = p.delete(id);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  @GET(<span style=color:#a31515>&#34;/{id}&#34;</span>)
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> Collection&lt;ProcessInstance&lt;MyProcess&gt;&gt; abort(String id) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> p.instances(id);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Today, both the code that is generated for run-time representations and the code that implements REST endpoints is all treated as an <em>implementation detail</em>. It is only visible in the compilation target directory of your project. And you are <em>not</em> supposed to rely on the structure of that code in your own codebase.</p><p>However, we always meant this procedure to become customizable at some point, promoting it to be <strong>scaffolding</strong>.</p><p>In the case of scaffolding, code should not be generated in your compilation target directory, but instead, it should be promoted to your <em>source code</em> directory. We are currently working on a general solution to allow you to opt-out from code generation for specific assets, and instead, &ldquo;claim&rdquo; it for ownership. For instance, suppose that you want to customize <code>MyProcess</code>. You will be able to tell the code-generation procedure that you want customize that asset: the code-generation procedure will run once, and then you will be able to edit the generated code as regular source code.</p><h2 id=conclusions>Conclusions <a href=#conclusions class=anchor>üîó</a></h2><p>You should now have a better understanding of the rationale for code generation in Kogito: in the future we are going to improve our code generation procedure to allow extensibility by plugging into the code-generation process, and customization by allowing end-users to promote code generation to scaffolding.</p><p>In the future we will further document how we plan to refactor our codebase to support these novel use cases.</p><p>Join us for discussion on our <a href=https://groups.google.com/forum/#!forum/kogito-development target=_blank rel=noopener>mailing list</a> or our <a href=https://kie.zulipchat.com/ target=_blank rel=noopener>Zulip Chat</a> !</p></div><div class=tags><a href=/tags/compilers>Compilers</a>
<a href=/tags/kogito>Kogito</a></div></section></main><footer id=footer><div class=social><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2023
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>