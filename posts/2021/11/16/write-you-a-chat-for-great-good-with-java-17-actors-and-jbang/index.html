<!doctype html><html lang=en-us><head><title>Write You A Chat For Great Good! (with Java 17, actors, and JBang!) | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Hello!
Welcome back to &ldquo;Learn You An Actor (System) For Great Good!&rdquo;. If you haven&rsquo;t read the first part, jump there to learn how to write a minimalistic actor runtime using Java 17.
As promised, in this second part I am showing how to write a tiny chat client/server using the runtime we wrote. Then, we will run it using JBang! Next time, we will learn how to create a typed version of the same actor runtime and revisit the examples!"><meta name=generator content="Hugo 0.109.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Write You A Chat For Great Good! (with Java 17, actors, and JBang!)</h1><div class=tip><time datetime="2021-11-16 00:00:00 +0000 UTC">Nov 16, 2021</time>
<span class=split>¬∑</span>
<span>3612 words</span>
<span class=split>¬∑</span>
<span>17 minute read</span></div><div class=content><p>Hello!</p><p>Welcome back to <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>&ldquo;Learn You An Actor (System) For Great Good!&rdquo;</a>. If you haven&rsquo;t read <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>the first part</a>, jump there to learn how to write a <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>minimalistic actor runtime using Java 17</a>.</p><p>As promised, in this second part I am showing how to write a tiny chat client/server <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>using the runtime we wrote</a>. Then, we will run it using <a href=https://jbang.dev target=_blank rel=noopener>JBang!</a> Next time, we will learn how to create a <strong>typed</strong> version of the same actor runtime and revisit the examples!</p><p>Because this post is quite long, here is a table of contents.</p><ul><li><a href=#overview>Overview</a><ul><li><a href=#protocol>Protocol</a></li></ul></li><li><a href=#sockets>Sockets</a></li><li><a href=#chat-server>Chat Server</a><ul><li><a href=#serversockethandler><code>serverSocketHandler</code></a></li><li><a href=#clientsockethanler><code>clientSocketHandler</code></a></li><li><a href=#clientmanager><code>clientManager</code></a></li><li><a href=#starting-the-server>Starting The Server</a></li></ul></li><li><a href=#chat-client>Chat Client</a><ul><li><a href=#client>Client</a></li><li><a href=#starting-the-client>Starting The Client</a></li></ul></li><li><a href=#addendum-a-nio-wrapper>Addendum: A NIO Wrapper</a></li><li><a href=#conclusions>Conclusions</a></li></ul><h2 id=overview>Overview <a href=#overview class=anchor>üîó</a></h2><p>Our chat applications will be extremely simple:</p><p>Each user picks a nickname, they connect to a server through their client and then they send messages to eachother:</p><ul><li>The client waits for the user to input the text of a message; it also displays the messages that it receives from the server.</li><li>The chat server accepts incoming connections, it receives messages, and it propagates them to all the clients that are connected.</li></ul><p><p class=markdown-image><img src=/assets/actor-2/chat.gif alt="Chat application where Duffman says &amp;ldquo;Are you ready?&amp;rdquo; to Carl, Lenny and Barney."></p></p><p>For instance, in this picture <code>Duffman</code> is sending the message <code>"Are you ready?"</code> to the server, and all of <code>Carl</code>, <code>Lenny</code> and <code>Barney</code> receive it (<a href="https://www.youtube.com/watch?v=eEt-n0ZsYx8" target=_blank rel=noopener>to great sadness for Barney, who&rsquo;s the designated driver</a>).</p><h3 id=protocol>Protocol <a href=#protocol class=anchor>üîó</a></h3><p>Computers transfer <em>bytes</em>, so our clients and server should know how to <em>chunk</em> the <em>incoming</em> stream of bytes into self-contained messages; and, likewise, they should <em>produce</em> an <em>outgoing</em> stream of bytes that they know how to chunk.</p><p>We will use a very simple line-based protocol:</p><ul><li>Each message contains the nickname of the user that wrote the message, and the body of the message</li><li>Every client writes a message on a new line</li><li>The server tokenizes the input on the newline, obtaining a message</li><li>The server rebroadcasts each message to the clients that are connected.</li></ul><pre tabindex=0><code>User A: Message 1 \n
User B: Message 2 \n
...
</code></pre><p>We may encode this in the following stream of JSON payloads :</p><pre tabindex=0><code>{ &#34;User A&#34;: &#34;Message 1&#34; } \n
{ &#34;User B&#34;: &#34;Message 2&#34; } \n
...
</code></pre><p>In fact, because JSON does not allow unescaped newlines, we can safely use <code>'\n'</code> as a message separator in the input/output stream of the socket.</p><p>Then, in order to <em>send</em> a message, a <em>client</em>:</p><ul><li>serializes the message into JSON</li><li>it concatenates a newline character at the end of the payload</li><li>it writes the message to its outgoing stream</li></ul><p>In order to <em>receive</em> a message, a <em>client</em>:</p><ul><li>buffers the bytes in its input stream, until a newline is encountered;</li><li>when a newline is found, bytes that have been buffered up to that point <em>are</em> a serialized message</li><li>thus, the client may deserialize the buffer and display the result message</li></ul><p>A <em>server</em>, similarly, to broadcast messages:</p><ul><li>buffers the bytes in its input stream, until a newline is encountered</li><li>when a newline is found, the bytes that have been buffered up to that point <em>are</em> a serialized message</li><li>each serialized message is immediately re-broadcast to all the connected clients</li></ul><p>In a real-world implementation, the input should be at least parsed and validated, but we will skip it here for simplicity.</p><h2 id=sockets>Sockets <a href=#sockets class=anchor>üîó</a></h2><p>We will handle socket connections using the <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/channels/AsynchronousServerSocketChannel.html target=_blank rel=noopener>Java NIO <code>AsyncServerSocketChannel</code> and <code>AsyncSocketChannel</code></a>.</p><p>The original version of this blog post used <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/net/ServerSocket.html target=_blank rel=noopener><code>java.net</code>&rsquo;s <code>ServerSocket</code> and <code>Socket</code></a>: these are <em>blocking</em> APIs, so they would take over the underlying thread of the pool. While they are usable, they require more boilerplate, and they do not make a great companion to the actor programming model. In the future (heh, <em><code>Future</code>s</em>, get it?) we may have better luck using blocking APIs on top of <a href=https://inside.java/tag/loom target=_blank rel=noopener>Project Loom</a>: then all threads will be &ldquo;virtual threads&rdquo;. But in the meantime we will have to make do.</p><p>The full story is that about one week ago I was finished polishing this blog post. Then I let my friend <a href=https://andreaperuffo.com target=_blank rel=noopener>Andrea</a> read it, and he basically rewrote the example from scratch using <code>Java NIO</code>. Indeed, the result is way simpler, but I am now here rewriting the entire blog post. Gee, thanks, I guess.</p><p>Well, the joke&rsquo;s on him, he had to re-read the entire draft.</p><p>Kidding aside, <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/channels/AsynchronousServerSocketChannel.html target=_blank rel=noopener>NIO APIs</a> plays much better with the actor runtime, and it allowed to get rid of most of the boilerplate. However, these APIs were largely developed before Java 8, so a lot of goodies such as lambdas and <code>CompletableFuture</code>s were still not available; they are thus a bit clunky to use. For your convenience, and in order not to burden too much this article, we have prepared a tiny library that you can import in your code, that wraps the callback-based APIs in <code>AsyncServerSocketChannel</code> and <code>AsyncSocketChannel</code>, into APIs that return a <code>CompletableFuture</code>.</p><p>It was designed so that you can use it from a JBang script by adding the directives:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>//REPOS mavencentral,jitpack=https://jitpack.io/
</span></span></span><span style=display:flex><span><span style=color:green>//DEPS com.github.evacchi:java-async-channels:main-SNAPSHOT
</span></span></span></code></pre></div><p>It contains only <em>two classes</em> <code>Channels.ServerSocket</code> and <code>Channels.Socket</code>. They expose the relevant methods from, respectively, <code>AsyncServerSocketChannel</code> and <code>AsyncSocketChannel</code>. They do not pretend to be a complete replacement for the real API, but they are just enough for this chat application. At the end of this blog post you will find an addendum that explains how to implement them yourself.</p><h2 id=chat-server>Chat Server <a href=#chat-server class=anchor>üîó</a></h2><p>First of all, let&rsquo;s create a &ldquo;namespace&rdquo; for our actors. In the <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>first post</a>: I chose to use an interface as a code container. The reason is that most members will be <code>public</code> <code>static</code> by default. We can initialize the actor runtime here.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>ChatServer</span> {
</span></span><span style=display:flex><span>    Actor.System system = <span style=color:#00f>new</span> Actor.System(Executors.newCachedThreadPool());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This interface will contain our <code>main</code> method and all of the <code>Behavior</code> methods and all our messages (as Java records).</p><p>In the actor-based implementation of the server, I have chosen to break down the server-related behavior into two &ldquo;root&rdquo; actors. One deals with I/O (<code>serverSocketHandler</code>) and the other (<code>clientManager</code>) orchestrates the client connections:</p><ol><li><p><code>serverSocketHandler</code> waits for incoming connection on the <code>ServerSocket</code>. When there is a new incoming connection,
it notifies the <code>clientManager</code>.</p></li><li><p><code>clientManager</code> keeps track of all the active clients. When a client sends a message, the <code>clientManager</code> is responsible for forwarding the message to all the clients.</p></li></ol><p>Let&rsquo;s see them in detail.</p><h3 id=serversockethandler><code>serverSocketHandler</code> <a href=#serversockethandler class=anchor>üîó</a></h3><p><code>serverSocketHandler</code> accepts incoming connections; when one such a connection is received, it will spawn a new <code>client</code> actor and send it to the <code>clientManager</code>.</p><p>The behavior requires a reference to the <code>clientManager</code> and a <code>Channels.ServerSocket</code> object.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Behavior serverSocketHandler(Address self, Address clientManager, Channels.ServerSocket serverSocket) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When the actor is initialized and the behavior is first evaluated, we <code>accept()</code> a new incoming connection.
The method returns a <code>CompletableFuture&lt;Channels.Socket></code>. Thus, we need to handle the succesfull and the exceptional case.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Behavior serverSocketHandler(Address self, Address clientManager, Channels.ServerSocket serverSocket) {
</span></span><span style=display:flex><span>    serverSocket.accept()
</span></span><span style=display:flex><span>            .thenAccept(skt -&gt; self.tell(<span style=color:#00f>new</span> ClientConnection(skt)))
</span></span><span style=display:flex><span>            .exceptionally(exc -&gt; { exc.printStackTrace(); <span style=color:#00f>return</span> <span style=color:#00f>null</span>; });
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the <em>exceptional</em> case, we just print the error. We may also kill the actor and restart it. As an exercise you may customize this behavior.</p><p>In the <em>successful</em> case, we send a <em>message</em> to the actor, so that it can resume processing:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record ClientConnection(Channels.Socket socket) {}
</span></span></code></pre></div><p>the actual <em>behavior</em> is then to handle such a message:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>return</span> msg -&gt; <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>    <span style=color:#00f>case</span> ClientConnection conn -&gt; {
</span></span><span style=display:flex><span>        out.printf(<span style=color:#a31515>&#34;Client connected at %s\n&#34;</span>, conn.socket().remoteAddress());
</span></span><span style=display:flex><span>        var client =
</span></span><span style=display:flex><span>                system.actorOf(ca -&gt; ChannelActor.socketHandler(ca, childrenManager, conn.socket()));
</span></span><span style=display:flex><span>        childrenManager.tell(<span style=color:#00f>new</span> ClientConnected(client));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        yield Become(serverSocketHandler(self, childrenManager, serverSocket));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>default</span> -&gt; <span style=color:#00f>throw</span> <span style=color:#00f>new</span> RuntimeException(<span style=color:#a31515>&#34;Unhandled message &#34;</span> + msg);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Upon receiving this message, we create an actor to handle the <code>Channels.Socket</code>, and then send it to the <code>clientManager</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record ClientConnected(Address addr) {}
</span></span></code></pre></div><p>then, we <em>stay</em> in this state, but we &ldquo;recurse&rdquo; by forcing the re-evaluation of this method again:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>yield Become(serverSocketHandler(self, clientManager, serverSocket));
</span></span></code></pre></div><p>because at the beginning of the method we invoke <code>accept()</code>, the result is to effectively wait for a new incoming connection.</p><h3 id=clientsockethandler><code>clientSocketHandler</code> <a href=#clientsockethandler class=anchor>üîó</a></h3><p>In the previous section we created a <code>clientSocketHandler</code>; but we haven&rsquo;t defined its behavior yet:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Behavior clientSocketHandler(Address self, Address clientManager, Channels.Socket channel) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>this actor:</p><ul><li>reads buffers from a <code>Channels.Socket</code> and tokenizes messages at each new line.</li><li>writes messages to a <code>Channels.Socket</code></li></ul><p>Let us start with reads; let us define the following messages:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record ReadBuffer(String content) {}
</span></span><span style=display:flex><span>record LineRead(String payload) {}
</span></span></code></pre></div><p>When the actor is created, we need to subscribe the channel for reading. Again, the <code>read()</code> method returns a <code>CompletableFuture&lt;String></code>, with the <code>String</code> being the buffer that has been read so far.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// subscribe the channel
</span></span></span><span style=display:flex><span><span style=color:green></span>channel.read()
</span></span><span style=display:flex><span>        .thenAccept(s -&gt; self.tell(<span style=color:#00f>new</span> ReadBuffer(s)))
</span></span><span style=display:flex><span>        .exceptionally(err -&gt; { err.printStackTrace(); <span style=color:#00f>return</span> <span style=color:#00f>null</span>; });
</span></span></code></pre></div><p>Similarly to the previous case, we handle the succesful case by sending the <code>ReadBuffer</code> message to the actor.</p><p>Now, if you recall, we need to look for newlines in the buffer, and tokenize the input; because the buffer it&rsquo;s for its nature, a &ldquo;sliding window&rdquo;, we also need to keep around an accumulator. For instance, suppose that we receive first the message &ldquo;Hi!&rdquo; from Carl and then &ldquo;Hello&rdquo; from Lenny.</p><pre tabindex=0><code>{&#34;Carl&#34;:&#34;Hi!&#34;}
{&#34;Lenny&#34;:&#34;Hello&#34;}
</code></pre><p>If the &ldquo;window&rdquo; is not large enough to contain an entire message it would need
to keep the partial message around until it finds a newline.</p><p><p class=markdown-image><img src=/assets/actor-2/sliding.gif alt="Sliding window with partial message until a newline is found"></p></p><p>We can create a &ldquo;recursive&rdquo; behavior that accumulates into <code>partial</code> the message that has been read so-far.
We make <code>partial</code> an argument of the method:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Behavior clientSocketHandler(Address self, Address clientManager, Channels.Socket channel, String partial) {
</span></span><span style=display:flex><span>    <span style=color:green>// subscribe the channel
</span></span></span><span style=display:flex><span><span style=color:green></span>    channel.read()
</span></span><span style=display:flex><span>            .thenAccept(s -&gt; self.tell(<span style=color:#00f>new</span> ReadBuffer(s)))
</span></span><span style=display:flex><span>            .exceptionally(err -&gt; { err.printStackTrace(); <span style=color:#00f>return</span> <span style=color:#00f>null</span>; });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> ReadBuffer incoming -&gt; {
</span></span><span style=display:flex><span>            var acc = (partial + incoming.content());
</span></span><span style=display:flex><span>            var eol = acc.indexOf(<span style=color:#a31515>&#39;\n&#39;</span>);
</span></span><span style=display:flex><span>            <span style=color:#00f>if</span> (eol &gt;= 0) {
</span></span><span style=display:flex><span>                var line = acc.substring(0, eol);
</span></span><span style=display:flex><span>                clientManager.tell(<span style=color:#00f>new</span> LineRead(line));
</span></span><span style=display:flex><span>                var rest = incoming.content().substring(Math.min(eol + 2, incoming.content().length()));
</span></span><span style=display:flex><span>                yield Become(socketHandler(self, clientManager, channel, rest));
</span></span><span style=display:flex><span>            } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>                var rest = partial + incoming.content();
</span></span><span style=display:flex><span>                yield Become(socketHandler(self, clientManager, channel, rest));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:green>// other cases...
</span></span></span><span style=display:flex><span><span style=color:green></span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When the recursive call is invoked, then the channel is subscribed again for reading.</p><p>This actor will also handle <em>writing</em> to the channel:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record WriteLine(String payload) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>static</span> Behavior clientSocketHandler(Address self, Address parent, Channels.Socket channel, String partial) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    msg -&gt; <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> WriteLine line -&gt; {
</span></span><span style=display:flex><span>            channel.write(line.payload());
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Stay;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#00f>default</span> -&gt; <span style=color:#00f>throw</span> <span style=color:#00f>new</span> RuntimeException(<span style=color:#a31515>&#34;Unhandled message &#34;</span> + msg);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For convenience, you may want to add the overload without the <code>partial</code> argument:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Behavior clientSocketHandler(Address self, Address parent, Channels.Socket channel, String partial) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> clientSocketHandler(self, parent, channel, <span style=color:#a31515>&#34;&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and this is the one that gets invoked upon creation of the actor in <code>serverSocketHandler</code>.
You can also make the other overload <code>private</code>.</p><h3 id=clientmanager><code>clientManager</code> <a href=#clientmanager class=anchor>üîó</a></h3><p>A <code>clientManager</code> is notified when a new client is connected, and it receives lines that are read from the input stream. Because the <code>clientManager</code> keeps track of all the <code>client</code> actors, it is able to forward them each <code>LineRead</code>.</p><p><p class=markdown-image><img src=/assets/actor-2/actor-lineread.png alt="clientManager forwards LineRead to all the connected clients"></p></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#00f>static</span> Behavior clientManager(Address self) {
</span></span><span style=display:flex><span>        var clients = <span style=color:#00f>new</span> ArrayList&lt;Address&gt;();
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> msg -&gt; {
</span></span><span style=display:flex><span>            <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>                <span style=color:#00f>case</span> ClientConnected cc -&gt; clients.add(cc.addr());
</span></span><span style=display:flex><span>                <span style=color:#00f>case</span> LineRead lr -&gt;
</span></span><span style=display:flex><span>                        clients.forEach(client -&gt; client.tell(<span style=color:#00f>new</span> WriteLine(lr.payload())));
</span></span><span style=display:flex><span>                <span style=color:#00f>default</span> -&gt; <span style=color:#00f>throw</span> <span style=color:#00f>new</span> RuntimeException(<span style=color:#a31515>&#34;Unhandled message &#34;</span> + msg);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Stay;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=starting-the-server>Starting the Server <a href=#starting-the-server class=anchor>üîó</a></h3><p>There we go! We only need to create our actors in the <code>main</code> method:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String... args) <span style=color:#00f>throws</span> IOException, InterruptedException {
</span></span><span style=display:flex><span>    var serverSocket = Channels.ServerSocket.open();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var clientManager = 
</span></span><span style=display:flex><span>            system.actorOf(self -&gt; clientManager(self));
</span></span><span style=display:flex><span>    var serverSocketHandler = 
</span></span><span style=display:flex><span>            system.actorOf(self -&gt; serverSocketHandler(self, clientManager, serverSocket));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Thread.currentThread().join(); <span style=color:green>// ensure the main thread does not quit
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>You can now start your server with JBang! Add the following lines at the top of your file:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>//JAVA 17
</span></span></span><span style=display:flex><span><span style=color:green>//JAVAC_OPTIONS --enable-preview --release 17
</span></span></span><span style=display:flex><span><span style=color:green>//JAVA_OPTIONS  --enable-preview
</span></span></span><span style=display:flex><span><span style=color:green>//REPOS jitpack=https://jitpack.io/
</span></span></span><span style=display:flex><span><span style=color:green>//DEPS com.github.evacchi:min-java-actors:main-SNAPSHOT
</span></span></span><span style=display:flex><span><span style=color:green>//DEPS com.github.evacchi:java-async-channels:main-SNAPSHOT
</span></span></span></code></pre></div><p>If everything is right, then you can type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>j! ChatServer.java
</span></span></code></pre></div><p>If you are lazy, you can run it from this URL directly:</p><pre tabindex=0><code>j! https://raw.githubusercontent.com/evacchi/min-java-actors/main/src/main/java/io/github/evacchi/asyncchat/ChatServer.java
</code></pre><p>The program will start waiting for incoming connections, printing:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Server started at /127.0.0.1:4444.
</span></span></code></pre></div><p>Neat, huh?</p><h2 id=chat-client>Chat Client <a href=#chat-client class=anchor>üîó</a></h2><p>Of course, we are not done yet. We still need to write the client app.
Luckily that is incredibly short: we only need 2 actors. To be fair, you may just dedicate one thread to each and call it a day, but for completeness, let&rsquo;s use the actor system: the result will be quite compact.</p><p>We will define:</p><ul><li>an actor that <em>reads</em> from and <em>writes</em> to the server socket</li><li>an actor that handles the messages from user input, and display incoming messages to screen</li></ul><p>Notice that, for simplicity, the messages that are written locally are not echoed immediately to screen (as it would usually happen). Instead, we will always print to screen whatever comes back from the server. Because the server always re-broadcasts <em>everything</em> to <em>everyone</em>, we will <em>also</em> effectively echo whatever the user wrote.</p><p>There is only two types of messages:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record Message(String user, String text) {}
</span></span></code></pre></div><p>In this case, the <code>Message</code> contains the nickname of the user who wrote the message, and the actual text of the message.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Actor.System system = <span style=color:#00f>new</span> Actor.System(Executors.newCachedThreadPool());
</span></span></code></pre></div><p>The <code>main</code> method:</p><ul><li>takes the nickname from the first command-line argument:</li><li>it creates the <code>client</code> actor, to handle the socket connection</li><li>it starts the input reading loop: it will read from standard input the messages
and send them to the <code>client</code>.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String HOST = <span style=color:#a31515>&#34;localhost&#34;</span>; <span style=color:#2b91af>int</span> PORT = 4444;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String[] args) <span style=color:#00f>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:green>// take the user name from the CLI args
</span></span></span><span style=display:flex><span><span style=color:green></span>    var userName = args[0];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var channel = Channels.Socket.open(HOST, PORT);
</span></span><span style=display:flex><span>    <span style=color:green>// start the `client` actor in `connecting` state.
</span></span></span><span style=display:flex><span><span style=color:green></span>    var client = system.actorOf(self -&gt; clientConnecting(self, channel));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    out.printf(<span style=color:#a31515>&#34;User &#39;%s&#39; connecting...&#34;</span>, userName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// read user input line-by-line
</span></span></span><span style=display:flex><span><span style=color:green></span>    var scann = <span style=color:#00f>new</span> Scanner(in);
</span></span><span style=display:flex><span>    <span style=color:#00f>while</span> (<span style=color:#00f>true</span>) {
</span></span><span style=display:flex><span>        var line = scann.nextLine();
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> (line != <span style=color:#00f>null</span> &amp;&amp; !line.isBlank()) {
</span></span><span style=display:flex><span>            <span style=color:green>// for each non-empty line, send a message 
</span></span></span><span style=display:flex><span><span style=color:green></span>            <span style=color:green>// with the userName and the body
</span></span></span><span style=display:flex><span><span style=color:green></span>            client.tell(<span style=color:#00f>new</span> Message(userName, line));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>where <code>Message</code> is a record defined as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record Message(String user, String text) {}
</span></span></code></pre></div><p>Let us now write the <code>main</code> routine with the initialization logic and the main user input loop.</p><p>The only thing missing are now the 2 actors!</p><h3 id=client-actor>Client Actor <a href=#client-actor class=anchor>üîó</a></h3><p>The client actor has two states:</p><ul><li>connecting</li><li>ready</li></ul><p>We will model them as two behaviors.</p><ul><li>The first behavior <code>clientConnecting</code> connects to the socket</li><li>when the connection is established it <code>Become</code>s <code>ready</code>.</li></ul><p>If any <code>Message</code> is received while connecting, it is rejected with an error message.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Actor.Behavior clientConnecting(Address self, Channels.Socket channel) {
</span></span><span style=display:flex><span>    channel.connect()
</span></span><span style=display:flex><span>            .thenAccept(skt -&gt; self.tell(<span style=color:#00f>new</span> ClientConnection(skt)))
</span></span><span style=display:flex><span>            .exceptionally(err -&gt; { err.printStackTrace(); <span style=color:#00f>return</span> <span style=color:#00f>null</span>; });
</span></span></code></pre></div><p>The <code>connect()</code> method returns a <code>Future&lt;Channels.Socket></code>. On success, we send the <code>ClientConnection</code> message
to the actor and transition to the <code>ready</code> state.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record ClientConnection(Channels.Socket socket) {}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>return</span> msg -&gt; <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>    <span style=color:#00f>case</span> ClientConnection conn -&gt; {
</span></span><span style=display:flex><span>        var socket = <span style=color:green>/// clientSocketHandler ?
</span></span></span><span style=display:flex><span><span style=color:green></span>        yield Become(clientReady(self, socket));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>you will notice that we need an actor to handle the socket. This is 100% identical to the one we wrote for the server. We can actually move that code to a <code>ChannelActor.java</code> shared library and share it across the two implementations!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>ChannelActor</span> {
</span></span><span style=display:flex><span>    record LineRead(String payload) {}
</span></span><span style=display:flex><span>    record WriteLine(String payload) {}
</span></span><span style=display:flex><span>    record ReadBuffer(String content) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>static</span> Behavior socketHandler(Address self, Address parent, Channels.Socket channel) {
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> socketHandler(self, parent, channel, <span style=color:#a31515>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>private</span> <span style=color:#00f>static</span> Behavior socketHandler(Address self, Address parent, Channels.Socket channel, String acc) {
</span></span><span style=display:flex><span>        channel.read()
</span></span><span style=display:flex><span>                .thenAccept(s -&gt; self.tell(<span style=color:#00f>new</span> ReadBuffer(s)))
</span></span><span style=display:flex><span>                .exceptionally(err -&gt; { err.printStackTrace(); <span style=color:#00f>return</span> <span style=color:#00f>null</span>; });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> msg -&gt; <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>            <span style=color:#00f>case</span> ReadBuffer buffer -&gt; {
</span></span><span style=display:flex><span>                var line = acc + buffer.content();
</span></span><span style=display:flex><span>                <span style=color:#2b91af>int</span> eol = line.indexOf(END_LINE);
</span></span><span style=display:flex><span>                <span style=color:#00f>if</span> (eol &gt;= 0) {
</span></span><span style=display:flex><span>                    parent.tell(<span style=color:#00f>new</span> Channels.Actor.LineRead(line.substring(0, eol)));
</span></span><span style=display:flex><span>                    yield Become(socketHandler(self, parent, channel, line.substring(eol + 2).trim()));
</span></span><span style=display:flex><span>                } <span style=color:#00f>else</span> yield Become(socketHandler(self, parent, channel));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#00f>case</span> WriteLine line -&gt; {
</span></span><span style=display:flex><span>                channel.write(line.payload());
</span></span><span style=display:flex><span>                yield Stay;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#00f>default</span> -&gt; <span style=color:#00f>throw</span> <span style=color:#00f>new</span> RuntimeException(<span style=color:#a31515>&#34;Unhandled message &#34;</span> + msg);
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>then update:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>case</span> ClientConnection conn -&gt; {
</span></span><span style=display:flex><span>    var socket = 
</span></span><span style=display:flex><span>            system.actorOf(ca -&gt; Channels.Actor.socketHandler(ca, self, conn.socket()));
</span></span><span style=display:flex><span>    yield Become(clientReady(self, socket));
</span></span></code></pre></div><p>and add to the header:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>//SOURCES Channels.java
</span></span></span></code></pre></div><p>you can now do the same for the <code>serverSocketHandler</code> in <code>ChatServer</code> and get rid of a bunch of duplicate code:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>case</span> ClientConnection conn -&gt; {
</span></span><span style=display:flex><span>    out.println(<span style=color:#a31515>&#34;Child connected!&#34;</span>);
</span></span><span style=display:flex><span>    var client =
</span></span><span style=display:flex><span>            system.actorOf(ca -&gt; Channels.Actor.socketHandler(ca, clientManager, conn.socket()));
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and add to the header:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>//SOURCES Channels.java
</span></span></span></code></pre></div><p>Finally, here is the code for <code>ready</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Actor.Behavior clientReady(Address self, Address socket) {
</span></span><span style=display:flex><span>    var mapper = <span style=color:#00f>new</span> ObjectMapper();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> msg -&gt; {
</span></span><span style=display:flex><span>        <span style=color:#00f>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>                <span style=color:#00f>case</span> Message m -&gt; {
</span></span><span style=display:flex><span>                    var jsonMsg = mapper.writeValueAsString(m);
</span></span><span style=display:flex><span>                    socket.tell(<span style=color:#00f>new</span> ChannelActor.WriteLine(jsonMsg));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#00f>case</span> ChannelActor.LineRead lr -&gt; {
</span></span><span style=display:flex><span>                    var message = mapper.readValue(lr.payload().trim(), Message.class);
</span></span><span style=display:flex><span>                    out.printf(<span style=color:#a31515>&#34;%s &gt; %s\n&#34;</span>, message.user(), message.text());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#00f>default</span> -&gt; <span style=color:#00f>throw</span> <span style=color:#00f>new</span> RuntimeException(<span style=color:#a31515>&#34;Unhandled message &#34;</span> + msg);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Stay;
</span></span><span style=display:flex><span>        } <span style=color:#00f>catch</span>(JsonProcessingException e) { <span style=color:#00f>throw</span> <span style=color:#00f>new</span> UncheckedIOException(e); }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this state, the client receives each line from the server (<code>LineRead</code>), deserializes it, and prints it to standard output.
It also receives each <code>Message</code> from user input. It serializes it, and then tells the server (<code>socket</code>) to write the payload on a new line (<code>WriteLine</code>).</p><h3 id=starting-the-client>Starting the Client <a href=#starting-the-client class=anchor>üîó</a></h3><p>And now you are <em>really</em> done: you can now start a client with JBang! Add the following lines at the top of your file:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>//JAVA 17
</span></span></span><span style=display:flex><span><span style=color:green>//JAVAC_OPTIONS --enable-preview --release 17
</span></span></span><span style=display:flex><span><span style=color:green>//JAVA_OPTIONS  --enable-preview
</span></span></span><span style=display:flex><span><span style=color:green>//DEPS com.fasterxml.jackson.core:jackson-databind:2.13.0
</span></span></span><span style=display:flex><span><span style=color:green>//DEPS com.github.evacchi:min-java-actors:main-SNAPSHOT
</span></span></span><span style=display:flex><span><span style=color:green>//DEPS com.github.evacchi:java-async-channels:main-SNAPSHOT
</span></span></span><span style=display:flex><span><span style=color:green>//SOURCES Channels.java
</span></span></span></code></pre></div><p>If everything is right, then you can type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>j! https://raw.githubusercontent.com/evacchi/min-java-actors/main/src/main/java/io/github/evacchi/asyncchat/ChatClient.java
</span></span></code></pre></div><p>If you are lazy, you can run it from this Gist directly (make sure the server is running!):</p><pre tabindex=0><code>j! https://raw.githubusercontent.com/evacchi/min-java-actors/main/src/main/java/io/github/evacchi/asyncchat/ChatClient.java your-nickname
</code></pre><p>The program will start waiting for incoming connections, printing something like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Login...............your-nickname
</span></span><span style=display:flex><span>Local connection..../127.0.0.1:61735
</span></span><span style=display:flex><span>Remote connection...localhost/127.0.0.1:4444
</span></span></code></pre></div><p>Here is a full demo!</p><div style=text-align:center><video controls autoplay>
<source src=/assets/actor-2/chat-demo.mp4 type=video/mp4><a href=/assets/actor-2/chat-demo.mp4>Full demo</a></video></div><h2 id=addendum-a-nio-wrapper>Addendum: A NIO Wrapper <a href=#addendum-a-nio-wrapper class=anchor>üîó</a></h2><p>For this chat application, <a href=https://andreaperuffo.com target=_blank rel=noopener>my friend Andrea</a> helped me and updated my original code using <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/channels/AsynchronousServerSocketChannel.html target=_blank rel=noopener>the JDK&rsquo;s asynchronous Socket API</a>. This API is however a bit clunky, so <a href=https://github.com/evacchi/java-async-channels target=_blank rel=noopener>we wrote some helpers to support <code>CompletableFuture</code>s</a>. <a href=https://github.com/evacchi/java-async-channels target=_blank rel=noopener>You can find a full listing here</a>.</p><p>The <code>AsynchronousServerSocketChannel</code> API provides all you need to <code>accept()</code> incoming connections from clients. For instance:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>var socketChannel = AsynchronousServerSocketChannel.open();
</span></span><span style=display:flex><span>socketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, <span style=color:#00f>true</span>);
</span></span><span style=display:flex><span>socketChannel.bind(<span style=color:#00f>new</span> InetSocketAddress(HOST, PORT_NUMBER));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>socketChannel.accept(<span style=color:#00f>null</span>, <span style=color:#00f>new</span> CompletionHandler&lt;&gt;() {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> completed(AsynchronousSocketChannel result, Void attachment) { <span style=color:green>/* handle result/attachment */</span> }
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> failed(Throwable exc, Void attachment) { <span style=color:green>/* handle exception/attachment */</span> }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>The API being asynchronous, it works through <em>callbacks</em>. Additionally, being the API from Java 1.7, it uses <em>callbacks</em> or the blocking <code>java.util.concurrent.Future</code> instead of lambdas or <code>j.u.c.CompletableFuture</code>s.</p><p>Each call to <code>accept()</code> on the <code>AsynchronousServerSocketChannel</code> results (if successful) in returning an <code>AsynchronousSocketChannel</code>, which represents a client connection.</p><p>So, roughly, this how a chat server and client should work:</p><p>The <code>AsynchronousServerSocketChannel</code> waits for connections by <code>accept()</code>ing them:</p><ul><li>every time the callback is invoked a new incoming connection (an <code>AsynchronousSocketChannel</code>) is returned.</li><li>every <code>AsynchronousSocketChannel</code> represents a client connection</li></ul><p>For each <code>AsynchronousSocketChannel</code> has been established, the <code>Server</code>:</p><ul><li>reads input from each client connection with <code>AsynchronousSocketChannel#read()</code></li><li>it broadcasts every input to the output of all client connections <code>AsynchronousSocketChannel#write()</code></li></ul><p>Both <code>read()</code> and <code>write()</code> sport the same callback-based interface:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>var buf = ByteBuffer.wrap(msgBytes);
</span></span><span style=display:flex><span>channel.write(buf, <span style=color:#00f>null</span>, <span style=color:#00f>new</span> CompletionHandler&lt;&gt;() {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> completed(Integer bytesWritten, Void ignored) { <span style=color:green>/* handle successful case */</span> }
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> failed(Throwable exc, Void ignored) { <span style=color:green>/* handle exception */</span> }
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>var buf = ByteBuffer.allocate(BUFFER_SIZE);
</span></span><span style=display:flex><span>channel.read(buf, buf, <span style=color:#00f>new</span> CompletionHandler&lt;&gt;() {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> completed(Integer bytesWritten, ByteBuffer bb) { <span style=color:green>/* handle bytesWritten/buffer */</span> }
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> failed(Throwable exc, ByteBuffer bb) { <span style=color:green>/* handle exception/buffer */</span> }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Both <code>read()</code> and <code>write()</code> use a <code>ByteBuffer</code> to represent an array of bytes.
In particular, the <code>read()</code> method reads <em>at most</em> <code>BUFFER_SIZE</code> bytes, but it may return earlier.</p><p>The <code>Client</code> connects to the server by <em>creating</em> an <code>AsynchronousSocketChannel</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>channel.connect(<span style=color:#00f>new</span> InetSocketAddress(HOST, PORT_NUMBER), attachment, <span style=color:#00f>new</span> CompletionHandler&lt;&gt;() {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> completed(Void ignored, Object attachment) { <span style=color:green>/* handle attachment */</span> }
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> failed(Throwable exc, Object attachment) { <span style=color:green>/* handle exception/attachment */</span> }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><ul><li>it <code>read()</code>s from the connection all the incoming messages</li><li>it <code>write()</code>s each incoming message to the standard output (so the user can see it)</li><li>it reads user messages from the standard input</li></ul><p>Now, order to keep our actors tidy, we may define a couple of handy private utility methods
to convert <code>CompletionHandler</code>s into <code>CompletableFuture</code>s:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Channels</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#00f>private</span> <span style=color:#00f>static</span> &lt;A, B&gt; CompletionHandler&lt;A, B&gt; handleAttachment(CompletableFuture&lt;B&gt; f) {
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> <span style=color:#00f>new</span> CompletionHandler&lt;&gt;() {
</span></span><span style=display:flex><span>            <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> completed(A result, B attachment) { f.complete(attachment); }
</span></span><span style=display:flex><span>            <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> failed(Throwable exc, B attachment) { f.completeExceptionally(exc); }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>private</span> <span style=color:#00f>static</span> &lt;A, B&gt; CompletionHandler&lt;A, B&gt; handleResult(CompletableFuture&lt;A&gt; f) {
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> <span style=color:#00f>new</span> CompletionHandler&lt;&gt;() {
</span></span><span style=display:flex><span>            <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> completed(A result, B attachment) { f.complete(result); }
</span></span><span style=display:flex><span>            <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> failed(Throwable exc, B attachment) { f.completeExceptionally(exc); }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You may use these methods directly, but instead, I created two handy wrappers for <code>AsynchronousServerSocketChannel</code> and
<code>AsynchronousSocketChannel</code>, nested under <code>Channels</code>. <code>Channels.ServerSocket</code> is a wrapper for <code>AsynchronousServerSocketChannel</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>class</span> <span style=color:#2b91af>ServerSocket</span> {
</span></span><span style=display:flex><span>    AsynchronousServerSocketChannel socketChannel;
</span></span><span style=display:flex><span>    <span style=color:#00f>private</span> ServerSocket(AsynchronousServerSocketChannel socketChannel) { <span style=color:#00f>this</span>.socketChannel = socketChannel; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>static</span> ServerSocket open() <span style=color:#00f>throws</span> IOException {
</span></span><span style=display:flex><span>        var socketChannel = AsynchronousServerSocketChannel.open();
</span></span><span style=display:flex><span>        socketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, <span style=color:#00f>true</span>);
</span></span><span style=display:flex><span>        socketChannel.bind(<span style=color:#00f>new</span> InetSocketAddress(HOST, PORT_NUMBER));
</span></span><span style=display:flex><span>        out.printf(<span style=color:#a31515>&#34;Server started at %s.\n&#34;</span>, socketChannel.getLocalAddress());
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> <span style=color:#00f>new</span> ServerSocket(socketChannel);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CompletableFuture&lt;Socket&gt; accept() {
</span></span><span style=display:flex><span>        var f = <span style=color:#00f>new</span> CompletableFuture&lt;AsynchronousSocketChannel&gt;();
</span></span><span style=display:flex><span>        socketChannel.accept(<span style=color:#00f>null</span>, handleResult(f));
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> f.thenApply(Socket::<span style=color:#00f>new</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and <code>Channels.Socket</code> wraps <code>AsynchronousSocketChannel</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>class</span> <span style=color:#2b91af>Socket</span> {
</span></span><span style=display:flex><span>    AsynchronousSocketChannel channel;
</span></span><span style=display:flex><span>    Socket(AsynchronousSocketChannel channel) { <span style=color:#00f>this</span>.channel = channel; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CompletableFuture&lt;Socket&gt; connect() {
</span></span><span style=display:flex><span>        var f = <span style=color:#00f>new</span> CompletableFuture&lt;Socket&gt;();
</span></span><span style=display:flex><span>        channel.connect(<span style=color:#00f>new</span> InetSocketAddress(HOST, PORT_NUMBER), <span style=color:#00f>this</span>, handleAttachment(f));
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> f;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>/**
</span></span></span><span style=display:flex><span><span style=color:green>     *  writes a string and concatenates a new line
</span></span></span><span style=display:flex><span><span style=color:green>     */</span>
</span></span><span style=display:flex><span>    CompletableFuture&lt;Void&gt; write(String line) {
</span></span><span style=display:flex><span>        var f = <span style=color:#00f>new</span> CompletableFuture&lt;Void&gt;();
</span></span><span style=display:flex><span>        var buf = ByteBuffer.wrap((line + END_LINE).getBytes(StandardCharsets.UTF_8));
</span></span><span style=display:flex><span>        channel.write(buf, <span style=color:#00f>null</span>, handleAttachment(f));
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> f;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    CompletableFuture&lt;String&gt; read() {
</span></span><span style=display:flex><span>        var f = <span style=color:#00f>new</span> CompletableFuture&lt;ByteBuffer&gt;();
</span></span><span style=display:flex><span>        var buf = ByteBuffer.allocate(2048);
</span></span><span style=display:flex><span>        channel.read(buf, buf, handleAttachment(f));
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> f.thenApply(bb -&gt; <span style=color:#00f>new</span> String(bb.array()));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://github.com/evacchi/java-async-channels target=_blank rel=noopener>And that&rsquo;s pretty much it.</a></p><h2 id=conclusions>Conclusions <a href=#conclusions class=anchor>üîó</a></h2><p>In this post we have learned how to write a simple chat app, and we used the <a href=https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/channels/AsynchronousServerSocketChannel.html target=_blank rel=noopener>asynchronous Socket API</a>.</p><p>As promised in the <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>previous post</a>, in the final part of this series we will revisit the actor runtime and define a <strong>fully-typed</strong> version, which will benefit from exhaustiveness checks!</p><p>I am also happy to announce that <a href=https://twitter.com/JavaAdvent/status/1457409222048636940 target=_blank rel=noopener>I have been selected</a> for the <a href=https://www.javaadvent.com/ target=_blank rel=noopener>Java Advent Calendar 2021</a>, so the last part of this series will be first published on the <a href=https://www.javaadvent.com/ target=_blank rel=noopener>Java Advent Calendar</a> website! <a href=https://twitter.com/JavaAdvent target=_blank rel=noopener>Follow them on Twitter</a> for updates!</p><p>See you there!</p></div><div class=tags><a href=/tags/java>Java</a>
<a href=/tags/records>Records</a>
<a href=/tags/jbang>JBang</a></div></section></main><footer id=footer><div class=social><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2022
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>