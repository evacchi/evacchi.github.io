<!doctype html><html lang=en-us><head><title>Wasm 4 the Java Geek 3: Electric Boogaloo | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="
  


Update (Jun 20, 2025). This post was originally published at JVM Advent.

And here we are again. For the third time in a row, we are back to the Java Advent, eager to discover what‚Äôs new with WebAssembly from a Java developer perspective.
Incidentally, since, as you know, I have a favorite topic (after programming languages and compilers, of course), it is also the third time in a row I have worked at a different company."><meta name=generator content="Hugo 0.148.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Wasm 4 the Java Geek 3: Electric Boogaloo</h1><div class=tip><time datetime="2024-12-18 00:00:00 +0000 UTC">Dec 18, 2024</time>
<span class=split>¬∑
</span><span>3826 words
</span><span class=split>¬∑
</span><span>18 minute read</span></div><div class=content><p><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/wasm-4-java-geek-3.jpg?w=1292&amp;ssl=1" alt></p></p><div style=padding:1em;background:#eee><b>Update (Jun 20, 2025)</b>. This post was originally published at <a href=https://www.javaadvent.com/2024/12/wasm-4-the-java-geek-3-electric-boogaloo.html>JVM Advent</a>.</div><p>And here we are again. For the third time in a row, we are back to the Java Advent, eager to discover what‚Äôs new with WebAssembly from a Java developer perspective.</p><p>Incidentally, since, as you know, I have a <a href="https://www.javaadvent.com/2023/12/a-return-to-webassembly-for-the-java-geek.html#:~:text=WHAT%20HAS%20CHANGED%20SINCE%20LAST%20TIME%3F" target=_blank rel=noopener>favorite topic</a> (after programming languages and compilers, of course), it is also the <strong>third time in a row</strong> I have worked at a different company.</p><p>The <a href=https://www.javaadvent.com/2022/12/webassembly-for-the-java-geek.html target=_blank rel=noopener>first time</a> I was at Red Hat, <a href=https://www.javaadvent.com/2023/12/a-return-to-webassembly-for-the-java-geek.html target=_blank rel=noopener>last year</a> I was at Tetrate, and this year I joined <a href=https://dylibso.com target=_blank rel=noopener>Dylibso</a>. Maybe <a href=https://dylibso.com target=_blank rel=noopener><strong>Dylibso</strong></a> does <em>jingle</em> a bell (see what I just did there? Come on, it‚Äôs Java <em>Advent</em>), or maybe it does not. But if you have followed this award-winning series of blog posts, you might remember Dylibso <a href=https://extism.org target=_blank rel=noopener>for the Extism framework</a>. Extism is an easy-to-use cross-platform framework to write plugins for several languages using the same API across languages.</p><p>To that end, we use and contribute to quite a few runtimes; for instance, we use <a href=https://wazero.io target=_blank rel=noopener>wazero</a> (the runtime <a href="https://www.javaadvent.com/2023/12/a-return-to-webassembly-for-the-java-geek.html#:~:text=WHAT%20HAS%20CHANGED%20SINCE%20LAST%20TIME%3F" target=_blank rel=noopener>I have been contributing to for the last year and a half at Tetrate</a>) for our <a href=https://github.com/extism/go-sdk target=_blank rel=noopener>Go SDK</a>. Dylibso started and have been sponsoring the development of the pure-Java <a href=https://chicory.dev target=_blank rel=noopener>Chicory runtime</a> which has recently hit its <a href=https://chicory.dev/blog/chicory-1.0.0-M1 target=_blank rel=noopener>first 1.0 milestone release</a>. We‚Äôll talk more about that later!</p><p>Finally, we have also just released a cool new <a href=https://getxtp.com target=_blank rel=noopener>product called <strong>XTP</strong> that builds and extends Extism</a> with type-safe bindings, codegen and a plug-in delivery system! More on that later too!</p><h2 id=is-this--about-front-end>Is This ü´¥ü¶ã About Front-End? <a href=#is-this--about-front-end class=anchor>üîó</a></h2><p>Well, yes, and no. Have you been living under a rock or is this your first Java Advent? Just kidding.</p><div style=width:375px;float:left><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/is-this-a-pigeon-srsly.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/is-this-a-pigeon-srsly.png?resize=365%2C273&amp;ssl=1" alt="The &ldquo;is this a pigeon meme&rdquo;, but the guy looks a too frowning."></p></a></p><p>Dude, seriously?</p></div><p>Sure, Wasm was originally created to bring a safe, sandboxed execution environment to the browser, leveraging the existing JS runtime. But the Wasm spec is relatively smaller than the bulk of a full JS implementation, and, as such, a constellation of pure-Wasm runtimes was born: these smaller, lighter-weight runtimes can be used as stand-alone language VMs (similarly to a JVM), or as embededded language hosts, as you would usually do for a scripting language, except that they are language-agnostic.</p><p>In fact, Wasm is a <strong>language-agnostic compilation target</strong> and any compiler is free to generate it: that makes it a great binary format to distribute <strong>cross-platform software extensions</strong> (i.e. plug-ins) that can be hosted in <em>any</em> ‚Äúhost‚Äù application.</p><p>In the last few years, we have seen the CNCF cloud-native landscape extend, and promote this new technology, to the point that <a href="https://landscape.cncf.io/?group=wasm" target=_blank rel=noopener>Wasm itself has now its own section in the CNCF software landscape</a>. Wasm is now for all intents and purposes considered one of the CNCF official technologies for ‚ÄúCloud-Native development‚Äù: this extends well-beyond the browser!</p><p>But how does this affect you, as a Java developer? Similarly to the other years, in this blog post, I will explore two main topics:</p><ul><li><strong>front-end development</strong>, compiling a JVM language into Wasm</li><li><strong>back-end development</strong> running Wasm on top of a JVM</li></ul><h2 id=the-front-end>The Front-End <a href=#the-front-end class=anchor>üîó</a></h2><p>Wasm was always meant to make the Web platform more efficient. That‚Äôs one reason why browsers and state-of-the-art JavaScript runtimes such as V8, JavaScriptCore and Spidermonkey, will probably <em>always</em> be at the forefront, when it comes to implementing practical, but bleeding-edge features. After all, for better or worse, that‚Äôs how Web development goes.</p><p>This is also why often these runtimes <strong>adopt experimental features of the Wasm spec</strong>, way before other, smaller runtimes. This is expected, considering also the workforce that is often beyond major web browsers.</p><p><a href=https://www.javaadvent.com/2023/12/a-return-to-webassembly-for-the-java-geek.html target=_blank rel=noopener>Last year</a> we explained how Wasm behaves more like a native target, than a JVM. This is, to some extent, still true: most WebAssembly runtimes do not support much beyond the so-called ‚Äúlinear memory‚Äù, threading support is still hit and miss, and the exception handling spec was revised a few times, finally hitting the last stage at the end of last year.</p><p>However, today all major browsers now support garbage-collected references, exception handling, and, through some shims, even threaded execution. All of these features are particularly important when it comes to supporting higher-level, managed, garbage-collected languages such as those hosted on the Java platform.</p><p>It is indeed feasible to support these features even in a native-like compilation target: after the GraalVM Native Image builder does just that. And Go <em>is</em> a higher-level, managed, garbage-collected, multi-threaded language and both TinyGo and ‚ÄúBig‚Äù Go can now be compiled to Wasm that runs perfectly in self-contained Wasm runtimes such as <a href=https://wasmtime.dev target=_blank rel=noopener>Wasmtime</a>, <a href=https://wazero.io target=_blank rel=noopener>wazero</a> or <a href=https://chicory.dev target=_blank rel=noopener>chicory</a>.</p><p>However, this comes with the cost of inflating the resulting binary, with baggage such as a garbage collector, emulating exception handlers, emulating multi-threading.</p><p>I believe this situation will continue for a while; that is, smaller runtimes, especially if they want to keep their footprint small, and especially if their <em>development team</em> is small, will generally be very conservative when it comes to implementing new, experimental part of the specs.</p><p>But it‚Äôs good that browsers are the front-runners: they have better resourcing, and hence can afford to support these experiments earlier. And besides, it makes sense for the Web to try to keep binary sizes down. For other use cases, we will see, this is less of a concern.</p><p>In the following I will show 3 compiler toolchains that generate Wasm, but still mainly target the browser.</p><p>Feeling <a href=https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.prcj59904 target=_blank rel=noopener>fatigued</a> already? We‚Äôre just getting started!</p><h3 id=kotlin>Kotlin <a href=#kotlin class=anchor>üîó</a></h3><div style=width:375px;float:left><p><p class=markdown-image><img src=https://lh4.googleusercontent.com/proxy/Dy9akvPnvjj7g9HZX2HabbfJZU5VyCuQkHAtnutrZOIpCmyNJ8Zj6X8DELrxBwGxz-TpU_150Gjk6ax2wUKXPf0LLII4CQwXnDY alt></p></p><p>Pic related: A Kotlin jar</p></div><p>Kotlin was one of the first JVM languages that targeted the browser with their JavaScript backend. Over the years, they gained a native compiler, and also, starting off as a flavor of their native compiler, a Wasm compiler.</p><p>The Kotlin team has recently switched their Wasm compiler backend to WasmGC and the Exception Handling proposal, resulting in smaller file sizes. However, this required a major overhaul of the compiler architecture, because a Wasm binary that targets the linear memory <a href=https://www.javaadvent.com/2023/12/a-return-to-webassembly-for-the-java-geek.html target=_blank rel=noopener>behaves more like a native target</a>, while targeting WasmGC is a bit closer to how JVM class files are represented.</p><p>Luckily, with their familiarity with targeting both the JVM and JavaScript, even though it was no small feat, we now have a functional Kotlin compiler for Wasm that works for <a href=https://kotlinlang.org/docs/wasm-troubleshooting.html#exception-handling-proposal target=_blank rel=noopener>on all runtimes supporting the GC and Exception Handling specs</a>.</p><p>To get started, you can head over to <a href=https://github.com/Kotlin/kotlin-wasm-browser-template target=_blank rel=noopener>this Kotlin Wasm template</a>.</p><p>I believe that the Kotlin toolchain is currently the most impressive and advanced when it comes to practical use cases for JVM language: the teams at Jetbrains have already ported <a href=https://www.jetbrains.com/compose-multiplatform/ target=_blank rel=noopener>Compose Multiplatform</a> to it. This that, you can already today port complex applications that will run both on mobile platforms and in the browser, with the convenience of using one modern, familiar programming language!</p><p>Kudos to the team!</p><h3 id=scala>Scala <a href=#scala class=anchor>üîó</a></h3><p>Scala was a pioneer in the JVM language ecosystem for many reasons; it helped revive the attention to the Java platform with a new, concise and practical programming language, in a time where the Java language was still very conservative.</p><p>It is also one of the first JVM languages to gain <a href=https://www.scala-js.org/ target=_blank rel=noopener>support for a JavaScript compiler</a>.</p><p>End users have been asking for a Wasm backend for a while. But the JavaScript backend was pretty practical and battle-tested; so the team deferred this sizable effort until there was reasonable support for some key features, such as, for instance (again!) garbage collected objects.</p><p>In the meantime, the alternative <a href=https://github.com/shadaj/scala-native-wasm target=_blank rel=noopener>Scala Native backend initially experimented with it</a>. Now, the Scala.js team has decided to finally take on this effort, as the feature gap in browsers is closing more and more.</p><p>As documented on the <a href=https://www.scala-js.org/doc/project/webassembly.html target=_blank rel=noopener>Scala.js website</a> the Wasm backend is still in its infancy, and it comes with some experimental requirements (including garbage collected references, and exception handling support). It is also primarily targeting browsers, and as such, it still emits some chunks of JavaScript.</p><p>For some examples, check out <a href=https://github.com/keynmol/scalajs-wasm-game-of-life target=_blank rel=noopener>keynmol/scalajs-wasm-game-of-life</a> and <a href=https://github.com/sjrd/funlabyrinthe-scala target=_blank rel=noopener>https://github.com/sjrd/funlabyrinthe-scala</a>.</p><h3 id=java>Java <a href=#java class=anchor>üîó</a></h3><p>I mentioned <a href=https://www.teavm.org/ target=_blank rel=noopener>TeaVM</a> multiple times in the past. TeaVM has recently <a href=https://github.com/konsoletyper/teavm/discussions/963 target=_blank rel=noopener>switched their backend to WasmGC</a>.</p><p>The <a href=https://github.com/google/j2cl target=_blank rel=noopener>J2CL</a> project is the successor to GWT. This project is extensively used at Google, to the point that you are probably already using it even if you don‚Äôt realize it. For instance, <a href=https://web.dev/case-studies/google-sheets-wasmgc target=_blank rel=noopener>Google Sheets</a> is using Wasm. Check out <a href="https://www.youtube.com/watch?v=2En8cj6xlv4" target=_blank rel=noopener>WebAssembly at Google by Thomas Steiner & Thomas Nattestadt</a>. And since you are there, you might want to check out Thomas Steiner‚Äôs podcast, <a href="https://youtu.be/gJPYvv1flJY?list=PLNYkxOF6rcIA46I-YCX3ASF4SRb548z8s" target=_blank rel=noopener>WasmAssembly</a> there is also an episode interviewing <a href="https://youtu.be/gJPYvv1flJY?list=PLNYkxOF6rcIA46I-YCX3ASF4SRb548z8s" target=_blank rel=noopener>our very own Steve</a>, talking about all things <a href=https://extism.org target=_blank rel=noopener>Extism</a>, including <a href=https://chicory.dev target=_blank rel=noopener>Chicory</a>!</p><p>Read more on <a href=https://github.com/google/j2cl/blob/master/docs/getting-started-j2wasm.md target=_blank rel=noopener>how to use J2CL with Wasm here</a>.</p><h3 id=graalvm-native-image>GraalVM Native Image <a href=#graalvm-native-image class=anchor>üîó</a></h3><p>All the languages we have mentioned earlier, have something in common: they all generate Wasm code starting from source code. This means that the Kotlin compiler compiles Kotlin code, the Scala compiler compiles Scala code, and the TeaVM and J2CL compilers compile Java code. ‚ÄúWell, duh‚Äù, I hear you say.</p><div style=width:375px;float:right><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/graalvm-mascot-coffeecup.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/graalvm-mascot-coffeecup.png?resize=500%2C500&amp;ssl=1" alt></p></a></p><p>The brand new GraalVM Mascot</p></div><p>On the other hand, GraalVM native image builds a binary starting from class files, making it possible to generate binaries for <em>any</em> language that typically runs on a JVM. So, considering the history of Wasm compilers so far, it would be really cool if they also started to build upon the experience they made with the Native Image builder, and implement a new backend for WebAssembly.</p><p>Oh boy, do I have news for you! It turns out that the GraalVM team <em>is</em> in fact working on a Wasm backend that will target browsers and state-of-the-art JavaScript runtimes such as V8 (at least at the beginning).</p><p>The work is being <a href=https://github.com/oracle/graal/issues/3391 target=_blank rel=noopener>actively tracked on GitHub</a>. I had the chance to take a look at an early demo, where a fully functional <code>javac</code> ran in the browser. The compiler is targeting WASI too, so, you should also be able to run it with Node, and, when more will catch up, with all the other self-contained Wasm runtimes.</p><p>There is some work to do but the direction is extremely exciting!</p><h3 id=honorable-mentions>Honorable Mentions <a href=#honorable-mentions class=anchor>üîó</a></h3><p>I am always fascinated with the excellent work at <a href=https://leaningtech.com/ target=_blank rel=noopener>LeaningTech</a>, so, even though it‚Äôs kind of a different stack, I want to mention the herculean work that this team is doing in porting code to the browser. Besides their <strong>very recent relaunch of their x86 in-browser VM</strong>, this time including a GUI, they also provide commercial support to compiling C++ and Flash to Wasm.</p><p>I believe one of the crown jewels is their Java runtime stack called <a href=https://leaningtech.com/what-is-cheerpj/ target=_blank rel=noopener>CheerpJ</a>, which they <em>also</em> recently relaunched. It is a <a href=https://cheerpj.com/how-cheerpj-works/ target=_blank rel=noopener>sophisticated port of a proper OpenJDK to Wasm that JIT-compiles bytecode into Wasm for optimal performance</a>, and contained code size. They can also run <a href=https://cheerpj.com/cheerpj-applet-runner/ target=_blank rel=noopener>Java Applets</a> and <a href=https://cheerpj.com/cheerpj-jnlp-runner/ target=_blank rel=noopener>JNLP</a> without a Java runtime installed on the desktop. That‚Äôs pretty neat!</p><h2 id=backend>Backend <a href=#backend class=anchor>üîó</a></h2><p>Wasm in the browsers is definitely here to stay, but the thing about this ecosystem that interests me the most is Wasm workloads in the backend. Wasm is on the <a href=https://www.thoughtworks.com/content/dam/thoughtworks/documents/radar/2024/10/tr_technology_radar_vol_31_en.pdf target=_blank rel=noopener>ThoughtWorks 2024 Tech Radar</a></p><p>This year a lot has happened there too. But how does it impact JVM developers?</p><p>Last year, a surprising <a href=https://www.javaadvent.com/2023/12/chicory-wasm-jvm.html target=_blank rel=noopener>Christmas gift for all Java developers was the first global official announcement of the Chicory interpreter</a>. While at the time the project was in an early development stage, it was already quite capable! Last October <a href=https://chicory.dev/blog/chicory-1.0.0-M1 target=_blank rel=noopener>we announced our first milestone release</a>, including, next to the interpreter, a new experimental bytecode translator (the ‚ÄúAoT compiler‚Äù), that turns Wasm bytecode into JVM Wasm for improved performance. Check it out and let us all know!</p><p>The GraalVM team also <a href=https://medium.com/graalvm/whats-new-in-graal-languages-24-1-b2452c9debae target=_blank rel=noopener>recently announced</a> that their <a href=https://www.graalvm.org/webassembly/ target=_blank rel=noopener>Wasm support can be now considered stable</a> and ready for production, with the benefit of all their past and present experience with developing languages for the JVM.</p><p>This means that it‚Äôs a great time to get started with Wasm support on the JVM. But what are the best use cases you can cover with a Wasm runtime that runs on a JVM? Isn‚Äôt this redundant? Why would you want to load a foreign bytecode format (Wasm) on a bytecode language runtime (i.e., your beloved JVM)?</p><p>There are many use cases, but I want to start from possibly the most niche and counterintuitive, because it‚Äôs cursed, and it feels wrong, and yet sometimes it makes so much sense.</p><h3 id=native-libraries-without-jni>Native Libraries Without JNI <a href=#native-libraries-without-jni class=anchor>üîó</a></h3><div style=text-align:center;font-style:italic><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/hat-1062061_640.jpg?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/hat-1062061_640.jpg?resize=600%2C450&amp;ssl=1" alt="A Panama Hat"></p></a></p><p>Did you know that ‚ÄúJNI‚Äù is supposed to be read as ‚ÄúGenie‚Äù? No? That‚Äôs because I just made that up (image by <a href="https://pixabay.com/users/natashag-363234/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1062061" target=_blank rel=noopener>Natasha G</a> from <a href="https://pixabay.com//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1062061" target=_blank rel=noopener>Pixabay</a>)</p></div><p>‚ÄúLOL look at this one,‚ÄùJNI‚Äù: we‚Äôve got <a href=https://openjdk.org/projects/panama/ target=_blank rel=noopener><strong>Panama</strong></a>, now, you boomer!‚Äù Right. Of course, <strong>Panama</strong> will finally bring a saner developer experience to interfacing with a native library.</p><p>However, you still have to deal with all of the limitations of interfacing with native code; essentially,</p><ul><li>the garbage collector and the threads (virtual and native!) may not play along well with it;</li><li>plus, a memory corruption bug in your native code could tear down your entire JVM.</li><li>finally, your build is now tied to the specific CPU architectures that your native library provides support for (this may not depend on you!)</li></ul><p>Now, it would be most excellent if you could just bring a native library to JVM land, and be done with it. Some projects attempted this before:</p><ul><li><a href=http://nestedvm.ibex.org/ target=_blank rel=noopener>NestedVM</a> was a wonderfully cursed project that translated binaries for the MIPS architecture to Java bytecode. Unfortunately it hasn‚Äôt released a new version since 2009.</li><li><a href=https://github.com/oracle/graal/tree/master/sulong target=_blank rel=noopener>GraalVM‚Äôs Sulong</a> is a high-performance LLVM bitcode runtime; i.e. it evaluates LLVM‚Äôs intermediate binary representation. One downside is that LLVM bitcode is <a href=https://dl.acm.org/doi/10.1145/3062341.3062363 target=_blank rel=noopener>known to be unstable</a>.</li></ul><p>The key difference is that, this time</p><ol><li>1a lot of compilers are including first-party support for Wasm, so it‚Äôs easier to cross-compile to this target and check whether it‚Äôs working.</li><li>the Web itself is huge, and a lot of developers are interested in porting well-written, performance-conscious libraries to use in their Web application</li></ol><p>As a consequence, it‚Äôs becoming easier to find a port of a traditionally ‚Äúnative‚Äù library to Wasm, and if that port exists, it is (<a href="https://tetrate.io/blog/introducing-wazero-from-tetrate/#:~:text=Or%2C%20maybe%20you%20would%20rather%20play%20the%201977%20Infocom%20text%20adventure%20Zork." target=_blank rel=noopener>in my limited experience with ancient code</a>) safe to assume that the binary will run.</p><p>So how would this help you? Granted, this is a niche use case, but there are situations where the one library you need is written in C or Rust, and you just want to be able to use that bit of functionality; maybe you just want to bootstrap your project (then in the future you will rewrite it), or maybe it‚Äôs just enough for your use case.</p><div style=width:210px;float:right><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/jruby.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/jruby.png?resize=200%2C200&amp;ssl=1" alt="JRuby Logo"></p></a></p></div><p>One example is JRuby‚Äôs team <a href=https://blog.jruby.org/2024/02/jruby-prism-parser#web-assembly-chicory target=_blank rel=noopener>port of the Prism Ruby parser</a>, where they successfully used Chicory as a fallback on platforms where the native binary may not be available.</p><p>There are many other examples in the Go space, because the wazero project is much more mature than Chicory, and the Go ecosystem has already employed it successfully in many cases: in fact the Go runtime has a surprising number of similarities when it comes to limitations with interfacing with native code. My favorite must be <a href=https://xeiaso.net/blog/carcinization-golang/ target=_blank rel=noopener>Xe Iaso‚Äôs ‚ÄúCarcinization of Go Programs‚Äù</a>, because everyone should run a Rust library from a Go program to parse Mastodon‚Äôs toots. But there is also the large collection of <a href=https://github.com/wasilibs target=_blank rel=noopener>wasilibs</a>, native tools re-built on top of wazero (including things like several plugins for <strong>protoc</strong>).</p><p>Another great example is <a href=https://github.com/ncruces/go-sqlite3 target=_blank rel=noopener>Nuno Cruces‚Äô Go SQLite Wasm port</a>, built on top of wazero, <a href=https://github.com/cvilsmeier/go-sqlite-bench target=_blank rel=noopener>is competitive in many ways</a> with other alternatives. Indeed, there is also an experimental SQLite port of SQLite to Chicory called <a href=https://github.com/dylibso/sqlite-zero target=_blank rel=noopener>sqlite-zero</a>.</p><p>The GraalVM team has also shared on their brand-new <a href=https://www.graalvm.org/latest/reference-manual/wasm/ target=_blank rel=noopener>GraalWasm landing page</a> <a href=https://github.com/graalvm/graal-languages-demos/tree/main/graalwasm/graalwasm-embed-c-code-guide/ target=_blank rel=noopener>an example of embedding C code running as a Wasm binary</a>.</p><p>And, of course, you can run Doom in Swing using both <a href=https://github.com/stepstone-tech/doom-graalvm target=_blank rel=noopener>GraalWasm</a> and <a href=https://github.com/andreaTP/doom-chicory target=_blank rel=noopener>Chicory</a>.</p><h3 id=bringing-computations-in-core>Bringing Computations In-Core <a href=#bringing-computations-in-core class=anchor>üîó</a></h3><p>Wasm has caught the attention of many as a <em>compact alternative to containers</em>.</p><p>Indeed, serverless workloads are an excellent candidate for Wasm: you get a cross-platform, efficient, executable binary representation that can be compiled into fast native code. And, of course, the grumpy Java developer in you might mumble something about application servers, but hopefully <a href=https://www.javaadvent.com/2022/12/webassembly-for-the-java-geek.html target=_blank rel=noopener>we have already addressed</a> that Wasm is not just ‚Äúexactly the same‚Äù as Java Bytecode. Companies such as <a href=https://fermyon.com target=_blank rel=noopener>Fermyon</a> and <a href=https://cosmonic.com target=_blank rel=noopener>Cosmonic</a> are building software platforms of this kind. CDN companies such as <a href=https://fastly.com target=_blank rel=noopener>Fastly</a> or <a href=https://cloudflare.com target=_blank rel=noopener>Cloudflare</a> are putting Wasm-computations at the edge.</p><p>But besides serverless containers, there is another space where cloud deployments could be replaced by Wasm ‚Äúfunctions‚Äù. This is when a service plays the role of a logic ‚Äúextension‚Äù to another service.</p><p>In this sense, such a service, be it a <em>sidecar</em>, be it a <em>Webhook</em> (or whatever fancy words you kids call them these days) can be often seen as a glorified ‚Äúplug-in‚Äù.</p><p><a href=https://shopify.dev/docs/apps/build/functions target=_blank rel=noopener>Shopify with their ‚Äúfunctions‚Äù</a> were among the first mainstream platforms to adopt Wasm to that end.</p><p>There are a few reasons why Wasm is a good candidate for plugin embedding. First of all, it was <em>explicitly designed</em> to work in concert with JavaScript, which, nowadays, is the ‚Äúextension language‚Äù for excellence! It was designed with the necessities of the web platform in mind: namely, security and sandboxing; in fact, it cannot access any feature of the host language without being explicitly given access to them (through what are called ‚Äúhost functions‚Äù). And obviously being cross-platform, efficient and compact.</p><div style=width:320px;float:right><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/extism.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/extism.png?resize=300%2C320&amp;ssl=1" alt="Extism logo"></p></a></p></div><p><a href=https://dylibso.org target=_blank rel=noopener>Dylibso</a> believes that all software should be ‚Äúsquishy‚Äù: that is, malleable, adaptable, and extensible; so they developed <a href=https://extism.org target=_blank rel=noopener>Extism</a>, an open-source framework to build your own ‚Äúfunction-as-a-service‚Äù layer <em>inside</em> your application. Or, to put it more simply, to easily embed your own plug-in system. At the time of writing Extism supports 16 ‚Äúhost‚Äù runtime platforms and over 10 ‚Äúguest‚Äù languages to write your plugin (and counting!). Notably, for the Go host, Extism uses <a href=https://wazero.io target=_blank rel=noopener>wazero</a>, and for the Java platform, we are finalizing our <a href=https://github.com/extism/chicory-sdk target=_blank rel=noopener>Chicory SDK</a> (Java is <a href=https://github.com/extism/java-sdk target=_blank rel=noopener>already supported through a native extension</a> though).</p><div style=width:220px;float:left><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/xtp-logo.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/12/xtp-logo.png?resize=200%2C150&amp;ssl=1" alt="XTP Logo"></p></a></p></div><p>Dylibso has also recently released an integrated platform for plugin delivery and management called <a href=https://getxtp.com target=_blank rel=noopener>XTP</a>, building on top of Extism and OpenAPI. Essentially, if you have an API manifest for your service, you should feel at home bringing it to Extism. The codegen and testing toolset is all available free of charge. For instance, we have an example of <a href=https://www.getxtp.com/blog/adding-extensibility-to-twenty-a-modern-crm target=_blank rel=noopener>how to port the API for the Twenty CRM and scaffold your own plug-in system</a> and another example of how to write a <a href=https://www.getxtp.com/blog/extending-discord-with-wasm target=_blank rel=noopener>programmable Discord bot</a>.</p><p>What makes Wasm interesting as a JDK extension language is that it supports multiple languages, and the guest can be preemptively terminated, <strong>preventing it from hogging the CPU</strong>. Moreover, user-provided Wasm code can be safely loaded and unloaded in a controlled environment, making it an excellent choice for hosting <a href=https://dylibso.com/blog/pg-extism/ target=_blank rel=noopener>user-defined functions in a database</a>.</p><p>The GraalVM team has also released a set of <a href="https://www.graalvm.org/webassembly/#:~:text=GraalWasm%20Quick%20Start" target=_blank rel=noopener>compelling use cases for GraalWasm</a>, including integrations with <a href=https://github.com/graalvm/graal-languages-demos/tree/main/graalwasm/graalwasm-starter target=_blank rel=noopener>Micronaut</a> and <a href=https://github.com/graalvm/graal-languages-demos/tree/main/graalwasm/graalwasm-spring-boot-photon target=_blank rel=noopener>Spring Boot</a>!</p><h4 id=more-complex-use-cases>More Complex Use Cases <a href=#more-complex-use-cases class=anchor>üîó</a></h4><p>I have recently written a few use cases for Extism, Chicory and XTP. Both the following examples support compilation into a native binary, while retaining dynamic code loading capabilities.</p><h5 id=kafka-data-transforms>Kafka Data Transforms <a href=#kafka-data-transforms class=anchor>üîó</a></h5><p>I have recently written an article on how to plug Chicory, Extism and XTP inside a <strong>native Quarkus application</strong> to build a Kafka data transform service. In this article I am giving a detailed explanation of how to use Extism, the XTP codegen tooling, and the XTP service to manage a data transform pipeline. <a href=https://www.getxtp.com/blog/pluggable-stream-processing-with-xtp-and-kafka target=_blank rel=noopener>Sounds intriguing? Check it out</a></p><p><a href=https://www.getxtp.com/blog/pluggable-stream-processing-with-xtp-and-kafka target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/cdn.loom.com/sessions/thumbnails/80dca9fa50bd46688ebca87b0fd58f6f-537f741734826116-full-play.gif?w=600&amp;ssl=1" alt></p></a></p><p>There is also a follow-up in the pipeline, where I‚Äôll explore <strong>extending the Kafka broker</strong> to the same effect. Stay tuned!</p><h5 id=quarkus-wasm-extension-demo>Quarkus Wasm Extension Demo <a href=#quarkus-wasm-extension-demo class=anchor>üîó</a></h5><p>In the <a href=https://github.com/evacchi/extism-quarkus-greeting-app target=_blank rel=noopener>Quarkus Wasm Extension</a> demo, I have implemented a middleware-style HTTP filter that you would usually run in a proxy or an API gateway like Envoy or NGINX using some API like <a href=https://github.com/proxy-wasm target=_blank rel=noopener>Proxy-Wasm</a>. Through the Quarkus extension and Chicory, you can compile the executable to a native image and load and reload extensions dynamically. <a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/11/request-proxy.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/11/request-proxy.png?resize=600%2C390&amp;ssl=1" alt></p></a></p><p>Essentially, a proxy such as Envoy implements a chain of HTTP request filters, it intercepts your requests, and then passes them through the filter. However, this requires you to deploy a fleet of proxies as sidecars alongside your application. On the one hand, makes it easier to manage policies from a central control plane; on the other hand, it might raise operational costs, because now you have even <em>more services</em> to deal with! Instead, you can turn some of these policies into interceptors inside your Quarkus application!</p><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/11/request-embedded.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2024/11/request-embedded-1024x720.png?resize=600%2C422&amp;ssl=1" alt></p></a></p><p>By cutting on the middleman, you are turning a complex multi-container deployment into a single application deployment! Pair that with XTP, and then you also get the missing control plane for your plugin policies!</p><h3 id=native-dynamic-software-extensions>Native DYNAMIC Software Extensions <a href=#native-dynamic-software-extensions class=anchor>üîó</a></h3><p>Did I just mention <strong>dynamic code loading</strong> with Native Image? Indeed, I just did. One of the original limitations for an executable built into a native image, was the infamous ‚Äúclosed world assumption‚Äù, essentially, you have to instruct the native image builder about all the classes you expect to need at run-time, especially if you load them dynamically through run-time code reflection.</p><p>Limitations with reflections are however nowadays largely solved, because a lot more tooling is available to automatically inspect your record and report it to the compiler; there are <a href=https://www.graalvm.org/jdk21/reference-manual/native-image/dynamic-features/Reflection/ target=_blank rel=noopener>embedded JSON manifests as well as automatic detection mechanisms</a>; besides frameworks like <a href=https://quarkus.io target=_blank rel=noopener>Quarkus</a> provide also sophisticated code-generation mechanisms that extend GraalVM‚Äôs built-in routines.</p><p>There have been also ways to dynamically load code: you can <a href=https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/JNI/ target=_blank rel=noopener>link against native libraries</a> or you can use the <a href=https://www.graalvm.org/latest/reference-manual/espresso/ target=_blank rel=noopener>Espresso Truffle runtime</a>.</p><p><a href=https://www.graalvm.org/latest/reference-manual/espresso/ target=_blank rel=noopener>Espresso is particularly interesting because it‚Äôs another example of a VM-in-a-VM:</a> it‚Äôs literally an implementation of the Java VM Specification that runs <em>on top</em> of another JVM. While, at a very first glance, this could feel like an intellectual experiment (you could probably run an Espresso instance on top of another Espresso instance, and then‚Ä¶ it‚Äôs Espresso all the way down), it makes a lot of sense if you build one inside a native image! Then you can have your fast-to-boot, tiny, efficient, self-contained executable, and yet be able to load Java code in a sandboxed environment! You can literally have your cake and eat it too.</p><p>Now, why would you want to use Wasm instead? Well, because, why limit yourself to JVM languages? A Wasm runtime will allow you to dynamically load <em>any</em> Wasm code from your users!</p><p>If you are interested in this use case, read the details in the <a href=https://www.getxtp.com/blog/pluggable-stream-processing-with-xtp-and-kafka target=_blank rel=noopener>Extism+XTP Kafka demo</a>, and the <a href=https://github.com/evacchi/extism-quarkus-greeting-app target=_blank rel=noopener>Quarkus Wasm Extension Demo</a>.</p><h2 id=conclusions>Conclusions <a href=#conclusions class=anchor>üîó</a></h2><p>It‚Äôs been a wonderful year for Wasm in the Java space. I hope this article sparked your interest too!</p><p>If you want to learn more about <a href=https://extism.org target=_blank rel=noopener>Extism</a> and <a href=https://getxtp.com target=_blank rel=noopener>XTP</a>, you can join us on our <a href="https://discord.gg/RWUN5SytPs?event=1303763128370200666" target=_blank rel=noopener>Discord</a>, where we host <a href="https://discord.gg/RWUN5SytPs?event=1303763128370200666" target=_blank rel=noopener>weekly office hours on Wednesdays</a>: ask all your questions about Wasm, Extism, XTP.</p><p>If you are especially interested in <a href=https://chicory.dev target=_blank rel=noopener>Chicory</a>, you can also join our <a href=https://chicory.zulipchat.com/join/g4gqsxoys6orfxlrk6hn4cyp/ target=_blank rel=noopener>Zulip</a>; and if you are the odd Gopher reading a Java blog, you might want to join the <a href=https://gophers.slack.com/archives/C040AKTNTE0 target=_blank rel=noopener>#wazero channel too</a>.</p><p>Finally, if <a href=https://extism.org target=_blank rel=noopener>Extism</a> and <a href=https://getxtp.com target=_blank rel=noopener>XTP</a> sparked your interest and you‚Äôd like to have some fun with extending <a href=https://claude.ai/ target=_blank rel=noopener>Claude.ai</a> (and other LLMs supporting the <a href=https://modelcontextprotocol.io/docs/ target=_blank rel=noopener>Model Context Protocol</a>) you might want to check out our brand-new project: <a href=https://www.mcp.run/ target=_blank rel=noopener><strong>mcp.run</strong></a>.</p></div></section></main><footer id=footer><div class=social><a class="symbol bluesky" href=https://bsky.app/profile/evacchi.dev rel=me target=_blank></a><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2025
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg>
</span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>