<!doctype html><html lang=en-us><head><title>Wasm the Hard Way: Porting the Chicory Compiler to Android | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="
    

I am resurrecting my old &ldquo;Wasm the Hard Way&rdquo; series with some fresh new content about a recent project I have been working on: porting the Chicory Wasm compiler to Android.
If you are interested in Wasm and Java, you might have heard about Chicory, a pure-Java Wasm runtime. Ever since I started working at Dylibso, I have been contributing to the project.
Extism is Dylibso&rsquo;s family of open-source projects to develop and host WebAssembly (Wasm) plugins. Going forward, we believe the Chicory SDK is a solid foundation for running Wasm modules in Java applications, making it our default Wasm runtime for Extism on the Java platform. We&rsquo;re putting our money where our mouth is: the mcpx4j library for running mcp.run servlets is built on top of the Chicory SDK."><meta name=generator content="Hugo 0.148.2"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Wasm the Hard Way: Porting the Chicory Compiler to Android</h1><div class=tip><time datetime="2025-07-11 00:00:00 +0000 UTC">Jul 11, 2025</time>
<span class=split>¬∑
</span><span>4626 words
</span><span class=split>¬∑
</span><span>22 minute read</span></div><div class=content><div style=float:right;width:50%><img src=/assets/chicory-android/robochicory.png alt=Robochicory width=100%></div><p>I am resurrecting my old <a href=/tags/wasm/>&ldquo;Wasm the Hard Way&rdquo;</a> series with some fresh new content about a recent project I have been working on: porting the <a href=https://chicory.dev target=_blank rel=noopener>Chicory</a> Wasm compiler to Android.</p><p>If you are interested in Wasm and Java, you might have heard about <a href=https://chicory.dev target=_blank rel=noopener>Chicory</a>, a pure-Java Wasm runtime. Ever since I started working at <a href=https://dylibso.com target=_blank rel=noopener>Dylibso</a>, I have been contributing to the project.</p><p><a href=https://extism.org target=_blank rel=noopener>Extism</a> is Dylibso&rsquo;s family of open-source projects to develop and host WebAssembly (Wasm) plugins. Going forward, we believe the <a href=https://github.com/extism/chicory-sdk target=_blank rel=noopener>Chicory SDK</a> is a solid foundation for running Wasm modules in Java applications, making it our default Wasm runtime for Extism on the Java platform. We&rsquo;re putting our money where our mouth is: the <a href=https://github.com/dylibso/mcpx4j target=_blank rel=noopener>mcpx4j</a> library for running <a href=https://www.mcp.run target=_blank rel=noopener>mcp.run servlets</a> is built on top of the Chicory SDK.</p><p>At Dylibso, we have also been working on <a href=https://www.mcp.run target=_blank rel=noopener>mcp.run</a>, a platform for writing, sharing and evaluating <a href=https://docs.mcp.run/blog/2025/04/07/mcp-run-security target=_blank rel=noopener>secure, sandboxed MCP &ldquo;servlets&rdquo;</a>. The secret sauce of course remains Wasm, as the foundations are still laid on <a href=https://extism.org target=_blank rel=noopener>Extism</a> and our <a href=https://getxtp.com target=_blank rel=noopener>XTP</a> plugin registry.</p><p>Because Chicory is written in Java, it can run on any platform that supports the Java language. In fact, it is <a href=https://docs.mcp.run/blog/2024/12/27/running-tools-on-android/ target=_blank rel=noopener>pretty easy to run the Chicory interpreter on Android</a>. But the Chicory runtime is not just an interpreter: it also includes <a href=https://chicory.dev/blog/chicory-1.4.0 target=_blank rel=noopener>a compiler</a> that translates Wasm into Java bytecode!</p><p>Unfortunately, the Android platform does not run Java bytecode, but Dalvik bytecode (DEX files). The Android toolchain translates Java bytecode into Dalvik bytecode at build-time. Does that mean you can use the Chicory compiler to translate Wasm into Dalvik bytecode? Well, yes‚Äîbut it heavily depends on your use case.</p><p>This blog post documents why and how we ported the Chicory compiler to Android, the challenges we faced, and how we solved them. We also document how we are now testing the Android backend of the Chicory compiler, which deviates from how Android apps are usually developed. Ever wondered how to run and debug code on Android without the overhead of the Android Instrumentation framework? Read on!</p><h2 id=porting-chicory-to-android>Porting Chicory to Android <a href=#porting-chicory-to-android class=anchor>üîó</a></h2><p>As mentioned, the Chicory compiler can run at build-time or at run-time. The build-time flavor translates Wasm into Java bytecode and dumps the result into class files on disk. The run-time compiler loads this same bytecode dynamically, allowing you to load and run Wasm modules on-the-fly.</p><p>The interpreter is our reference implementation; as runtime maintainers, our key priority is keeping it easy to understand, debug and test. Development tends to move faster than the compiler: features are developed and tested first in the interpreter, then ported to the compiler as they stabilize. Therefore, the interpreter is meant to follow the spec rather strictly, not to be efficient. The compiler, on the other hand, is useful when you want to run Wasm modules with better performance.</p><p>The <strong>build-time compiler</strong> is the best pick when the Wasm modules you want to run are <strong>known at build-time</strong>. For instance, if a specific library has been ported to Wasm, you can convert it to Java bytecode and use it as plain Java code: this is the case for <a href=https://github.com/roastedroot/sqlite4j target=_blank rel=noopener>sqlite4j</a>, a library that allows you to run SQLite databases in pure-Java.</p><p>On the other hand, you will reach for the <strong>run-time compiler</strong> when you want to run Wasm modules that are <strong><em>not</em> known at build-time</strong>. This is where Wasm&rsquo;s sandboxing capabilities shine: your users can extend the software you write, while you can rest easy knowing that these untrusted Wasm binaries run in a secure environment. This is the primary use case when your Wasm binaries are Extism plugins!</p><p>Now, while Java bytecode can normally be translated into Dalvik bytecode at build-time, this approach falls short if you want to <strong>load Wasm modules dynamically</strong>. The problem is that while most Java APIs for classloading and reflection work on Android, you cannot simply generate Java bytecode and load it into an Android class-loader, because that&rsquo;s not the bytecode format Android expects.</p><p>Well, that&rsquo;s alright‚Äîyou might say‚Äîwe can just translate the Java bytecode into Dalvik bytecode at run-time. If only! At the time of writing, there is no convenient tooling to perform that translation on-device.</p><p>There is, however, a bytecode engineering library called <a href=https://github.com/linkedin/dexmaker/ target=_blank rel=noopener>DexMaker</a>. DexMaker&rsquo;s main purpose is to allow you to generate Dalvik bytecode at run-time. The library is better known as a tool for generating dynamic proxies and as a dependency of <a href=https://site.mockito.org/ target=_blank rel=noopener>Mockito</a> for dynamically generating mocks.</p><p>So we thought: why not use DexMaker to generate Dalvik bytecode from Wasm at run-time?</p><h2 id=dex-bytecode-vs-java-bytecode>DEX bytecode vs Java bytecode <a href=#dex-bytecode-vs-java-bytecode class=anchor>üîó</a></h2><p>The Dalvik bytecode format is a distant relative of Java bytecode, with one fundamental difference: Dalvik is register-based rather than stack-based. This means Dalvik instructions operate on registers instead of a stack of values, making the mapping between the two formats non-trivial.</p><p>In a modern Android toolchain, your build tool produces Java bytecode, which is then translated into Dalvik bytecode by the <a href=https://developer.android.com/studio/command-line/d8 target=_blank rel=noopener>d8 tool</a> from the Android SDK. The <a href=https://developer.android.com/tools/d8 target=_blank rel=noopener>d8 bytecode translator</a> follows a traditional multi-stage compiler architecture: it translates Java bytecode into an intermediate representation (IR), performs instruction selection and optimization, handles register allocation, and finally outputs Dalvik bytecode. <a href=https://github.com/linkedin/dexmaker/ target=_blank rel=noopener>DexMaker</a> layers on top of d8, abstracting away these low-level details to provide a more streamlined API for generating Dalvik bytecode.</p><p>This means we need a separate Android backend for the Chicory compiler that works with register-based instructions. We can still reuse a lot of the JVM compiler code, but we have to watch out for the differences between the two approaches‚Äîespecially with control-flow structures like branches and loops, where registers and stacks work pretty differently.</p><p>Consider this example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#2b91af>int</span> example() {
</span></span><span style=display:flex><span>    <span style=color:#2b91af>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>int</span> param1 = 1;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>int</span> param2 = 2;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>while</span> (1) {
</span></span><span style=display:flex><span>        <span style=color:#2b91af>int</span> sum = param1 + param2;
</span></span><span style=display:flex><span>        x = sum;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> (!(x &lt; 10)) {
</span></span><span style=display:flex><span>            <span style=color:#00f>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:green>// Prepare for next iteration
</span></span></span><span style=display:flex><span><span style=color:green></span>        param1 = sum;
</span></span><span style=display:flex><span>        param2 = 3;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The equivalent Wasm code would look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>  (func (export <span style=color:#a31515>&#34;example&#34;</span>) (result i32)
</span></span><span style=display:flex><span>    (local $x i32)
</span></span><span style=display:flex><span>    (i32.const 1)
</span></span><span style=display:flex><span>    (i32.const 2)
</span></span><span style=display:flex><span>    (loop (param i32 i32) (result i32)
</span></span><span style=display:flex><span>      (i32.add)
</span></span><span style=display:flex><span>      (local.tee $x)
</span></span><span style=display:flex><span>      (i32.const 3)
</span></span><span style=display:flex><span>      (local.get $x)
</span></span><span style=display:flex><span>      (i32.const 10)
</span></span><span style=display:flex><span>      (i32.lt_u)
</span></span><span style=display:flex><span>      (br_if 0)
</span></span><span style=display:flex><span>      (drop)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  )
</span></span></code></pre></div><p>The equivalent Java bytecode is relatively straightforward, because the JVM is also stack-based. The loop condition is checked at the end of the loop, and the parameters are updated at the end of each iteration.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// Method: func_0(Lcom/dylibso/chicory/runtime/Memory;Lcom/dylibso/chicory/runtime/Instance;)I</span>
</span></span><span style=display:flex><span><span style=color:green>// Stack: 3, Locals: 3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 0: iconst_0          <span style=color:green>// push 0 (initialize local variable)</span>
</span></span><span style=display:flex><span> 1: istore 2          <span style=color:green>// x = 0 (local variable initialization)</span>
</span></span><span style=display:flex><span> 2: iconst_1          <span style=color:green>// push 1 (loop param 1)</span>
</span></span><span style=display:flex><span> 3: iconst_2          <span style=color:green>// push 2 (loop param 2)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:green>// Loop start L0 - stack: [param1, param2]</span>
</span></span><span style=display:flex><span> 4: iadd              <span style=color:green>// add top two stack values -&gt; stack: [sum]</span>
</span></span><span style=display:flex><span> 5: dup               <span style=color:green>// duplicate sum -&gt; stack: [sum, sum]</span>
</span></span><span style=display:flex><span> 6: istore 2          <span style=color:green>// store sum in local x -&gt; stack: [sum]</span>
</span></span><span style=display:flex><span> 7: iconst_3          <span style=color:green>// push 3 -&gt; stack: [sum, 3]</span>
</span></span><span style=display:flex><span> 8: iload 2           <span style=color:green>// load x -&gt; stack: [sum, 3, x]</span>
</span></span><span style=display:flex><span> 9: bipush 10         <span style=color:green>// push 10 -&gt; stack: [sum, 3, x, 10]</span>
</span></span><span style=display:flex><span>10: invokestatic com/dylibso/chicory/runtime/OpcodeImpl.I32_LT_U (II)I  <span style=color:green>// compare x &lt; 10 -&gt; stack: [sum, 3, result]</span>
</span></span><span style=display:flex><span>11: ifeq L1           <span style=color:green>// if result == 0 (false), exit loop -&gt; stack: [sum, 3]</span>
</span></span><span style=display:flex><span>12: invokestatic com/dylibso/chicory/runtime/Memory.checkInterruption ()V  <span style=color:green>// interruption check -&gt; stack: [sum, 3]</span>
</span></span><span style=display:flex><span>13: <span style=color:#00f>goto</span> L0           <span style=color:green>// loop back -&gt; stack: [sum, 3] (these become new params)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// Loop exit L1 - stack: [sum, 3]</span>
</span></span><span style=display:flex><span>14: pop               <span style=color:green>// remove the 3 -&gt; stack: [sum]</span>
</span></span><span style=display:flex><span>15: ireturn           <span style=color:green>// return sum</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// Local variable table:</span>
</span></span><span style=display:flex><span><span style=color:green>// 0: Memory parameter</span>
</span></span><span style=display:flex><span><span style=color:green>// 1: Instance parameter  </span>
</span></span><span style=display:flex><span><span style=color:green>// 2: x (local variable)</span>
</span></span></code></pre></div><p>A relatively direct Dalvik translation could pre-allocate the registers assigning them specific roles,
and ensure that they are preserved as invariants across iterations. In the following, the <code>v0</code> register
is used to hold the loop result, <code>v1</code> and <code>v2</code> are the loop parameters, and <code>v3</code> is the sum.
The loop condition checks if the sum is less than 10, and if so, it continues iterating.</p><pre tabindex=0><code class=language-dalvik data-lang=dalvik>;; ... function prologue (reads args etc) ...
0011: const/4             v1 #1 #1     ; param1 = 1
0012: const/4             v2 #2 #2     ; param2 = 2
0013: add-int             v3, v1, v2   ; sum = param1 + param2
0015: move/from16         v0, v3       ; loop result = sum (allocated at loop header)
0017: const/16            v4 #3 #3     ; constant 3 (pushed to stack)
0019: move/from16         v5, v0       ; setup comparison operand 1
001b: const/16            v6 #10 #10   ; setup comparison operand 2
001d: invoke-static/range Lcom/dylibso/chicory/runtime/OpcodeImpl;-&gt;I32_LT_U(II)I {v5, v6}  ; compare loop_result &lt; 10
0020: move-result         v7           ; branch condition result
0021: move/from16         v1, v3       ; param1 = sum (loop param update)
0023: move/from16         v2, v4       ; param2 = 3 (loop param update)
0025: move/from16         v0, v4       ; loop result = current stack top (systematic update)
0027: if-eqz              v7 -&gt; 002d   ; if condition false, exit loop
0029: invoke-static       Lcom/dylibso/chicory/experimental/android/aot/AotMethods;-&gt;checkInterruption()V {}  ; runtime interruption check
002c: goto                -&gt; 0013      ; continue loop
002d: move/from16         v0, v3       ; loop result = final sum (systematic update)
;; ... function epilogue (return the values) ...
</code></pre><p>The loop result is consistently maintained in <code>v0</code>, which is allocated at the loop header (0011) and updated at each iteration (0025) and at the final exit (002d).
Notice how, at the end of the loop, we ensure that <code>v0</code>, <code>v1</code> and <code>v2</code> are updated with the latest values, so, as we re-enter the loop, the registers hold the correct values for the next iteration.</p><p>The main limitation of this approach is that it will waste a few registers, and generate a few more moves than strictly necessary. However this makes the compiler simpler: while more sophisticated approaches could be used to optimize the register usage, they could add overhead to the compiler and slow it down. We will revisit this in the future, but for now, we are happy with this approach.</p><h2 id=runtime-limitations>Runtime Limitations <a href=#runtime-limitations class=anchor>üîó</a></h2><p>Even though nowadays Android devices can be pretty beefy, you cannot give resources for granted. In particular, to ensure a smooth user experience, the ART runtime poses some limitations on the amount of memory and stack space that can be used by an application. Let&rsquo;s see what these limitations are, and how we can work around them.</p><h3 id=limitations-on-the-stack-size>Limitations on the Stack Size <a href=#limitations-on-the-stack-size class=anchor>üîó</a></h3><p>Threads on the Dalvik runtime default to a stack size of <strong>1 MB</strong>. This is a strict limit on the <code>main</code> thread, which is usually the one running the UIlogic. If you try to run a Wasm module that uses more than 1 MB of stack space, you will get a <code>java.lang.StackOverflowError</code>.</p><p>Add to that, that <strong>dynamically-loaded</strong> code is usually not pre-compiled to native code, and in fact, in most cases it will initially run in the Dalvik interpreter! This is not only a performance issue (that would be fine when we are only running tests): it also means that the stack usage is higher than it would be if the code was compiled to native code. For instance, this a snippet from the stacktrace of a recursive function:</p><pre tabindex=0><code>--------- beginning of crash
F libc    : Fatal signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0x6ddb4fd000 in tid 27607 (roidJUnitRunner), pid 27566 (ndroid.aot.test)
E crash_dump64: failed to get the guest state header for thread 27566: Bad address
E crash_dump64: failed to get the guest state header for thread 27567: Bad address
...
I crash_dump64: obtaining output fd from tombstoned, type: kDebuggerdTombstoneProto
I tombstoned: received crash request for pid 27607
I crash_dump64: performing dump of process 27566 (target tid = 27607)
F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
F DEBUG   : Build fingerprint: &#39;google/sdk_gphone64_arm64/emu64a:15/AE3A.240806.043/12960925:userdebug/dev-keys&#39;
F DEBUG   : Revision: &#39;0&#39;
F DEBUG   : ABI: &#39;arm64&#39;
F DEBUG   : Timestamp: 2025-07-11 11:18:25.911063122+0200
F DEBUG   : Process uptime: 2s
F DEBUG   : Cmdline: com.dylibso.chicory.android.aot.test
F DEBUG   : pid: 27566, tid: 27607, name: roidJUnitRunner  &gt;&gt;&gt; com.dylibso.chicory.android.aot.test &lt;&lt;&lt;
F DEBUG   : uid: 10238
F DEBUG   : tagged_addr_ctrl: 0000000000000001 (PR_TAGGED_ADDR_ENABLE)
F DEBUG   : pac_enabled_keys: 000000000000000f (PR_PAC_APIAKEY, PR_PAC_APIBKEY, PR_PAC_APDAKEY, PR_PAC_APDBKEY)
F DEBUG   : signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0x0000006ddb4fd000
F DEBUG   :     x0  0000006ddb4faa80  x1  0000000000000000  x2  00000000000107a8  x3  0000006ddb4fd000
F DEBUG   :     x4  0000006ddb50d7e8  x5  0000000000000004  x6  0000006ddb50daf8  x7  0000006d5565be76
F DEBUG   :     x8  0000000000012d70  x9  0000006ddb50d7f0  x10 00000000000025a5  x11 0000006ddfb79040
F DEBUG   :     x12 0000006ddfb79040  x13 00000000000025a5  x14 0000006ddb50d7c8  x15 b400006fa33821b0
F DEBUG   :     x16 0000006de0224c10  x17 0000007082a97bc0  x18 0000006d528f8000  x19 b400006eb33a56a0
F DEBUG   :     x20 0000006ddb50db40  x21 0000006de040d000  x22 b400006f933820d0  x23 0000006ddb4faa80
F DEBUG   :     x24 0000006d00213840  x25 00000000000025a5  x26 0000000000012d28  x27 00000000000025a5
F DEBUG   :     x28 0000000000000003  x29 0000006ddb50d8d0
F DEBUG   :     lr  0000006ddfb5b774  sp  0000006ddb4faa80  pc  0000007082a97c84  pst 0000000020001000
F DEBUG   : 512 total frames
F DEBUG   : backtrace:
F DEBUG   :       #00 pc 0000000000055c84  /apex/com.android.runtime/lib64/bionic/libc.so (__memset_aarch64+196) (BuildId: 1b9fecf834d610f77e641f026ca7269b)
F DEBUG   :       #01 pc 000000000035b770  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+476) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #02 pc 000000000076da48  /apex/com.android.art/lib64/libart.so (void art::interpreter::ExecuteSwitchImplCpp&lt;false&gt;(art::interpreter::SwitchImplContext*)+12208) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #03 pc 000000000037b5d8  /apex/com.android.art/lib64/libart.so (ExecuteSwitchImplAsm+8) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #04 pc 00000000000004a8  [anon:dalvik-DEX data] (com.dylibso.chicory._gen.CompiledMachine_Chunk0.func_0+0)
...
F DEBUG   :       #69 pc 00000000000023b4  [anon:dalvik-DEX data] (com.dylibso.chicory._gen.CompiledMachine.call+0)
F DEBUG   :       #70 pc 000000000034e21c  /apex/com.android.art/lib64/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame&amp;, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.2845697060370838518)+428) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #71 pc 000000000035c5b0  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+4124) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #72 pc 000000000076da48  /apex/com.android.art/lib64/libart.so (void art::interpreter::ExecuteSwitchImplCpp&lt;false&gt;(art::interpreter::SwitchImplContext*)+12208) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #73 pc 000000000037b5d8  /apex/com.android.art/lib64/libart.so (ExecuteSwitchImplAsm+8) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #74 pc 000000000000168c  /data/app/~~mVADCp0l4u2tmGTofEPdqQ==/com.dylibso.chicory.android.aot.test-irCJzP1P57Ywof2WQebRvg==/base.apk (com.dylibso.chicory.experimental.android.aot.TestAotAndroidMachine.call+0)
F DEBUG   :       #75 pc 000000000034e21c  /apex/com.android.art/lib64/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame&amp;, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.2845697060370838518)+428) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #76 pc 000000000035c5b0  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+4124) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #77 pc 000000000076da48  /apex/com.android.art/lib64/libart.so (void art::interpreter::ExecuteSwitchImplCpp&lt;false&gt;(art::interpreter::SwitchImplContext*)+12208) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #78 pc 000000000037b5d8  /apex/com.android.art/lib64/libart.so (ExecuteSwitchImplAsm+8) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #79 pc 000000000036a664  /data/app/~~mVADCp0l4u2tmGTofEPdqQ==/com.dylibso.chicory.android.aot.test-irCJzP1P57Ywof2WQebRvg==/base.apk (com.dylibso.chicory.runtime.Instance$Exports.lambda$function$0$com-dylibso-chicory-runtime-Instance$Exports+0)
F DEBUG   :       #80 pc 000000000034e21c  /apex/com.android.art/lib64/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame&amp;, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.2845697060370838518)+428) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #81 pc 000000000035c5b0  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+4124) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #82 pc 000000000076da48  /apex/com.android.art/lib64/libart.so (void art::interpreter::ExecuteSwitchImplCpp&lt;false&gt;(art::interpreter::SwitchImplContext*)+12208) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #83 pc 000000000037b5d8  /apex/com.android.art/lib64/libart.so (ExecuteSwitchImplAsm+8) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #84 pc 000000000036a464  /data/app/~~mVADCp0l4u2tmGTofEPdqQ==/com.dylibso.chicory.android.aot.test-irCJzP1P57Ywof2WQebRvg==/base.apk (com.dylibso.chicory.runtime.Instance$Exports$$ExternalSyntheticLambda0.apply+0)
F DEBUG   :       #85 pc 000000000034e21c  /apex/com.android.art/lib64/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame&amp;, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.2845697060370838518)+428) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #86 pc 000000000035c5b0  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+4124) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #87 pc 000000000076da48  /apex/com.android.art/lib64/libart.so (void art::interpreter::ExecuteSwitchImplCpp&lt;false&gt;(art::interpreter::SwitchImplContext*)+12208) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #88 pc 000000000037b5d8  /apex/com.android.art/lib64/libart.so (ExecuteSwitchImplAsm+8) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #89 pc 00000000002aa140  /data/app/~~mVADCp0l4u2tmGTofEPdqQ==/com.dylibso.chicory.android.aot.test-irCJzP1P57Ywof2WQebRvg==/base.apk (com.dylibso.chicory.test.gen.SpecV1FacTest.test1+0)
F DEBUG   :       #90 pc 000000000034d5a8  /apex/com.android.art/lib64/libart.so (artQuickToInterpreterBridge+1932) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #91 pc 0000000000379098  /apex/com.android.art/lib64/libart.so (art_quick_to_interpreter_bridge+88) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #92 pc 0000000000362774  /apex/com.android.art/lib64/libart.so (art_quick_invoke_stub+612) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #93 pc 000000000035e36c  /apex/com.android.art/lib64/libart.so (_jobject* art::InvokeMethod&lt;(art::PointerSize)8&gt;(art::ScopedObjectAccessAlreadyRunnable const&amp;, _jobject*, _jobject*, _jobject*, unsigned long)+540) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #94 pc 00000000006c87f8  /apex/com.android.art/lib64/libart.so (art::Method_invoke(_JNIEnv*, _jobject*, _jobject*, _jobjectArray*) (.__uniq.165753521025965369065708152063621506277)+32) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #95 pc 00000000001c8670  [anon_shmem:dalvik-jit-code-cache] (offset 0x2000000) (art_jni_trampoline+144)
F DEBUG   :       #96 pc 0000000000362774  /apex/com.android.art/lib64/libart.so (art_quick_invoke_stub+612) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #97 pc 000000000035bd1c  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+1928) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #98 pc 000000000076da48  /apex/com.android.art/lib64/libart.so (void art::interpreter::ExecuteSwitchImplCpp&lt;false&gt;(art::interpreter::SwitchImplContext*)+12208) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #99 pc 000000000037b5d8  /apex/com.android.art/lib64/libart.so (ExecuteSwitchImplAsm+8) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
...
F DEBUG   :       #509 pc 00000000004b3d5c  /data/app/~~mVADCp0l4u2tmGTofEPdqQ==/com.dylibso.chicory.android.aot.test-irCJzP1P57Ywof2WQebRvg==/base.apk (org.junit.runners.ParentRunner.access$100+0)
F DEBUG   :       #510 pc 000000000034e21c  /apex/com.android.art/lib64/libart.so (art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame&amp;, art::JValue, bool, bool) (.__uniq.112435418011751916792819755956732575238.llvm.2845697060370838518)+428) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
F DEBUG   :       #511 pc 000000000035c5b0  /apex/com.android.art/lib64/libart.so (bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+4124) (BuildId: dcb9fe2b5c99aa3f1a682a6008427d08)
E tombstoned: Tombstone written to: tombstone_31
I Zygote  : Process 27566 exited due to signal 11 (Segmentation fault)
I adbd    : Remote process closed the socket (on MSG_PEEK)
I libprocessgroup: Removed cgroup /sys/fs/cgroup/uid_10238/pid_27566
D InetDiagMessage: Destroyed 0 sockets, proto=IPPROTO_TCP, family=AF_INET, states=14
D InetDiagMessage: Destroyed 0 sockets, proto=IPPROTO_TCP, family=AF_INET6, states=14
D InetDiagMessage: Destroyed live tcp sockets for uids={10238} in 2ms
I app_process: System.exit called, status: 0
I AndroidRuntime: VM exiting with result code 0.
D InetDiagMessage: Destroyed 0 sockets, proto=IPPROTO_TCP, family=AF_INET, states=14
D InetDiagMessage: Destroyed 0 sockets, proto=IPPROTO_TCP, family=AF_INET6, states=14
D InetDiagMessage: Destroyed live tcp sockets for uids={20238} in 0ms
I netd    : tetherGetStats() -&gt; {[]} &lt;0.34ms&gt;
</code></pre><p>As you might notice from the stack trace above, for each guest function call, the Dalvik interpreter introduces 3 stack frames!
That makes it quite easy to hit the stack overflow limit, especially if you are running a Wasm module that has a lot of nested function calls.</p><pre tabindex=0><code>(art::interpreter::Execute(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame&amp;, art::JValue, bool, bool) 
(bool art::interpreter::DoCall&lt;false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, bool, art::JValue*)+4124) 
(void art::interpreter::ExecuteSwitchImplCpp&lt;false&gt;(art::interpreter::SwitchImplContext*)+12208) 
...
</code></pre><p>Now, even though this limit cannot be overcome on the main thread, you can still create a new thread with a custom stack size. This is generally the recommended way to run long computations on Android, as it allows you to avoid blocking the main thread and keep the UI responsive. The default stack size is still 1MB, but you can <a href=https://developer.android.com/reference/java/lang/Thread#Thread%28java.lang.ThreadGroup,%20java.lang.Runnable,%20java.lang.String,%20long%29 target=_blank rel=noopener>configure the stack size of a thread when you create it.</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#00f>var</span> stackSize = 8 * 1024 * 1024;
</span></span><span style=display:flex><span>    <span style=color:#00f>var</span> t = <span style=color:#00f>new</span> Thread(
</span></span><span style=display:flex><span>            <span style=color:#00f>new</span> ThreadGroup(<span style=color:#a31515>&#34;chicory-thread-group&#34;</span>), 
</span></span><span style=display:flex><span>            myRunnable, 
</span></span><span style=display:flex><span>            <span style=color:#a31515>&#34;chicory-thread&#34;</span>,
</span></span><span style=display:flex><span>            stackSize);
</span></span></code></pre></div><p>There is still one big caveat; when you spawn a thread with a custom stack size, apparently you will get less guarantees from the Dalvik runtime. In particular, in our experiments, sometimes you might get a hard crash, instead of a managed StackOverflowError!</p><pre tabindex=0><code>Fatal signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0x7284415700 in tid 4791 (thread), pid 4754 (ndroid.aot.test)
Cmdline: com.dylibso.chicory.android.aot.test
pid: 4754, tid: 4791, name: thread  &gt;&gt;&gt; com.dylibso.chicory.android.aot.test &lt;
      #04 pc 00000000000004a8  /data/data/com.dylibso.chicory.android.aot.test/cache/chicory196337394512609375/com/dylibso/chicory/_gen/CompiledMachine_Chunk0/classes.dex (com.dylibso.chicory._gen.
      #09 pc 00000000000004a8  /data/data/com.dylibso.chicory.android.aot.test/cache/chicory196337394512609375/com/dylibso/chicory/_gen/CompiledMachine_Chunk0/classes.dex (com.dylibso.chicory._gen.
      #14 pc 00000000000004a8  /data/data/com.dylibso.chicory.android.aot.test/cache/chicory196337394512609375/com/dylibso/chicory/_gen/CompiledMachine_Chunk0/classes.dex (com.dylibso.chicory._gen.
      #19 pc 00000000000004a8  /data/data/com.dylibso.chicory.android.aot.test/cache/chicory196337394512609375/com/dylibso/chicory/_gen/CompiledMachine_Chunk0/classes.dex (com.dylibso.chicory._gen.
      #24 pc 00000000000004a8  /data/data/com.dylibso.chicory.android.aot.test/cache/chicory196337394512609375/com/dylibso/chicory/_gen/CompiledMachine_Chunk0/classes.dex (com.dylibso.chicory._gen.
      #29 pc 00000000000004a8  /data/data/com.dylibso.chicory.android.aot.test/cache/chicory196337394512609375/com/dylibso/chicory/_gen/CompiledMachine_Chunk0/classes.dex (com.dylibso.chicory._gen.
      #34 pc 00000000000004a8  /data/data/com.dylibso.chicory.android.aot.test/cache/chicory196337394512609375/com/dylibso/chicory/_gen/CompiledMachine_Chunk0/classes.dex (com.dylibso.chicory._gen.
// ... rest omitted ...
</code></pre><p>At this time we are not aware of a simple way to avoid this issue, but there is still a lot of work to do!</p><h2 id=memory-management>Memory Management <a href=#memory-management class=anchor>üîó</a></h2><p>Finally, we managed to make all the spec tests pass on Android. Great, now let&rsquo;s move onto some real-world Wasm modules! We started with the <a href=https://www.mcp.run/dylibso/fetch target=_blank rel=noopener>mcp.run <code>fetch</code> servlet</a>, which is a Wasm module that fetches a webpage from a URL and returns it as Markdown. I was pretty bummed when ART started throwing a <code>java.lang.OutOfMemoryError</code>. Looking more closely, I noticed that the offender was the Chicory compiler itself, which was using more than <strong>200MB</strong> of heap space!</p><p>Now, everybody knows that the JVM has limitations on class file size and method count. The Dalvik runtime has similar constraints, with a limit of <strong>65535 methods</strong> per class file. So, on the JVM compiler, we generate multiple class files when the class file grows over 50k methods; if a function is too large, we just fall back to the interpreter. This works well on the JVM, but it is not enough on Android; it is mostly an issue related to the way DexMaker works. DexMaker retains the complete intermediate representation of all the generated methods in memory until the final DEX file is generated. This means that if you generate a lot of methods, the memory usage can grow significantly, especially if the methods are large.</p><p>Luckily, the solution is relatively straightforward: split class files at a lower boundary (currently 200 methods per &ldquo;chunk&rdquo;). This approach finally allowed us to &ldquo;make <a href=https://www.mcp.run/dylibso/fetch target=_blank rel=noopener><code>fetch</code></a> happen&rdquo;!</p><h2 id=testing-the-android-backend>Testing the Android backend <a href=#testing-the-android-backend class=anchor>üîó</a></h2><p>Android&rsquo;s development tooling is not designed for this kind of lower-level work. Testing Android applications on device, typically uses the <a href=https://developer.android.com/training/testing/ target=_blank rel=noopener>Android Instrumentation framework</a>. The instrumentation framework is a powerful tool but comes with significant overhead; among other things, it transfers a lot of metadata between the host and the device. This is ok for end-to-end, integration testing, where flows are usually long and complex, but not so much for unit testing, where you want to run a lot of tests quickly.</p><p>Moreover, while the instrumentation framework is the default way to run tests on the device, most unit tests are usually run on the host machine on a plain JVM; even when Android-specific APIs are involved, <a href=https://robolectric.org/ target=_blank rel=noopener>Roboelectric</a> simulates the Android environment, allowing you to run tests without the overhead of the instrumentation framework.</p><p>Unfortunately, none of this applies to our case: the JVM can&rsquo;t load DEX bytecode, and the Chicory compiler <em>must</em> be tested on ART.</p><p>Some work <a href=https://github.com/dylibso/chicory/tree/main/android-tests target=_blank rel=noopener>has been done to run the test suite against the interpreter</a>. Even though there is some overhead, it is manageable, because the interpreter can be tested and debugged on a traditional JVM. On Android we only ensure that there aren&rsquo;t any platform-specific issues.</p><p>However, running the entire Wasm spec test suite against the Android compiler with the instrumentation framework takes about <strong>8 minutes</strong> in Android Studio, and about <strong>4 minutes</strong> using Gradle on the command line. This is not terrible, but it is still a lot of time to wait for a test suite to run, especially when you are iterating on the code. Compare this to the plain JVM, where the same test suite takes about <strong>7 seconds</strong> to run!</p><p>So, I decided to investigate how to run unit tests on Android <em>without</em> the overhead of the instrumentation framework.</p><h3 id=running-plain-java-on-art>Running Plain Java on ART <a href=#running-plain-java-on-art class=anchor>üîó</a></h3><p>Running unit tests on Android is not a common practice, but it is possible. Unfortunately documentation is scattered and a bit outdated, so we had to figure out a lot of things on our own. It doesn&rsquo;t help that while some people still rever to the Android Java platform as the &ldquo;Dalvik runtime&rdquo;, Android has been using the Android Runtime (ART) since Android 5.0 (Lollipop), and that &ldquo;ART&rdquo; is a pretty unsearchable term. Moreover, even internally, the ART runtime is sometimes referred to as &ldquo;Dalvik&rdquo;, which adds to the confusion.</p><p>First of all, is it possible to run Java console applications on Android? It is; but first you have to figure out where the Java launcher is, and how to package your application.</p><p>In fact thanks to <a href=https://github.com/WanghongLin/StandaloneDVM target=_blank rel=noopener>this lone Github repo</a> we learn that the Java (ART) launcher is located at <code>/apex/com.android.art/bin/dalvikvm64</code> (<code>/apex/com.android.art/bin/dalvikvm</code> is the 32-bit version). This is the launcher that you can use to run Java applications on Android.</p><p>Let&rsquo;s write a simple Java application that prints the name of the host operating system to the console.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>class</span> <span style=color:#2b91af>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String... args) { 
</span></span><span style=display:flex><span>        System.out.printf(<span style=color:#a31515>&#34;Hello, %s %s\n&#34;</span>, 
</span></span><span style=display:flex><span>            System.getProperty(<span style=color:#a31515>&#34;os.name&#34;</span>),
</span></span><span style=display:flex><span>            System.getProperty(<span style=color:#a31515>&#34;os.version&#34;</span>)); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On my machine, I can compile and run this code with the following commands:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>‚ùØ javac Main.java
</span></span><span style=display:flex><span>‚ùØ java Main
</span></span><span style=display:flex><span>Hello, Mac OS X 15.5
</span></span></code></pre></div><p>Now, assuming your Android tools are on the PATH (on my machine they are in <code>$HOME/Library/Android/sdk/build-tools/35.0.0</code>), you can convert the class into a DEX file with the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>d8 Main.class
</span></span></code></pre></div><p>This will create a file called <code>classes.dex</code> in the current directory. This is the Dalvik bytecode that you can run on Android. Then, assuming you have a running Android emulator (or a connected device), you can upload the file to <code>/tmp/main.dex</code> with the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>‚ùØ adb push classes.dex /tmp/main.dex
</span></span><span style=display:flex><span>classes.dex: 1 file pushed, 0 skipped. 2.3 MB/s (1076 bytes in 0.000s)
</span></span></code></pre></div><p>Now you can run it on Android:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>‚ùØ adb shell /apex/com.android.art/bin/dalvikvm64 -cp /tmp/main.dex Main
</span></span><span style=display:flex><span>Hello, Linux 6.6.30-android15-8-gdd9c02ccfe27-ab11987101-4k
</span></span></code></pre></div><p>Congratulations! You have just run a plain Java application on Android!</p><h3 id=running-unit-tests-on-android>Running Unit Tests on Android <a href=#running-unit-tests-on-android class=anchor>üîó</a></h3><p>Putting it all together, assuming your android test cases are in <code>androidTest</code> you can run them with the following commands:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>./gradlew assembleAndroidTest
</span></span><span style=display:flex><span>adb push MY_PROJECT/build/outputs/apk/androidTest/debug/MY_PROJECT-debug-androidTest.apk /tmp/main.apk
</span></span><span style=display:flex><span>adb shell /apex/com.android.art/bin/dalvikvm64 -cp /tmp/main.apk com.example.Main
</span></span></code></pre></div><p>for instance, if you are using junit4 you can start the launcher with the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>adb /apex/com.android.art/bin/dalvikvm64 -cp main.apk org.junit.runner.JUnitCore &lt;test class&gt;
</span></span></code></pre></div><p>This will run the JUnit test class on the Android device, and you will see the output in the console. Notice this is sidestepping the usual Android launcher. This means that you can run your tests without the overhead of the instrumentation framework, but also you will not be able to use any Android-specific features, such as the Android UI framework or other Android APIs. Just to give you an example, you will not be able to use the Android logging framework.</p><h3 id=running-junit-5-tests-on-android>Running JUnit 5 tests on Android <a href=#running-junit-5-tests-on-android class=anchor>üîó</a></h3><p>Now, as an additional degree of complexity, the Chicory test suite uses JUnit 5, while the Android platform only supports JUnit 4 out of the box. There is an unofficial <a href=https://github.com/mannodermaus/android-junit5 target=_blank rel=noopener>JUnit 5 Android support library</a> that you can use; it also supports the Instrumentation Framework, and this is what we&rsquo;ve been using so far.</p><p>But if you run from the console, you can just use the <a href=https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher target=_blank rel=noopener>JUnit Platform Console Launcher</a>, and add it to your dependencies; you will also need to ensure that is bundled in the APK: that means that all the dependencies mut be <code>androidTestImplementation</code> instead of <code>androidTestRuntimeOnly</code>!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>    androidTestImplementation(<span style=color:#a31515>&#34;org.junit.jupiter:junit-jupiter-api:5.13.1&#34;</span>)
</span></span><span style=display:flex><span>    androidTestImplementation(<span style=color:#a31515>&#34;org.junit.jupiter:junit-jupiter-engine:5.13.1&#34;</span>)
</span></span><span style=display:flex><span>    androidTestImplementation(<span style=color:#a31515>&#34;org.junit.platform:junit-platform-console:1.13.1&#34;</span>)
</span></span><span style=display:flex><span>    androidTestImplementation(<span style=color:#a31515>&#34;org.junit.platform:junit-platform-suite:1.13.1&#34;</span>)
</span></span></code></pre></div><p>It is also advisable to create a Suite and list all the classes you want to run, as classpath scanning will not work. In our case:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>package</span> com.dylibso.chicory.test.gen;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>import</span> org.junit.platform.suite.api.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@SelectClasses({
</span></span><span style=display:flex><span>        SpecV1AddressTest.class,
</span></span><span style=display:flex><span>        SpecV1AlignTest.class,
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        SpecV1Utf8ImportModuleTest.class,
</span></span><span style=display:flex><span>        SpecV1Utf8InvalidEncodingTest.class,
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>@Suite
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>SpecV1</span> {}
</span></span></code></pre></div><p>Then once built and uploaded to <code>/tmp/main.apk</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>./gradlew assembleAndroidTest
</span></span><span style=display:flex><span>adb push MY_PROJECT/build/outputs/apk/androidTest/debug/MY_PROJECT-debug-androidTest.apk /tmp/main.apk
</span></span><span style=display:flex><span>adb shell /apex/com.android.art/bin/dalvikvm64 -cp /tmp/main.apk com.example.Main
</span></span></code></pre></div><p>you will finally be able to run the tests with the following command:</p><pre tabindex=0><code>adb shell /apex/com.android.art/bin/dalvikvm64 -cp /tmp/main.apk org.junit.platform.console.ConsoleLauncher -c com.dylibso.chicory.test.gen.SpecV1
</code></pre><p>The boot might take a little time: you can follow on <code>logcat</code> if you are bored, and you&rsquo;ll see that something is indeed happening; eventually you will see the test results in the console!</p><p>This finally brings the test time down to about <strong>14 seconds</strong>, which is a lot more manageable than the <strong>8 minutes</strong> we had before!</p><h3 id=the-hard-way-running-tests-with-a-custom-launcher>The Hard Way: Running Tests with a Custom Launcher <a href=#the-hard-way-running-tests-with-a-custom-launcher class=anchor>üîó</a></h3><p>Can we bring this down further? After all, the spec test suite is generated code, we know exactly what it does, and we could run it without the JUnit framework. <a href=https://gist.github.com/evacchi/6e63f31866c2118edf50b5b789725c76 target=_blank rel=noopener>With this custom launcher</a>, we can write a simple <code>Main</code> class that runs the tests directly, without the JUnit framework:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String... args) <span style=color:#00f>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#00f>var</span> tests = Class[] {
</span></span><span style=display:flex><span>            SpecV1AddressTest.class,
</span></span><span style=display:flex><span>            SpecV1AlignTest.class,
</span></span><span style=display:flex><span>            <span style=color:green>// ... all the other test classes ...</span>
</span></span><span style=display:flex><span>            SpecV1Utf8ImportModuleTest.class,
</span></span><span style=display:flex><span>            SpecV1Utf8InvalidEncodingTest.class,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#00f>var</span> runner = <span style=color:#00f>new</span> SpecTestRunnerMain(8 * 1024 * 1024, tests);
</span></span><span style=display:flex><span>        runner.runSuiteOnThread();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>The entire suite runs now in about <strong>7 seconds</strong> on the Android device, just like on the JVM!</p><h3 id=debugging-the-android-backend>Debugging the Android backend <a href=#debugging-the-android-backend class=anchor>üîó</a></h3><p>It is also possible to attach a debugger to the Android process running the tests. This is useful to debug the Chicory compiler and the generated Dalvik bytecode. In this case, the instructions are even more hard to find, but with some trial and error, especially following the <code>logcat</code> output I was able to figure out that you can attach a debugger to the Android process running the tests by using the following command:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>/apex/com.android.art/bin/dalvikvm64 -Xplugin:libopenjdkjvmti.so -agentpath:libjdwp.so=server=y,suspend=y,transport=dt_socket,address=0.0.0.0:8000 -cp /tmp/main.apk com.example.Main
</span></span></code></pre></div><p>Then you will be able to attach a remote debugging session using your favorite IDE (e.g. IntelliJ IDEA or Android Studio) to the port <code>8000</code> on the Android device.</p><p>The critical part is <code>-Xplugin:libopenjdkjvmti.so</code>, otherwise the <code>-agentpath</code> flag has no effect.</p><h2 id=conclusion>Conclusion <a href=#conclusion class=anchor>üîó</a></h2><p>The Android backend of the Chicory compiler is still a work in progress, but it is showing promising results. If you are interested in lower-level Android development, or if you want to run Wasm modules on Android, I hope this article has given you some insights into the challenges and solutions we have found so far. If you want to try it out follow the instruction on the <a href=https://github.com/dylibso/chicory-compiler-android target=_blank rel=noopener>chicory-compiler-android</a> repository. The Android backend is still experimental, but you can already try it with the <a href=https://github.com/extism/chicory-sdk target=_blank rel=noopener>Chicory SDK</a> and the <a href=https://github.com/dylibso/mcpx4j target=_blank rel=noopener>mcpx4j</a> library. Feel free to open issues if you find any problems or have suggestions for improvements.</p></div><div class=tags><a href=/tags/android>Android</a>
<a href=/tags/chicory>Chicory</a>
<a href=/tags/webassembly>WebAssembly</a></div></section></main><footer id=footer><div class=social><a class="symbol bluesky" href=https://bsky.app/profile/evacchi.dev rel=me target=_blank></a><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2025
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg>
</span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>