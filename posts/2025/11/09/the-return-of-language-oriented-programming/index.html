<!doctype html><html lang=en-us><head><title>The Return of Language-Oriented Programming | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="
I&rsquo;ve been wondering what LLMs mean for language design and implementation. Some believe that, because language models are obviously trained on existing content, they are inherently less capable of assisting users with new programming languages. Intuitively this makes sense. However:"><meta name=generator content="Hugo 0.152.2"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>â†</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>The Return of Language-Oriented Programming</h1><div class=tip><time datetime="2025-11-09 00:00:00 +0000 UTC">Nov 9, 2025</time>
<span class=split>Â·
</span><span>1397 words
</span><span class=split>Â·
</span><span>7 minute read</span></div><div class=content><img src=/assets/lop/cover.jpg alt="Spoof of 'The Return of the Pink Panther' with a dragon in place of the panther, and the silhouette of the knight instead of Inspector Clouseau" title="Spoof of 'The Return of the Pink Panther' with a dragon in place of the panther, and the silhouette of the knight instead of Inspector Clouseau" width=100%><p>I&rsquo;ve been wondering <strong>what LLMs mean for language design and implementation</strong>. Some believe that, because language models are obviously trained on existing content, they are inherently less capable of assisting users with new programming languages. Intuitively this makes sense. However:</p><ul><li><a href=https://simonwillison.net/2025/Nov/7/llms-for-new-programming-languages/#atom-everything target=_blank rel=noopener>Simon Wilson has a &ldquo;hunch&rdquo;</a> that LLMs actually make it <em>easier</em> to build a new programming language;</li><li><a href="https://www.youtube.com/watch?v=ZsBHc-J9f8o" target=_blank rel=noopener>Richard Felman has argued that this might be the &ldquo;best time to create new programming languages&rdquo;</a>;</li><li><a href="https://x.com/Love2Code/status/1950622166166241767?ref_src=twsrc%5Etfw" target=_blank rel=noopener>Maxime Chevalier has been developing her own experimental programming language</a> called <a href=https://github.com/maximecb/plush target=_blank rel=noopener>Plush</a>, porting <a href=https://x.com/Love2Code/status/1986900389631811723 target=_blank rel=noopener>&ldquo;many example programs with the help of LLMs&rdquo;</a>.</li></ul><p>If anything, LLMs might be shifting the cost of programming language development economics, making it possibly <em>even simpler</em> to build your own. As a self-professed <a href=https://x.com/evacchi/ target=_blank rel=noopener>&ldquo;programming-language nerd&rdquo; and compiler-enthusiast</a>, that just makes me excited.</p><p><strong>Disclaimer</strong>: you should <em>not</em> think of this as of a fully-fleshed out essay, rather it is a collection of ideas that I just want share in the hope to spark some interesting conversation! Some code examples have been generated using Claude and a bit of Python. If you find mistakes, <a href=https://twitter.com/evacchi target=_blank rel=noopener>let</a> <a href=https://bsky.app/profile/evacchi.dev target=_blank rel=noopener>me</a> <a href=https://mastodon.social/@evacchi target=_blank rel=noopener>know</a>!</p><h2 id=domain-specific-languages-and-language-oriented-programming>Domain-Specific Languages and Language-Oriented ProgrammingÂ  <a href=#domain-specific-languages-and-language-oriented-programming class=anchor>ğŸ”—</a></h2><p>One of my favorite articles about domain-specific languages is a classic from 1994 where M.C. Ward introduces the idea of <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=825a90a7eaebd7082d883b198e1a218295e0ed3b" target=_blank rel=noopener>Language-Oriented Programming</a>. In essence, LOP extends the idea of designing a large software system in layers, with one layer being a language definition.</p><div style=text-align:center><img src=/assets/lop/dsl-middle-out.png width=100% alt="The 'middle-out' diagram found in the paper next to the poster for the Silicon Valley series, where 'middle-out compression' is discovered over a decidedly NSFW argument" title="The 'middle-out' diagram found in the paper next to the poster for the Silicon Valley series, where 'middle-out compression' is discovered over a decidedly NSFW argument">
<span style=font-style:italic;font-size:small;line-height:.5>The 'middle-out' diagram found in the paper next to the poster for the Silicon Valley series, where 'middle-out compression' is discovered over a decidedly NSFW argument</span></div><p>Rather than traditional top-down or bottom-up development, LOP proposes a &ldquo;middle-out&rdquo; approach:</p><ol><li>Design a domain-oriented language suited for the specific problem domain</li><li>Split development into two independent parallel tracks:<ul><li>Implement the system using this middle-level language</li><li>Implement a compiler/interpreter for the language</li></ul></li></ol><p><a href=https://martinfowler.com/books/dsl.html target=_blank rel=noopener>Domain-Specific Languages</a> are small languages designed to focus on a specific aspect of a software system. We deal with DSLs every day: SQL can be considered a DSL, LaTeX is a DSL, AWK is a DSL, Kubernetes&rsquo; YAMLs are a DSL. They are &ldquo;domain-specific&rdquo; because they are used to write code for a given &ldquo;subdomain&rdquo; of the software system. In this sense, they have been also described as a means of communcation between a developer and a &ldquo;domain-expert&rdquo;. The holy grail of computing for many years was to let such &ldquo;domain experts&rdquo; write the code themselves, while developers would only validate it and deploy it in the large system.</p><p>Now it so happens that coding agents are pretty good at generating code, to the point that <a href=https://x.com/karpathy/status/1617979122625712128 target=_blank rel=noopener>Andrey Karpathy claimed</a> that &ldquo;The hottest new programming language is English&rdquo;!</p><p>So, I&rsquo;ve been thinking: what if instead of just generating code for the languages that LLMs already have in their training set, <strong>we instead let <em>them</em> generate the <em>implementation</em> of a domain-specific language</strong>, and <em>then</em> <strong>use <em>that</em> throughout the rest of a coding session</strong>?</p><p>But then, what would one such language look like? <a href=https://x.com/bsideup/status/1955412035052900587 target=_blank rel=noopener>Sergei Egorov shared a thread with his thoughts on a similar matter</a>. I myself I&rsquo;ve been wondering if a programming language for LLMs would be some kind of mixture between a high-level and a low-level language: in that we want the language to be terse, but at the same time low-level enough to implement some kind of VM for it.</p><p>Then again, what would &ldquo;terseness&rdquo; mean in this context?</p><h2 id=detour-token-efficiency-in-programming-languages>Detour: Token-Efficiency in Programming Languages <a href=#detour-token-efficiency-in-programming-languages class=anchor>ğŸ”—</a></h2><p>Traditional programming languages optimize for human readability, not for token efficiency within an LLM&rsquo;s &ldquo;context window&rdquo;<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>From a language design perspective, there&rsquo;s a <strong>fundamental mismatch in how &ldquo;tokens&rdquo; are defined</strong>: while programming language tokenizers split text at whitespace and symbols (which are then usually dropped after parsing), language models treat tokens very differently.</p><p>For instance, in a JS tokenizer, the control-flow structure:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#00f>for</span> (<span style=color:#00f>let</span> i = 0; i &lt;= 10; i++) {
</span></span><span style=display:flex><span>    print(i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>would be tokenized as follows (notice how similar types of tokens are color-coded the same)</p><div><style>.token-container{line-height:1.8;font-family:monospace;margin:20px 0}.token{padding:2px 1px;border:1px solid #ccc;margin:0}.bg-0{background-color:#ffcdd2}.bg-1{background-color:#f8bbd0}.bg-2{background-color:#e1bee7}.bg-3{background-color:#d1c4e9}.bg-4{background-color:#c5cae9}.bg-5{background-color:#bbdefb}.bg-6{background-color:#b3e5fc}.bg-7{background-color:#b2dfdb}.bg-8{background-color:#c8e6c9}.bg-9{background-color:#dcedc8}.bg-10{background-color:#f0f4c3}.bg-11{background-color:#fff9c4}.bg-12{background-color:#ffecb3}.bg-13{background-color:#ffe0b2}.bg-14{background-color:#ffccbc}</style><pre class=token-container><span class="token bg-0" title=keyword>for</span><span class="token bg-5" title=punctuation>(</span><span class="token bg-0" title=keyword>let</span><span class="token bg-3" title=identifier>Â·i</span><span class="token bg-5" title=operator>Â·=</span><span class="token bg-11" title=number>Â·0</span><span class="token bg-5" title=punctuation>;</span><span class="token bg-3" title=identifier>Â·i</span><span class="token bg-5" title=operator>Â·&lt;=</span><span class="token bg-11" title=number>Â·10</span><span class="token bg-5" title=punctuation>;</span><span class="token bg-3" title=identifier>Â·i</span><span class="token bg-5" title=operator>++</span><span class="token bg-5" title=punctuation>)</span><span class="token bg-5" title=punctuation>Â·{</span><span class="token bg-3" title=identifier>Â·print</span><span class="token bg-5" title=punctuation>(</span><span class="token bg-3" title=identifier>i</span><span class="token bg-5" title=punctuation>,</span><span class="token bg-3" title=identifier>Â·j</span><span class="token bg-5" title=punctuation>);</span><span class="token bg-5" title=punctuation>Â·}</span></pre></div><p>this in turn, would correspond to a &ldquo;parse tree&rdquo; of the form:</p><pre tabindex=0><code>ForStatement
â”œâ”€â”€ Init: VariableDeclaration (let)
â”‚   â””â”€â”€ VariableDeclarator
â”‚       â”œâ”€â”€ Identifier: i
â”‚       â””â”€â”€ Literal: 0
â”œâ”€â”€ Test: BinaryExpression (&lt;=)
â”‚   â”œâ”€â”€ Identifier: i
â”‚   â””â”€â”€ Literal: 10
â”œâ”€â”€ Update: UpdateExpression (++)
â”‚   â””â”€â”€ Identifier: i
â””â”€â”€ Body: BlockStatement
    â””â”€â”€ ExpressionStatement
        â””â”€â”€ CallExpression
            â”œâ”€â”€ Identifier: print
            â””â”€â”€ Arguments
                â””â”€â”€ Identifier: i
</code></pre><p>But, for the tokenizer of an LLM, no further structure is detected before inference; the token stream would look something like the following<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, where there is no longer any relation between colors and content (in fact, in this representation matching colors do not qualify the kind of token)</p><div><pre class=token-container><span class="token bg-0" title="Token 0: 'for'">for</span><span class="token bg-1" title="Token 1: ' ('">Â·(</span><span class="token bg-2" title="Token 2: 'let'">let</span><span class="token bg-3" title="Token 3: ' i'">Â·i</span><span class="token bg-4" title="Token 4: ' ='">Â·=</span><span class="token bg-5" title="Token 5: ' '">Â·</span><span class="token bg-6" title="Token 6: '0'">0</span><span class="token bg-7" title="Token 7: ';'">;</span><span class="token bg-8" title="Token 8: ' i'">Â·i</span><span class="token bg-9" title="Token 9: ' <='">Â·&lt;=</span><span class="token bg-10" title="Token 10: ' '">Â·</span><span class="token bg-11" title="Token 11: '10'">10</span><span class="token bg-12" title="Token 12: ';'">;</span><span class="token bg-13" title="Token 13: ' i'">Â·i</span><span class="token bg-14" title="Token 14: '++)'">++)</span><span class="token bg-0" title="Token 15: ' {\n'">Â·{
</span><span class="token bg-1" title="Token 16: ' '">Â·</span><span class="token bg-2" title="Token 17: ' console'">print</span><span class="token bg-4" title="Token 19: '(i'">(i</span><span class="token bg-7" title="Token 22: ');\n'">);
</span><span class="token bg-8" title="Token 23: '}'">}</span></pre></div><p>In other words, because the tokenizer of an LLM is trained on a vast amount of varied text, it is not specifically optimized for code; <strong>semantically equivalent code can have wildly different token counts</strong> based purely on formatting choices, identifier naming, or even the presence of comments.</p><p>For instance, complete words like <code>user</code>, <code>authentication</code>, and <code>token</code> tend to be learned as single units; rare abbreviations (<code>Tkn</code>) may be split into multiple character-level tokens (<code>T</code>, <code>k</code>, <code>n</code>); symbols usually count as single tokens. It follows that:</p><ul><li>a loop written with short variable names like <code>i</code> and <code>j</code> does not necessarily consume fewer tokens than one calling them, respectively <code>outer</code> and <code>inner</code>;</li><li>in general, verbose but clear variable names using common English words (<code>userAuthenticationToken</code>) may be more token-efficient than abbreviations (<code>uat</code> or <code>usrAuthTkn</code>);</li><li>code that might look compact can still be token-heavy for a language model; comments, symbols and whitespace are often often transformed, abstracted or even dropped during parsing; however, in LLM tokenization, these syntactic construct will usually persist.</li></ul><p>Let&rsquo;s consider a few examples.</p><h3 id=example-1-javascript-vs-python>Example 1: JavaScript vs Python <a href=#example-1-javascript-vs-python class=anchor>ğŸ”—</a></h3><p>When it comes to token-efficiency, a language like Python might compare more favorably to Javascript. Even in code where complexity is comparable, Python uses fewer symbolic delimiters, favoring whitespace and full words instead. Consider:</p><div><div class="stream output-id-3"><div class="output_subarea output_text"><h4>JavaScript (short vars): 43 tokens</h4></div></div><div class=output-section><pre class=token-container><span class="token bg-0" title="Token 0: 'for'">for</span><span class="token bg-1" title="Token 1: ' ('">(</span><span class="token bg-2" title="Token 2: 'let'">let</span><span class="token bg-3" title="Token 3: ' i'"> i</span><span class="token bg-4" title="Token 4: ' ='"> =</span><span class="token bg-5" title="Token 5: ' '"> </span><span class="token bg-6" title="Token 6: '0'">0</span><span class="token bg-7" title="Token 7: ';'">;</span><span class="token bg-8" title="Token 8: ' i'"> i</span><span class="token bg-9" title="Token 9: ' <='"> &lt;=</span><span class="token bg-10" title="Token 10: ' '"> </span><span class="token bg-11" title="Token 11: '10'">10</span><span class="token bg-12" title="Token 12: ';'">;</span><span class="token bg-13" title="Token 13: ' i'"> i</span><span class="token bg-14" title="Token 14: '++)'">++)</span><span class="token bg-0" title="Token 15: ' {\n'"> {
</span><span class="token bg-1" title="Token 16: ' '"> </span><span class="token bg-2" title="Token 17: ' for'"> for</span><span class="token bg-3" title="Token 18: ' ('">(</span><span class="token bg-4" title="Token 19: 'let'">let</span><span class="token bg-5" title="Token 20: ' j'"> j</span><span class="token bg-6" title="Token 21: ' ='"> =</span><span class="token bg-7" title="Token 22: ' '"> </span><span class="token bg-8" title="Token 23: '0'">0</span><span class="token bg-9" title="Token 24: ';'">;</span><span class="token bg-10" title="Token 25: ' j'"> j</span><span class="token bg-11" title="Token 26: ' <='"> &lt;=</span><span class="token bg-12" title="Token 27: ' '"> </span><span class="token bg-13" title="Token 28: '5'">5</span><span class="token bg-14" title="Token 29: ';'">;</span><span class="token bg-0" title="Token 30: ' j'"> j</span><span class="token bg-1" title="Token 31: '++)'">++)</span><span class="token bg-2" title="Token 32: ' {\n'"> {
</span><span class="token bg-3" title="Token 33: '   '">   </span><span class="token bg-4" title="Token 34: ' console'"> console</span><span class="token bg-5" title="Token 35: '.log'">.log</span><span class="token bg-6" title="Token 36: '(i'">(i</span><span class="token bg-7" title="Token 37: ','">,</span><span class="token bg-8" title="Token 38: ' j'"> j</span><span class="token bg-9" title="Token 39: ');\n'">);
</span><span class="token bg-10" title="Token 40: ' '"> </span><span class="token bg-11" title="Token 41: ' }\n'"> }
</span><span class="token bg-12" title="Token 42: '}'">}</span></pre></div><div class=output-section><h4>Python (short variable names): 21 tokens (51% vs JS)</h4><pre class=token-container><span class="token bg-0" title="Token 0: 'for'">for</span><span class="token bg-1" title="Token 1: ' i'"> i</span><span class="token bg-2" title="Token 2: ' in'"> in</span><span class="token bg-3" title="Token 3: ' range'"> range</span><span class="token bg-4" title="Token 4: '('">(</span><span class="token bg-5" title="Token 5: '11'">11</span><span class="token bg-6" title="Token 6: '):\n'">):
</span><span class="token bg-7" title="Token 7: ' '"> </span><span class="token bg-8" title="Token 8: ' for'"> for</span><span class="token bg-9" title="Token 9: ' j'"> j</span><span class="token bg-10" title="Token 10: ' in'"> in</span><span class="token bg-11" title="Token 11: ' range'"> range</span><span class="token bg-12" title="Token 12: '('">(</span><span class="token bg-13" title="Token 13: '6'">6</span><span class="token bg-14" title="Token 14: '):\n'">):
</span><span class="token bg-0" title="Token 15: '   '">   </span><span class="token bg-1" title="Token 16: ' print'"> print</span><span class="token bg-2" title="Token 17: '(i'">(i</span><span class="token bg-3" title="Token 18: ','">,</span><span class="token bg-4" title="Token 19: ' j'"> j</span><span class="token bg-5" title="Token 20: ')'">)</span></pre></div><div class=output-section><h4>Python (readable names): 22 tokens (49% vs JS)</h4><pre class=token-container><span class="token bg-0" title="Token 0: 'for'">for</span><span class="token bg-1" title="Token 1: ' outer'"> outer</span><span class="token bg-2" title="Token 2: ' in'"> in</span><span class="token bg-3" title="Token 3: ' range'"> range</span><span class="token bg-4" title="Token 4: '('">(</span><span class="token bg-5" title="Token 5: '11'">11</span><span class="token bg-6" title="Token 6: '):\n'">):
</span><span class="token bg-7" title="Token 7: ' '"> </span><span class="token bg-8" title="Token 8: ' for'"> for</span><span class="token bg-9" title="Token 9: ' inner'"> inner</span><span class="token bg-10" title="Token 10: ' in'"> in</span><span class="token bg-11" title="Token 11: ' range'"> range</span><span class="token bg-12" title="Token 12: '('">(</span><span class="token bg-13" title="Token 13: '6'">6</span><span class="token bg-14" title="Token 14: '):\n'">):
</span><span class="token bg-0" title="Token 15: '   '">   </span><span class="token bg-1" title="Token 16: ' print'"> print</span><span class="token bg-2" title="Token 17: '('">(</span><span class="token bg-3" title="Token 18: 'outer'">outer</span><span class="token bg-4" title="Token 19: ','">,</span><span class="token bg-5" title="Token 20: ' inner'"> inner</span><span class="token bg-6" title="Token 21: ')'">)</span></pre></div></div><p>Of course, you might argue that the example above is somewhat contrieved (it&rsquo;s just two nested loops). Let&rsquo;s consider another example.</p><h3 id=example-2-apl-vs-q-vs-python>Example 2: APL vs Q vs Python <a href=#example-2-apl-vs-q-vs-python class=anchor>ğŸ”—</a></h3><p><a href=https://en.wikipedia.org/wiki/Kdb%2B target=_blank rel=noopener>kdb+</a> is quantitative finance&rsquo;s sweetheart; a somewhat obscure time-series DB, sporting an <a href=https://en.wikipedia.org/wiki/APL_%28programming_language%29 target=_blank rel=noopener>APL</a> dialect called <a href=https://en.wikipedia.org/wiki/K_%28programming_language%29 target=_blank rel=noopener>K</a>, and a thin, more readable wrapper called <a href=https://en.wikipedia.org/wiki/Q_%28programming_language_from_Kx_Systems%29 target=_blank rel=noopener>Q</a>, where symbolic identifiers are often traded for more explicit English words.</p><p>How does APL compare to an equivalent Q program, in terms of tokens? And what about Python with numpy and pandas (effectively using Python as an array-oriented DSL)?</p><p><strong>Update Nov 11</strong>: The original version presented a broken 3-period weighted average; thus it also claimed, incorrectly, that the Python version was shorter (token-wise). Thanks to <a href=https://bsky.app/profile/abrudz.bsky.social/post/3m5elxvpls22o target=_blank rel=noopener>AdÃ¡m Brudzewsky</a></p><p>In the following, we compute a 3-period moving average by symbol, selecting the symbols with average greater than 100. For instance, if we have:</p><pre tabindex=0><code>data = {
    &#39;sym&#39;: [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;, &#39;C&#39;], 
    &#39;price&#39;: [100, 101, 95, 102, 98, 108, 105, 96, 98, 100] 
}
</code></pre><p>the result is <code>['A']</code>, because <code>B</code> and <code>C</code>&rsquo;s average will be smaller than 100 at the end.</p><p>In <a href=https://tryapl.org/ target=_blank rel=noopener>Dyalog APL</a> this is written as follows (assuming two vectors, <code>sym</code> and <code>price</code>, where each index correspond to a <code>symbol, price</code> pair):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-apl data-lang=apl><span style=display:flex><span>sym <span style=color:#00f>â†</span> <span style=color:#a31515>&#39;A&#39;</span> <span style=color:#a31515>&#39;A&#39;</span> <span style=color:#a31515>&#39;B&#39;</span> <span style=color:#a31515>&#39;A&#39;</span> <span style=color:#a31515>&#39;B&#39;</span> <span style=color:#a31515>&#39;A&#39;</span> <span style=color:#a31515>&#39;B&#39;</span> <span style=color:#a31515>&#39;C&#39;</span> <span style=color:#a31515>&#39;C&#39;</span> <span style=color:#a31515>&#39;C&#39;</span>
</span></span><span style=display:flex><span>price <span style=color:#00f>â†</span> 100 101 95 102 98 108 105 96 98 100
</span></span><span style=display:flex><span>result <span style=color:#00f>â†</span> (100&lt;(+/Ã·â‰¢)sym(Â¯3â†‘âŠ¢)âŒ¸price)/âˆªsym
</span></span><span style=display:flex><span>result            <span style=color:green>â // prints &#39;A&#39;</span>
</span></span></code></pre></div><p>Now, notice how the usage of Unicode characters <strong>explodes</strong> into several non-printable tokens:</p><div><div class=output-section><h4>Dyalog APL: 28 tokens</h4><pre><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 0: 'result'">result</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 1: ' â†'">Â·â†</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 2: ' ('">Â·(</span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 3: '100'">100</span><span style="background-color:#c5cae9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 4: '<('">&lt;(</span><span style="background-color:#bbdefb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 5: '+/'">+/</span><span style="background-color:#b3e5fc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 6: 'ï¿½'">ï¿½</span><span style="background-color:#b2dfdb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 7: 'ï¿½'">ï¿½</span><span style="background-color:#c8e6c9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 8: 'ï¿½'">ï¿½</span><span style="background-color:#dcedc8;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 9: 'ï¿½'">ï¿½</span><span style="background-color:#f0f4c3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 10: ')'">)</span><span style="background-color:#fff9c4;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 11: 'sym'">sym</span><span style="background-color:#ffecb3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 12: '('">(</span><span style="background-color:#ffe0b2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 13: 'Â¯'">Â¯</span><span style="background-color:#ffccbc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 14: '3'">3</span><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 15: 'â†‘'">â†‘</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 16: 'ï¿½'">ï¿½</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 17: 'ï¿½'">ï¿½</span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 18: 'ï¿½'">ï¿½</span><span style="background-color:#c5cae9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 19: ')'">)</span><span style="background-color:#bbdefb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 20: 'ï¿½'">ï¿½</span><span style="background-color:#b3e5fc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 21: 'ï¿½'">ï¿½</span><span style="background-color:#b2dfdb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 22: 'ï¿½'">ï¿½</span><span style="background-color:#c8e6c9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 23: 'price'">price</span><span style="background-color:#dcedc8;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 24: ')/'">)/</span><span style="background-color:#f0f4c3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 25: 'ï¿½'">ï¿½</span><span style="background-color:#fff9c4;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 26: 'ï¿½'">ï¿½</span><span style="background-color:#ffecb3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 27: 'sym'">sym</span></pre></div><p>Somehow surprisingly, the same code in Q, even if it&rsquo;s more readable and, some might argue, more verbose, has actually a slightly lower token count:</p><div class=output-section><h4>Q (kdb+): 26 tokens</h4><pre><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 0: 'select'">select</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 1: ' sym'">Â·sym</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 2: ' from'">Â·from</span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 3: ' (\n'">Â·(
</span><span style="background-color:#c5cae9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 4: ' '">Â·</span><span style="background-color:#bbdefb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 5: ' select'">Â·select</span><span style="background-color:#b3e5fc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 6: ' sm'">Â·sm</span><span style="background-color:#b2dfdb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 7: 'a'">a</span><span style="background-color:#c8e6c9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 8: ':'">:</span><span style="background-color:#dcedc8;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 9: ' avg'">Â·avg</span><span style="background-color:#f0f4c3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 10: ' '">Â·</span><span style="background-color:#fff9c4;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 11: '3'">3</span><span style="background-color:#ffecb3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 12: '#'">#</span><span style="background-color:#ffe0b2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 13: 'price'">price</span><span style="background-color:#ffccbc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 14: ' by'">Â·by</span><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 15: ' sym'">Â·sym</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 16: ' from'">Â·from</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 17: ' prices'">Â·prices</span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 18: '\n'">
</span><span style="background-color:#c5cae9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 19: ')'">)</span><span style="background-color:#bbdefb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 20: ' where'">Â·where</span><span style="background-color:#b3e5fc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 21: ' sm'">Â·sm</span><span style="background-color:#b2dfdb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 22: 'a'">a</span><span style="background-color:#c8e6c9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 23: ' >'">Â·&gt;</span><span style="background-color:#dcedc8;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 24: ' '">Â·</span><span style="background-color:#f0f4c3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 25: '100'">100</span></pre></div><p>Unsurprisingly, the Python version has a higher token count. Depending on your meter, the difference is either quite large (about twice as many tokens!) or relatively small (just about 20â€“25 tokens!). Still, considering how much longer the Python version is in terms of characters compared to Q or APL, itâ€™s interesting that the token count remains relatively low.</p><div class=output-section><h4>Python (numpy, pandas): 49 tokens</h4><pre><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 0: 'result'">result</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 1: ' ='">Â·=</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 2: ' ('">Â·(</span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 3: 'prices'">prices</span><span style="background-color:#c5cae9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 4: '\n'">
</span><span style="background-color:#bbdefb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 5: '   '">Â·Â·Â·</span><span style="background-color:#b3e5fc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 6: ' .'">Â·.</span><span style="background-color:#b2dfdb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 7: 'group'">group</span><span style="background-color:#c8e6c9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 8: 'by'">by</span><span style="background-color:#dcedc8;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 9: " ('"">('</span><span style="background-color:#f0f4c3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 10: 'sym'">sym</span><span style="background-color:#fff9c4;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 11: " ')['"">')['</span><span style="background-color:#ffecb3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 12: 'price'">price</span><span style="background-color:#ffe0b2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 13: " ']\n"">']
</span><span style="background-color:#ffccbc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 14: '   '">Â·Â·Â·</span><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 15: ' .'">Â·.</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 16: 'apply'">apply</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 17: '(lambda'">(lambda</span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 18: ' g'">Â·g</span><span style="background-color:#c5cae9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 19: ':'">:</span><span style="background-color:#bbdefb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 20: ' g'">Â·g</span><span style="background-color:#b3e5fc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 21: '.tail'">.tail</span><span style="background-color:#b2dfdb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 22: '('">(</span><span style="background-color:#c8e6c9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 23: '3'">3</span><span style="background-color:#dcedc8;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 24: ').'">).</span><span style="background-color:#f0f4c3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 25: 'mean'">mean</span><span style="background-color:#fff9c4;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 26: '())\n'">())
</span><span style="background-color:#ffecb3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 27: '   '">Â·Â·Â·</span><span style="background-color:#ffe0b2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 28: ' .'">Â·.</span><span style="background-color:#ffccbc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 29: 'to'">to</span><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 30: '_frame'">_frame</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 31: '(name'">(name</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 32: " ='""="">=' </span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 33: 'avg'">avg</span><span style="background-color:#c5cae9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 34: " ')"">')</span><span style="background-color:#bbdefb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 35: ' \n'">Â·
</span><span style="background-color:#b3e5fc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 36: '   '">Â·Â·Â·</span><span style="background-color:#b2dfdb;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 37: ' .'">Â·.</span><span style="background-color:#c8e6c9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 38: 'query'">query</span><span style="background-color:#dcedc8;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 39: " ('"">('</span><span style="background-color:#f0f4c3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 40: 'ac'">ac</span><span style="background-color:#fff9c4;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 41: 'g'">g</span><span style="background-color:#ffecb3;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 42: ' >'">Â·&gt;</span><span style="background-color:#ffe0b2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 43: ' '">Â·</span><span style="background-color:#ffccbc;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 44: '100'">100</span><span style="background-color:#ffcdd2;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 45: " ')."">').</span><span style="background-color:#f8bbd0;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 46: 'index'">index</span><span style="background-color:#e1bee7;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 47: '.tolist'">.tolist</span><span style="background-color:#d1c4e9;padding:2px 1px;border:1px solid #ccc;margin:0" title="Token 48: '())'">())</span></pre></div></div><h3 id=example-3-token-oriented-object-notation-toon>Example 3: Token-Oriented Object Notation (TOON) <a href=#example-3-token-oriented-object-notation-toon class=anchor>ğŸ”—</a></h3><p>I like this example, because I did not come up with it. <a href=https://x.com/jschopplich target=_blank rel=noopener>Johann Schopplich</a> has proposed the <a href=https://github.com/toon-format/toon#readme target=_blank rel=noopener>&ldquo;Token-Oriented Object Notation&rdquo; (TOON)</a>, a more compact alternative to JSON. The authors claim &ldquo;typically 30-60% fewer tokens on large uniform arrays vs formatted JSON&rdquo;. In the words of its readme:</p><blockquote><p>AI is becoming cheaper and more accessible, but larger context windows allow for larger data inputs as well. <strong>LLM tokens still cost money</strong> â€“ and standard JSON is verbose and token-expensive:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;users&#34;: [
</span></span><span style=display:flex><span>    { &#34;id&#34;: 1, &#34;name&#34;: <span style=color:#a31515>&#34;Alice&#34;</span>, &#34;role&#34;: <span style=color:#a31515>&#34;admin&#34;</span> },
</span></span><span style=display:flex><span>    { &#34;id&#34;: 2, &#34;name&#34;: <span style=color:#a31515>&#34;Bob&#34;</span>, &#34;role&#34;: <span style=color:#a31515>&#34;user&#34;</span> }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>TOON conveys the same information with <strong>fewer tokens</strong>:</p><pre tabindex=0><code>users[2]{id,name,role}:
  1,Alice,admin
  2,Bob,user
</code></pre></blockquote><p>TOON is a perfect example of a token-efficient DSL.</p><h2 id=the-return-of-language-oriented-programming>The Return of Language-Oriented Programming <a href=#the-return-of-language-oriented-programming class=anchor>ğŸ”—</a></h2><p>A domain-specific language is by definition smaller in scope than a general-purpose language, so it should be easier to design and implement; moreover, if the language is designed well, it should lead to a more efficient usage of the context window.</p><p>If we can abstract away parts of our domain into a higher-level language, we can effectively use the LLM to</p><ol><li>generate the implementation of a DSL</li><li>generate <strong>documentation</strong> and <strong>examples</strong> for such our DSL</li><li>point the LLM to docs and examples and prompt it to generate more code <strong>using our DSL</strong></li></ol><p>So, instead of trying to come up with a general-purpose language for LLMs, we define a tiny DSL for each specific subsystem we mean to realize. The domain-specific Language is now not only a means of communication between a domain-expert and the developer, but also a means of communication between the developer, the domain-expert and the language model.</p><p>I&rsquo;m going to show a couple of examples</p><h3 id=example-1-piano-dsl>Example 1: Piano DSL <a href=#example-1-piano-dsl class=anchor>ğŸ”—</a></h3><p>Days ago, I stumbled upon <a href=https://xlii.space/eng/haskell-feels-easy/ target=_blank rel=noopener>Alexander Kaminski&rsquo; blog post</a> about &ldquo;microdiagram DSLs&rdquo;:</p><blockquote><p>The core concept is quite straightforward: instead of having one language for all diagrams, have multiple languages for various purposes. For example, this diagram is designed to help learn piano by illustrating the relationship between different keys.</p><div style=text-align:center><img src=/assets/lop/dsl-microdiag-piano.png width=50%></div></blockquote><p>I immediately wondered if I could generate something similar using Claude:</p><blockquote><p>design a DSL to design piano diagrams like these:</p><p><a href=https://xlii.space/eng/haskell-feels-easy/ target=_blank rel=noopener>https://xlii.space/eng/haskell-feels-easy/</a></p><p>then implement it in JS and show me some examples with their rendering</p></blockquote><p><a href="https://claude.site/public/artifacts/1660b34e-939e-4ccf-a403-4c29cbad48e8/embed?utm_source=embedded_artifact&amp;utm_medium=iframe&amp;utm_campaign=artifact_frame" target=_blank rel=noopener>This is the result</a>:</p><p><a href=https://claude.site/public/artifacts/ade8dd7f-1883-4f59-9372-be464834b6d9/embed target=_blank><img src=/assets/lop/dsl-piano-gen.png width=100%></a></p><p>The implementation is fully-functional and interactive</p><h3 id=example-2-business-rules>Example 2: Business Rules <a href=#example-2-business-rules class=anchor>ğŸ”—</a></h3><p>Another classic example of a DSL is Business Rules Languages. To be more precise, BRLs are more of a &ldquo;framework&rdquo; to define business rules; then rules <em>then</em> encode the actual domain logic.</p><blockquote><p>design and implement a business rules language. Then implement it in JS and show me some examples</p></blockquote><p><a href="https://claude.site/public/artifacts/ade8dd7f-1883-4f59-9372-be464834b6d9/embed?utm_source=embedded_artifact&amp;utm_medium=iframe&amp;utm_campaign=artifact_frame" target=_blank rel=noopener>Here&rsquo;s the result</a>:</p><p><a href=https://claude.site/public/artifacts/1660b34e-939e-4ccf-a403-4c29cbad48e8/embed target=_blank><img src=/assets/lop/dsl-brl-gen.png width=100%></a></p><p>Now, if you ignore that <a href=https://kie.apache.org/docs/10.0.x/drools/drools/language-reference-traditional/index.html#drl-rules-THEN-con_drl-rules-traditional target=_blank rel=noopener>this is clearly reminiscent of Drools to the point of plagiarism</a>, and that the implementation is really poor, you still got a functional PoC, with the added benefit that the LLM is fully aware of the syntax and can assist you in iterating over it.</p><p>The goal here isn&rsquo;t necessarily to implement a language perfectly; instead we can quickly iterate on a prototype, possibly delivering this to end users, while the implementation is improved. After all, this is exactly how the original <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=825a90a7eaebd7082d883b198e1a218295e0ed3b" target=_blank rel=noopener>LOP paper</a> proposed to carry on the work!</p><h2 id=what-about-maintainance>What About Maintainance? <a href=#what-about-maintainance class=anchor>ğŸ”—</a></h2><p>A <strong>common critique</strong> about the cost of maintaining and working with DSLs is that <strong>you now have to maintain not just documentation but also tooling</strong>. With the advent of LLMs, these special-purpose, small languages are much more cost-effective.</p><ol><li>docs and examples can be very often generated by the LLM itself.</li><li>if the main interaction pattern is code-gen via an LLM, there is far fewer pressure to implement comprehensive tooling, such as a full IDE integrations, because a coding agent might be happy enough with a CLI tool or an MCP server. Other, simpler things, like syntax coloring, can be generated as well.</li></ol><p><strong>Another common critique</strong> is about the <strong>cost of defining an external DSL as opposed to an internal DSL</strong>.</p><ul><li><p>An <strong>external DSL</strong> is the type of language that we have shown in this blog post, with its own syntax, parser, interpreter/compilation pipeline.</p></li><li><p>An <strong>internal</strong> or <strong>embedded DSL</strong> (also <em>&ldquo;fluent interface&rdquo;</em>) is a style of library design where function or method invocations are chained together to form &ldquo;sentences&rdquo;. For instance, <a href=https://martinfowler.com/bliki/FluentInterface.html target=_blank rel=noopener>Martin Fowler&rsquo;s classic essay mentions JMock</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>mock.expects(once()).method(<span>â€œ</span>m<span>â€</span>).with( or(stringContains(<span>â€œ</span>hello<span>â€</span>),
</span></span><span style=display:flex><span>                                        stringContains(<span>â€œ</span>howdy<span>â€</span>)) );
</span></span></code></pre></div><p>but I am sure nowadays you&rsquo;ll have seen plenty of those. The more the syntax of your &ldquo;host&rdquo; language is flexible, the more your &ldquo;internal&rdquo; DSL will look like its own language. For instance, at some point Scala was notorious for <a href=https://www.scala-graph.org/guides/1.x/core-initializing.html#EdgeFactories target=_blank rel=noopener>going a bit too wild with operators</a>. The benefit of this style is that you don&rsquo;t need to define your own parser and tooling. The downside is that the &ldquo;host&rdquo; language is not really aware of your &ldquo;guest&rdquo; language, so error messages might be more inscrutable.</p></li></ul><p>Depending on how flexible your language is, the boundaries between internal and external DSLs might blur: for instance <a href=https://docs.racket-lang.org/guide/languages.html target=_blank rel=noopener>Racket allows you to define your own syntax in term of the core syntax</a>; in fact <a href=https://docs.racket-lang.org/rhombus/index.html target=_blank rel=noopener>Rhombus is a recent addition to the family, with whitespace-delimited, Python-like syntax</a>.</p><p>In general, the way you will implement your language is really a detail, at this point. But because of the way LLMs change language economics, I would argue that the cost of defining your own syntax instead of leaning onto the host language&rsquo;s is now much lower; in fact, I would even dare to say that you might want to <em>prefer</em> flexible syntax, so that you will be able to optimize for token cost.</p><h2 id=conclusions>Conclusions <a href=#conclusions class=anchor>ğŸ”—</a></h2><p>Over the years the pendulum has swung back and forth, when it comes to domain-specific languages. In late 2000s and early 2010s there was an explosion of newer programming languages, and there was a lot of excitement around DSLs, including <a href=https://www.manning.com/books/dsls-in-action target=_blank rel=noopener>Debasish Ghosh&rsquo;s classic &ldquo;DSLs in Action&rdquo;</a><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>In recent years, there has been something of a â€œwinterâ€ in DSL design and development due to the high maintenance costs and the tooling expectations from end users. This blog post explored the syntactic dimension of &ldquo;token-efficiency&rdquo; in DSL design: I invite you to explore more of this space, including semantics; I, for one, will welcome more crazy DSL implementations!</p><p>I hope that with the avalanche of changes AI is bringing to our daily lives, it will also ignite a renewed wave of enthusiasm for language design.</p><p>If it won&rsquo;t, well, I know <a href=https://x.com/evacchi/status/1971956291913634265 target=_blank rel=noopener>I&rsquo;ll find a way</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Yes, I hear you: context windows are getting larger; however, research has shown that performance may suffer at much smaller lengths than the theoretical maximum context size. e.g.:</p><ul><li>Context Is What You Need: The Maximum Effective Context Window for Real World Limits of LLMs (Paulsen, 2025)</li><li>Context Length Alone Hurts LLM Performance Despite Perfect Retrieval (Du et al., 2025)</li><li>LLM Effective Context Limits â€“ Why Does the Effective Context Length of LLMs Fall Short? (October 2024)</li></ul>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:2><p>Throughout the rest of the post, we used <code>tiktoken</code> with <code>cl100k_base</code>, used by GPT-4 and similar to Claude&rsquo;s (<code>tiktoken.get_encoding("cl100k_base")</code>)&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>In fact, <a href=https://www.manning.com/books/domain-specific-small-language-models target=_blank rel=noopener>Guglielmo Iozzia is currently writing a book about Domain-Specific <em>Small Language Models</em></a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=tags><a href=/tags/dsl>dsl</a>
<a href=/tags/language-oriented-programming>language-oriented-programming</a></div></section></main><footer id=footer><div class=social><a class="symbol bluesky" href=https://bsky.app/profile/evacchi.dev rel=me target=_blank></a><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>Â© Copyright
2025
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg>
</span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>