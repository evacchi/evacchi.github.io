<!doctype html><html lang=en-us><head><title>Extending Kafka the Hard Way (Part 1) | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="
You might have read my article about plugging Wasm into Kafka Connect, but I wanted to revisit this from a different angle: what if instead of consuming data from a topic and manipulating such data on the client-side, we intercepted data as it lands on the Kafka broker?
But first of all, is it possible to extend the Kafka broker at all?"><meta name=generator content="Hugo 0.149.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Extending Kafka the Hard Way (Part 1)</h1><div class=tip><time datetime="2025-08-25 00:00:00 +0000 UTC">Aug 25, 2025</time>
<span class=split>¬∑
</span><span>1454 words
</span><span class=split>¬∑
</span><span>7 minute read</span></div><div class=content><img src=/assets/kafka/kafka-wasm.jpg alt="Picture of Franz Kafka looking surprised at the Wasm Logo" width=100%><p>You might have read my article about <a href=https://www.getxtp.com/blog/pluggable-stream-processing-with-xtp-and-kafka target=_blank rel=noopener>plugging Wasm into Kafka Connect</a>, but I wanted to revisit this from a different angle: what if instead of <strong>consuming data</strong> from a topic and <strong>manipulating such data on the client-side,</strong> we <strong>intercepted</strong> data as it lands <strong>on the Kafka broker?</strong></p><p>But first of all, <strong>is it possible to extend the Kafka broker at all</strong>?</p><p>Well, <strong>yes and no</strong>. There are indeed some predefined hooks where we can plug custom Java code; in particular, there are places where you can plug your custom Java policy to validate pieces of data; but, <strong>at this time</strong>, <strong>these extension mechanisms do <em>not</em> deal with records.</strong></p><p>The Kafka broker has supported custom user-defined code <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-108%3A+Create+Topic+Policy target=_blank rel=noopener>since at least version 0.10.0</a> with the interface <a href=https://kafka.apache.org/10/javadoc/org/apache/kafka/server/policy/CreateTopicPolicy.html target=_blank rel=noopener><strong>CreateTopicPolicy</strong></a>**, ** which essentially amounts to implementing <strong>one method:</strong></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>void</span> validate(CreateTopicPolicy.RequestMetadata requestMetadata) 
</span></span><span style=display:flex><span>   <span style=color:#00f>throws</span> PolicyViolationException
</span></span></code></pre></div><p>This policy <strong>intercepts all the topic creation requests performed by an admin</strong>, injecting custom validation logic. In other words, the code you plug here will be executed every time someone invokes the standard utility <code>kafka-topic.sh</code> to create a new topic.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kafka-topics.sh --topic my-new-topic --create
</span></span></code></pre></div><p>Users define their own policy by implementing the <code>CreateTopicPolicy</code> interface, then they can package their implementation as a jar, and finally, provided that that jar will be available on the classpath at run-time, they can <strong>specify the class name</strong> using the broker config property <code>create.topic.policy.class.name</code>.</p><p>This is the perfect spot to plug the <a href=https://github.com/extism/chicory-sdk/ target=_blank rel=noopener>Chicory Extism SDK</a>: <a href=https://chicory.dev target=_blank rel=noopener>Chicory</a> is <strong>just plain, simple Java, but with a twist</strong> that proves essential when you are hosting user-defined code: <strong>sandboxing and <strong><em>guaranteed</em></strong> interruptability.</strong> This is what we will show in this blog post.</p><h2 id=thats-all-fine-and-dandy-but-what-about-records>That&rsquo;s all fine and dandy, but what about records? <a href=#thats-all-fine-and-dandy-but-what-about-records class=anchor>üîó</a></h2><p>In the past, there were a <strong>number of attempts to support record validation or transformation in the broker</strong>, but <strong>none landed on the trunk</strong>. For instance, in the order in which they were proposed:</p><ul><li><a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-686%3A+API+to+ensure+Records+policy+on+the+broker target=_blank rel=noopener><strong>KIP-686: API to ensure Records policy on the broker</strong></a></li><li><a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-729%3A+Custom+validation+of+records+on+the+broker+prior+to+log+append target=_blank rel=noopener><strong>KIP-729: Custom validation of records on the broker prior to log append</strong></a></li><li><a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-905%3A+Broker+interceptors target=_blank rel=noopener><strong>KIP-905: Broker interceptors</strong></a></li><li><a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-940%3A+Broker+extension+point+for+validating+record+contents+at+produce+time target=_blank rel=noopener><strong>KIP-940: Broker extension point for validating record contents at produce time</strong></a></li></ul><p>In many cases, <strong>the proponents</strong> eventually <strong>did not follow through</strong> with their idea. One key issue is that supporting this kind of extension means <strong>running user-defined code</strong> on <strong>one of the hottest paths in the broker.</strong></p><p>Not only is this controversial, but it is also <strong>highly risky</strong> because user-defined Java code might fail, go haywire, and, depending on how the code was written, even be hard to interrupt abruptly.</p><p>But the same is not true for Chicory. A Chicory runtime can be <strong>always</strong> interrupted.</p><p>So, <strong>in the next post of this series,</strong> we will walk you through a <strong>PoC where we patch the Kafka broker</strong> and expose a new interface in the style of <code>CreateTopicPolicy</code>. <strong>We will then implement this interface using Chicory</strong> to support <strong>interruptible, sandboxed data transforms.</strong> The new <code>ProduceRequestInterceptor</code> will, again, expose essentially one method:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RecordBatch intercept(RecordBatch batch) 
</span></span><span style=display:flex><span>   <span style=color:#00f>throws</span> ProduceRequestInterceptorException;
</span></span></code></pre></div><p>In practice, the basic <strong>design</strong> <strong>principles for our patch</strong> will be the same as those for <code>CreateTopicPolicy</code> (or any other Java extension point that is *already * present in Kafka). And, when we will plug <strong>Wasm support,</strong> we will follow the same pattern that we will detail in this blog post for <code>CreateTopicPolicy</code>.</p><p>Consider this as your way to get your feet wet.</p><h2 id=nice-interface-it-would-be-a-shame-if-someone-plugged-some-wasm-in-it>Nice interface, it would be a shame if someone plugged some Wasm in it <a href=#nice-interface-it-would-be-a-shame-if-someone-plugged-some-wasm-in-it class=anchor>üîó</a></h2><p>So, let&rsquo;s start simple. In this blog post we will implement the <code>CreateTopicPolicy</code> interface with Chicory, we will plug a Wasm module, and implement one such policy using Wasm and Go.</p><p>We will also show that even a malicious payload can be given a timeout and killed abruptly at any time.</p><p><code>CreateTopicPolicy</code> implements the <code>Configurable</code> interface, which means you can also implement a method to configure your policy. This method will be passed the config properties of the broker. It is safe to assume that this method will be invoked before any topic creation request is handled; so for all intents and purposes, this may act as our initializer.</p><p>For instance, we could look for the path of Wasm binary at <code>create.topic.policy.wasm.path</code> and instantiate it. If you have read <a href=https://www.getxtp.com/blog/pluggable-stream-processing-with-xtp-and-kafka target=_blank rel=noopener>the previous blog post, you will notice a pattern.</a></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>WasmCreateTopicPolicyHandler</span> <span style=color:#00f>implements</span> CreateTopicPolicy {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>private</span> WasmCreateTopicPolicy policy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Override
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> configure(Map&lt;String, ?&gt; configs) {
</span></span><span style=display:flex><span>        <span style=color:green>// Get the config policy</span>
</span></span><span style=display:flex><span>        String wasmPath = configs.get(<span style=color:#a31515>&#34;create.topic.policy.wasm.path&#34;</span>).toString();
</span></span><span style=display:flex><span>        <span style=color:#00f>try</span> {
</span></span><span style=display:flex><span>            <span style=color:green>// Read our wasm file and instantiate a Manifest.</span>
</span></span><span style=display:flex><span>            Path path = Path.of(wasmPath);
</span></span><span style=display:flex><span>            FileInputStream inputStream = <span style=color:#00f>new</span> FileInputStream(wasmPath);
</span></span><span style=display:flex><span>            <span style=color:#00f>var</span> manifest = <span style=color:#00f>new</span> WasmTopicPolicyManifest(
</span></span><span style=display:flex><span>                    inputStream, path.getFileName().toString(), Map.of());
</span></span><span style=display:flex><span>            <span style=color:green>// set the policy</span>
</span></span><span style=display:flex><span>            <span style=color:#00f>this</span>.policy = WasmCreateTopicPolicy.fromManifest(manifest);
</span></span><span style=display:flex><span>        } <span style=color:#00f>catch</span> (IOException e) {
</span></span><span style=display:flex><span>            <span style=color:#00f>throw</span> <span style=color:#00f>new</span> ConfigException(<span style=color:#a31515>&#34;Invalid Wasm binary&#34;</span>, e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Override
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> validate(RequestMetadata requestMetadata) <span style=color:#00f>throws</span> PolicyViolationException {
</span></span><span style=display:flex><span>        policy.validate(requestMetadata);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>WasmCreateTopicPolicy</code> is, <a href=https://www.getxtp.com/blog/pluggable-stream-processing-with-xtp-and-kafka target=_blank rel=noopener>like in the article</a>, just a wrapper around an Extism plugin, exposing the <code>validate</code> method.</p><p>Alright, that&rsquo;s all we need to get started. Now let&rsquo;s define our <strong>validation extension point.</strong></p><blockquote><p>üí° For simplicity, in this example, instead of calling into the XTP service, we assume the plugin is available somewhere on disk, but the same loading strategy we demonstrated in the previous article could be also applied here, potentially allowing you to reload strategies from the network and on the fly. Be mindful, however, that you might not want to clog your broker by repeatedly polling an HTTP service.</p></blockquote><h2 id=xtp-more-like-ex-tee-policy-am-i-right>XTP? More like ex-tee-policy am I right <a href=#xtp-more-like-ex-tee-policy-am-i-right class=anchor>üîó</a></h2><p>In this case, the XTP schema needs very little design. It&rsquo;s just a matter of porting over the Java interface, including the <a href=https://kafka.apache.org/10/javadoc/org/apache/kafka/server/policy/CreateTopicPolicy.RequestMetadata.html target=_blank rel=noopener><code>RequestMetadata</code></a> data structure:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>exports:
</span></span><span style=display:flex><span>  validate:
</span></span><span style=display:flex><span>    input:
</span></span><span style=display:flex><span>      $ref: <span style=color:#a31515>&#34;#/components/schemas/RequestMetadata&#34;</span>
</span></span><span style=display:flex><span>      contentType: application/json
</span></span><span style=display:flex><span>version: v1-draft
</span></span><span style=display:flex><span>components:
</span></span><span style=display:flex><span>  schemas:
</span></span><span style=display:flex><span>    RequestMetadata:
</span></span><span style=display:flex><span>      properties:
</span></span><span style=display:flex><span>        topic:
</span></span><span style=display:flex><span>          type: string
</span></span><span style=display:flex><span>          description: the name of the topic to create
</span></span><span style=display:flex><span>        configs:
</span></span><span style=display:flex><span>          type: object
</span></span><span style=display:flex><span>          description: topic configs in the request, not including broker defaults
</span></span><span style=display:flex><span>        numPartitions:
</span></span><span style=display:flex><span>          type: integer
</span></span><span style=display:flex><span>          description: the number of partitions to create or null if replicaAssignments is not null.
</span></span><span style=display:flex><span>        replicationFactor:
</span></span><span style=display:flex><span>          type: integer
</span></span><span style=display:flex><span>          description: the number of replicas to create or null if replicaAssignments is not null
</span></span><span style=display:flex><span>        replicasAssignments:
</span></span><span style=display:flex><span>          type: object
</span></span><span style=display:flex><span>      description: a map from partition id to replica (broker) ids or null if numPartitions and replicationFactor are set instead.
</span></span></code></pre></div><p>We can now write our policy plugin with <code>xtp plugin init</code>. I named it <code>create-topic-policy-example</code>. Here&rsquo;s my <code>main.go</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#00f>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a31515>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a31515>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>func</span> Validate(input RequestMetadata) <span style=color:#2b91af>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#00f>if</span> strings.Contains(input.Topic, <span style=color:#a31515>&#34;__INVALID__&#34;</span>) {
</span></span><span style=display:flex><span>		<span style=color:#00f>return</span> errors.New(<span style=color:#a31515>&#34;contained the magic keyword `__INVALID__`&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#00f>return</span> <span style=color:#00f>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This simple plug-in intercepts all topic creation requests and rejects all those that contain the text <code>__INVALID__</code>. Build your plugin with <code>xtp plugin build</code> and then configure the broker with the newly created property to point to your wasm binary:</p><pre tabindex=0><code>create.topic.policy.wasm.path=/path/to/create-topic-policy-example/dist/plugin.wasm
</code></pre><p>Start your Kafka broker, and if everything goes as planned, you can now try to create a topic with the magic string:</p><pre tabindex=0><code>‚ùØ bin/kafka-topics.sh --bootstrap-server localhost:9092 \
  --topic my__INVALID__topic --create
Error while executing topic command : Wasm Policy rejected the topic 
&#39;my__INVALID__topic&#39; with error &#39;Error evaluating function validate: 
Topic rejected, contained the magic keyword &#39;__INVALID__&#39;&#39;
</code></pre><p>while all other topics will work as expected</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>‚ùØ bin/kafka-topics.sh --bootstrap-server localhost:9092 <span style=color:#a31515>\
</span></span></span><span style=display:flex><span><span style=color:#a31515></span>	--topic my-topic --create
</span></span><span style=display:flex><span>Created topic my-topic.
</span></span></code></pre></div><p>There&rsquo;s no trick here! The policy is evaluated <strong>by the broker,</strong> and the error is returned <strong>to the client.</strong></p><h2 id=killing-me-softly>Killing me softly <a href=#killing-me-softly class=anchor>üîó</a></h2><p>Now what if our policy goes rogue? Let&rsquo;s modify our plug-in as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>func Validate(input RequestMetadata) error {
</span></span><span style=display:flex><span>	<span style=color:#00f>for</span> {
</span></span><span style=display:flex><span>		<span style=color:green>// infinite loop</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#00f>return</span> nil
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The Chicory runtime handles thread interruption requests, so execution can be safely interrupted at any time. Let&rsquo;s modify our <code>validate()</code> routine with a timeout:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#2b91af>void</span> validate(RequestMetadata requestMetadata) <span style=color:#00f>throws</span> PolicyViolationException {
</span></span><span style=display:flex><span>    <span style=color:#00f>try</span> {
</span></span><span style=display:flex><span>        CompletableFuture
</span></span><span style=display:flex><span>                .runAsync(() -&gt; <span style=color:#00f>this</span>.policy.validate(requestMetadata))
</span></span><span style=display:flex><span>                .get(500, TimeUnit.MILLISECONDS);
</span></span><span style=display:flex><span>        } <span style=color:#00f>catch</span> (InterruptedException | TimeoutException e) {
</span></span><span style=display:flex><span>            <span style=color:#00f>throw</span> <span style=color:#00f>new</span> PolicyViolationException(
</span></span><span style=display:flex><span>                    <span style=color:#a31515>&#34;Policy evaluation exceeded the given time limit. &#34;</span> +
</span></span><span style=display:flex><span>                            <span style=color:#a31515>&#34;Default to reject.&#34;</span>, e);
</span></span><span style=display:flex><span>    } <span style=color:#00f>catch</span> (ExecutionException e) {
</span></span><span style=display:flex><span>       <span style=color:green>// handle the execution exception and turn it into a PolicyViolationException</span>
</span></span><span style=display:flex><span>       <span style=color:#00f>throw</span> <span style=color:#00f>new</span> PolicyViolationException(...);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the policy will be terminated after a maximum of 500 milliseconds.</p><pre tabindex=0><code>‚ùØ bin/kafka-topics.sh --bootstrap-server localhost:9092 --topic my_topic --create
Error while executing topic command : Policy evaluation exceeded the given time 
limit. Default to reject.
</code></pre><p>Congrats! You just plugged Wasm in a Kafka broker!</p><blockquote><p>üí° <strong>Rough around the edges.</strong> The example we have written is not thread-safe because it reuses a single Wasm instance against all requests. If multiple requests were to be served at the same time, we might corrupt the Wasm memory. You might want to create a <strong>pool of Wasm plug-ins</strong> and reuse them to serve distinct validation requests.</p></blockquote><h2 id=conclusions>Conclusions <a href=#conclusions class=anchor>üîó</a></h2><p>I hope you enjoyed this introduction to extending the Kafka broker with Chicory and Extism. In the next post, we will detail the delicate path where the Kafka broker handles incoming records.</p><p>Brace for some open-heart surgery on the core of Kafka!</p></div><div class=tags><a href=/tags/kafka>Kafka</a>
<a href=/tags/chicory>Chicory</a>
<a href=/tags/webassembly>WebAssembly</a></div></section></main><footer id=footer><div class=social><a class="symbol bluesky" href=https://bsky.app/profile/evacchi.dev rel=me target=_blank></a><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2025
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg>
</span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>