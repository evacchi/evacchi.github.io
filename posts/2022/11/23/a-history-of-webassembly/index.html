<!doctype html><html lang=en><head><title>A History of WebAssembly | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Lately there have been quite a few announcements around WebAssembly, such as the Docker+Wasm Technical Preview. You may have started to wonder whether this technology is something you should care about.
In this blog post, we will lightheartedly explore the history of Wasm. I will not make any claim about correctness: I may have made mistakes; in that case, feel free to contact me! I will try to motivate how we came to defining the WebAssembly standard and VM, and how they are all about providing a multi-platform, portable low-level compilation target for multiple programming languages."><meta name=generator content="Hugo 0.112.4"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>A History of WebAssembly</h1><div class=tip><time datetime="2022-11-23 00:00:00 +0000 UTC">Nov 23, 2022</time>
<span class=split>¬∑</span>
<span>1260 words</span>
<span class=split>¬∑</span>
<span>6 minute read</span></div><div class=content><img src=https://i.imgur.com/JnJO7HZ.jpg style=float:right width=400/><p>Lately there have been quite a few announcements around WebAssembly, such as the <a href=https://www.docker.com/blog/docker-wasm-technical-preview/ target=_blank rel=noopener>Docker+Wasm Technical Preview</a>. You may have started to wonder whether this technology is something you should care about.</p><p>In this blog post, we will lightheartedly explore the history of Wasm. I will not make any claim about correctness: I may have made mistakes; in that case, feel free to contact me! I will try to motivate how we came to defining the WebAssembly standard and VM, and how they are all about providing a multi-platform, portable low-level <strong>compilation target</strong> for multiple programming languages. In fact, a history of WebAssembly really is&mldr;</p><h2 id=a-history-of-running-arbitrary-code-in-the-browser>A History of Running Arbitrary Code in the Browser <a href=#a-history-of-running-arbitrary-code-in-the-browser class=anchor>üîó</a></h2><p>And indeed, this finds its root in some of the earliest days of the Internet going mainstream (let&rsquo;s call them the &ldquo;Geocities days&rdquo;). Browser had limited extensibility; but you could script your web page using a tiny cute language called JavaScript, that, as we all know, bear <em>only a superficial similarity to Java</em> (basically &ldquo;it has braces&rdquo; and similar control flow structures, including falling-through <code>switch</code> because why not). At the beginning, JavaScript was mostly meant to add a tidbit of interactivity to web pages.</p><h3 id=the-early-days-browser-plug-ins>The Early Days: Browser Plug-Ins <a href=#the-early-days-browser-plug-ins class=anchor>üîó</a></h3><p>If you wanted full-blown multimedia capabilities you could use <strong>plug-ins</strong> instead. There were multimedia players such as Real Player, Windows Media Player, Quicktime; but also programmable platforms such as Flash, Shockwave, Java and also, at some point Silverlight. But developers could write their own shared libraries and link them against the browser runtime.</p><p>There were downsides: for instance, these libraries had to be shipped for multiple browsers, multiple operating systems and possibly multiple architectures. They had to be periodically updated, and, in general, they ran with the full-permission level of the browser, which in turn made them susceptible to security exploits.</p><h3 id=rise-of-the-transpilers>Rise of the Transpilers <a href=#rise-of-the-transpilers class=anchor>üîó</a></h3><div style=float:right;margin-left:1em><img src=https://i.imgur.com/miQZNW0.png style=float:right width=300></div><p>Plug-ins got the job done, but keeping them up-to-date and secure was a chore. In the meantime, browsers were becoming more and more powerful. For instance. While videos and music needed plug-in support for a long time, at some point browsers gained video and music playing capabilities. Around the same time, Web developers discovered that, even with all its quirks, JavaScript was a decent language after all. Google, with <a href=https://v8.dev/ target=_blank rel=noopener>Chrome and the V8 (2008)</a> runtime, demonstrated that you could achieve quite a reasonable amount of performance using a well-engineered JIT compiler; and at some point, with Node.js <a href=https://nodejs.org/en/ target=_blank rel=noopener>it even escaped the browser (2009)</a>.</p><p>However, for a long time the JavaScript language could not evolve. In order to support the largest number of browsers and not to &ldquo;break the web&rdquo;, even if some browsers could support different or better programming languages (e.g. Google initially tried this with <a href=https://dart.dev/ target=_blank rel=noopener>Dart (2011)</a>) people had to target the lowest common denominator.</p><p>This is probably one of the reasons why there was a sudden spike in so-called &ldquo;Transpilers&rdquo;. If you know me, you will now that I am not in love with the term, because <strong>Transpilers are just Compilers-In-Disguise</strong>. Regardless, it just meant that most of these source-to-source translators (better name, but indeed a bit long) targeted JavaScript. In other words, you could write whitespace-delimited <a href=https://coffeescript.org/ target=_blank rel=noopener>Coffeescript (2009)</a> (the first of such transpilers to go mainstream) and desugar it to well-formatted JavaScript, minus the pain.</p><div style=float:left;margin-right:1em><img src=https://i.imgur.com/Qo4sPje.png width=300></div><p>Around the same time, many other transpilers were released (including even pre-processors for CSS and HTML). Even people that did not really know JavaScript could write Web applications using one of these &ldquo;compile-to-JavaScript&rdquo; languages. Even the Java scene got excited for a while about the <a href=https://www.gwtproject.org/ target=_blank rel=noopener>Google Web Toolkit (GWT, 2006)</a>, a Java compiler framework that promised to handle the client/server split in an automated way (an evolution of GWT still exist in the <a href=https://github.com/google/j2cl target=_blank rel=noopener>J2CL compiler</a>). And I am not even mentioning the number of tools to transpile CSS and, heck, even HTML.</p><p>As a result, front-end developers grew accustomed to expect a build step in their regular workflow; even if you just wanted to use JavaScript! In fact, the <a href=https://babeljs.io/ target=_blank rel=noopener>Babel.js project (2014)</a> allowed (and still allows) to use features in recent releases of the language, desugaring them into syntax for the older releases. And, since you are already waiting for a build stage, you might as well carry some static analysis there. And then <a href=https://www.typescriptlang.org/ target=_blank rel=noopener>TypeScript (2012)</a> was born. But that&rsquo;s another story.</p><h3 id=a-compilation-target>A Compilation Target <a href=#a-compilation-target class=anchor>üîó</a></h3><p>In the meantime, Google was presenting to the world its sandboxing technology for the browser, called <a href=https://developer.chrome.com/docs/native-client/overview/ target=_blank rel=noopener>Native Client (or NaCl (2011)</a>). While similar in principle to plug-ins (you had to ship executable code for different architectures), the difference was that Native Client executables were not unrestricted like traditional plugins, but ran in a sandboxed environment; morever, now a web-page could carry its own specific binary payload; while, traditionally plug-ins had to be installed separately. Finally, with Portable Native Client (PNaCl), you could also target an abstract CPU architecture, and the browser would &ldquo;JIT it&rdquo; to the actual architecture. The NaCl compiler toolchain was essentially a customized C/C++ toolchain. The main downside was that (P)NaCl was still a Chrome-specific technology.</p><p>At this point some people also realized that, since JS was effectively being treated as a compilation target, nothing would prevent us from &ldquo;transpiling&rdquo; languages that traditionally targeted bare-metal CPU architectures (such as C/C++) into JavaScript. ‚Äî Incidentally, this is also where the traditional notion of a &ldquo;transpiler&rdquo; falls apart (at least to me): if a Transpiler is ¬´a translator between languages &ldquo;at the same level of abstraction&rdquo;¬ª, is a translator from C to JS really between languages &ldquo;at the same level of abstraction&rdquo;?</p><p>And then another thought surfaced: what if we designed a <em>strict subset</em> of JS, such that a smart JIT can turn it into efficient native code for the &ldquo;real&rdquo; host CPU?</p><iframe style=float:right width=560 height=315 src=https://www.youtube-nocookie.com/embed/BV32Cs_CMqo title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>That&rsquo;s how ASM.JS (2013) was born. The ground-breaking <a href=#>Unreal demo</a> showed native or near-native performance could be achieved by the JavaScript engine of a regular browser, equipped with a JIT-compiler that could recognize a specific subset of JavaScript. Such a subset could be easily translated into native code using the <a href=https://emscripten.org target=_blank rel=noopener>Emscripten</a> toolchain, making it effectively <a href=https://www.hanselman.com/blog/javascript-is-assembly-language-for-the-web-sematic-markup-is-dead-clean-vs-machinecoded-html target=_blank rel=noopener>&ldquo;The Assembly Of The Web&rdquo;</a> as people had already started to call JavaScript.</p><p>This is an example of how a C function would be translated into an ASM.JS equivalent snippet:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#2b91af>int</span> f(<span style=color:#2b91af>int</span> i) {
</span></span><span style=display:flex><span>  <span style=color:#00f>return</span> i + 1;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function f(i) {
</span></span><span style=display:flex><span>  i = i|0;
</span></span><span style=display:flex><span>  <span style=color:#00f>return</span> (i + 1)|0;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you may notice, this is still valid JS, albeit stylized in such a way that a &ldquo;smart&rdquo; interpreter could figure out extra details about the code. In this case, the <code>|0</code> annotation really is a binary <code>or</code> with <code>0</code>. Because JS does not define a proper integer type (only IEEE 754 floating points), but the binary <code>or</code> operation against a literal <code>0</code> is only meaningful when <code>i</code> is an integer, this is effectively telling the JIT that <code>i</code> <em>is</em> an integer value.</p><p>After ASM.JS was released, it became clear that JavaScript engines could support a proper compilation target; now, parsing <em>text</em> for the purpose of turning into binary instructions is just inconvenient. Let&rsquo;s do away with that. What if we use an efficient, compact binary representation with a lower-level semantics, that can be efficiently interpreted and JIT-compiled into native code for fast execution?</p><p>Well, that&rsquo;s WebAssembly.</p><h2 id=conclusion>Conclusion <a href=#conclusion class=anchor>üîó</a></h2><p>This is only the first part of our journey. In the next part, that will be kindly hosted on the <a href=https://www.javaadvent.com/ target=_blank rel=noopener>Java Advent Blog</a> we will do a deeper comparison between Java and WebAssembly, and we will learn why, in spite of the name, there is more to WebAssembly than just &ldquo;the Web&rdquo;.</p></div><div class=tags><a href=/tags/wasm>wasm</a>
<a href=/tags/compilers>compilers</a></div></section></main><footer id=footer><div class=social><a class="symbol _merge" href rel=me target=_blank></a><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2023
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>