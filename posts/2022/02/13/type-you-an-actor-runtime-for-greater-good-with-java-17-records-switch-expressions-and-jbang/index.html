<!doctype html><html lang=en><head><title>Type You An Actor Runtime For Greater Good! (with Java 17, records, switch expressions and JBang) | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="This blog post was originally published at the Java Advent Calendar 2021, so pardon all the festive references. San Biagio was just a few days ago, but if that really bothers you, you can mentally replace all references to Panettone with Tortelli alla crema e chiacchiere di Carnevale.
The festive season is that period of the year when they tempt you to indulge in those dear sweet, sugary treats.
Personally, as an Italian, I do love me some panettone."><meta name=generator content="Hugo 0.112.4"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Type You An Actor Runtime For Greater Good! (with Java 17, records, switch expressions and JBang)</h1><div class=tip><time datetime="2022-02-13 00:00:00 +0000 UTC">Feb 13, 2022</time>
<span class=split>¬∑</span>
<span>4063 words</span>
<span class=split>¬∑</span>
<span>20 minute read</span></div><div class=content><p><em>This blog post was originally published at the <a href=https://www.javaadvent.com/2021/12/type-you-an-actor-runtime-for-greater-good-with-java-17-records-switch-expressions-and-jbang.html target=_blank rel=noopener>Java Advent Calendar 2021</a></em>, so pardon all the festive references. <a href=https://it.wikipedia.org/wiki/Panettone#Varianti target=_blank rel=noopener>San Biagio</a> was just a few days ago, but if that really bothers you, you can mentally replace all references to Panettone with <a href=https://it.wikipedia.org/wiki/Frittella target=_blank rel=noopener>Tortelli alla crema</a> e <a href=https://it.wikipedia.org/wiki/Chiacchiere target=_blank rel=noopener>chiacchiere</a> di <a href=https://en.wikipedia.org/wiki/Carnival target=_blank rel=noopener>Carnevale</a>.</p><p>The festive season is that period of the year when they tempt you to indulge in those dear sweet, sugary treats.</p><div style=float:right><img src=/assets/actor-3/shakespeare.png alt="Whimsical sketch of Shakespeare"></div><p>Personally, as an Italian, I do love me some <a href=https://en.wikipedia.org/wiki/Panettone target=_blank rel=noopener>panettone</a>. And as much as I enjoy the bitter taste of Java coffee, I have been enjoying the sugar that has been introduced in the most recent versions. Indeed, I believe that Java 17 really hits the sweet spot, when it comes to treats. So what better time of the year to indulge in Java&rsquo;s sweet, sweet sugar than this December?</p><p>Last year <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>I published a blog series</a> with my take on <a href=https://viktorklang.com/ target=_blank rel=noopener>Viktor Klang</a>&rsquo;s original <a href=https://gist.github.com/viktorklang/2557678 target=_blank rel=noopener>tiny Java</a> and <a href=https://gist.github.com/viktorklang/2362563 target=_blank rel=noopener>Scala</a> actor system, updated for Java 17.</p><p><em>Untyped</em> actors in the style of <a href=https://doc.akka.io/docs/akka/current/actors.html target=_blank rel=noopener>Akka Classic</a> used to be clunky to write in Java, because Java used to lack some key goodies:</p><ol><li>a concise way to express messages; but now we have <strong>records</strong></li><li>a tidy syntax to match against the types of the incoming messages; but now we have <strong>switch expressions</strong> and <strong>pattern matching</strong></li></ol><p>Another key addition is <strong>sealed type hiearchies</strong>. If you are able to express the upper bound of your type hierarchy, and such a type hierarchy is &ldquo;sealed&rdquo;, then the compiler will tell you if you are missing a <code>case</code> in a <code>switch</code> expression (<em>exhaustiveness check</em>).</p><p>For instance:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>sealed <span style=color:#00f>interface</span> <span style=color:#2b91af>A</span> {
</span></span><span style=display:flex><span>    record X() <span style=color:#00f>implements</span> A{} 
</span></span><span style=display:flex><span>    record Y() <span style=color:#00f>implements</span> A{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> f(A a) {
</span></span><span style=display:flex><span>        <span style=color:#00f>switch</span> (a) {
</span></span><span style=display:flex><span>            <span style=color:#00f>case</span> X x -&gt; {}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you put this in <code>A.java</code> and run it with <code>java --enable-preview --source 17 A.java</code> you&rsquo;ll read:</p><pre tabindex=0><code>A.java:6: error: the switch statement does not cover all possible input values
        switch (a) {
        ^
</code></pre><p>In my <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>previous blog posts</a> I have detailed how to develop an actor runtime for <em>untyped actors</em>; that is, actors that can accept <em>any kind of message</em>. In this part we are rewriting that actor runtime from scratch and implement a <strong>typed actor runtime</strong>, and we will see how sealed type hierarchies can improve the code we write!</p><ol><li><a href=#the-actor-model>The Actor Model</a></li></ol><ul><li><a href=#behaviors-and-effects>Behaviors and Effects</a></li><li><a href=#example-1-a-hello-world>Example 1: A Hello World</a></li><li><a href=#example-2-ping-pong>Example 2: Ping Pong</a></li><li><a href=#example-3-a-vending-machine>Example 3: A Vending Machine</a></li></ul><ol start=2><li><a href=#implementing-the-actor-system>Implementing The Actor System</a></li><li><a href=#wrapping-up>Wrapping Up</a></li></ol><p>This is the full listing of our typed actor runtime. You can also find it <a href=https://gist.github.com/evacchi/b601498c3d8d483e3350f00b4c8aabf5 target=_blank rel=noopener>at this repository</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>package</span> io.github.evacchi;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>import</span> java.util.concurrent.*;
</span></span><span style=display:flex><span><span style=color:#00f>import</span> java.util.concurrent.atomic.AtomicInteger;
</span></span><span style=display:flex><span><span style=color:#00f>import</span> java.util.function.Function;
</span></span><span style=display:flex><span><span style=color:#00f>import static</span> java.lang.System.out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>TypedActor</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>interface</span> <span style=color:#2b91af>Effect</span>&lt;T&gt; <span style=color:#00f>extends</span> Function&lt;Behavior&lt;T&gt;, Behavior&lt;T&gt;&gt; {}
</span></span><span style=display:flex><span>    <span style=color:#00f>interface</span> <span style=color:#2b91af>Behavior</span>&lt;T&gt; <span style=color:#00f>extends</span> Function&lt;T, Effect&lt;T&gt;&gt; {}
</span></span><span style=display:flex><span>    <span style=color:#00f>interface</span> <span style=color:#2b91af>Address</span>&lt;T&gt; { <span style=color:#2b91af>void</span> tell(T msg); }
</span></span><span style=display:flex><span>    <span style=color:#00f>static</span> &lt;T&gt; Effect&lt;T&gt; Become(Behavior&lt;T&gt; next) { <span style=color:#00f>return</span> current -&gt; next; }
</span></span><span style=display:flex><span>    <span style=color:#00f>static</span> &lt;T&gt; Effect&lt;T&gt; Stay() { <span style=color:#00f>return</span> current -&gt; current; }
</span></span><span style=display:flex><span>    <span style=color:#00f>static</span> &lt;T&gt; Effect&lt;T&gt; Die() { <span style=color:#00f>return</span> Become(msg -&gt; { out.println(<span style=color:#a31515>&#34;Dropping msg [&#34;</span> + msg + <span style=color:#a31515>&#34;] due to severe case of death.&#34;</span>); <span style=color:#00f>return</span> Stay(); }); }
</span></span><span style=display:flex><span>    record System(Executor executor) {
</span></span><span style=display:flex><span>        <span style=color:#00f>public</span> &lt;T&gt; Address&lt;T&gt; actorOf(Function&lt;Address&lt;T&gt;, Behavior&lt;T&gt;&gt; initial) {
</span></span><span style=display:flex><span>            <span style=color:#00f>abstract</span> <span style=color:#00f>class</span> <span style=color:#2b91af>AtomicRunnableAddress</span>&lt;T&gt; <span style=color:#00f>implements</span> Address&lt;T&gt;, Runnable
</span></span><span style=display:flex><span>                { AtomicInteger on = <span style=color:#00f>new</span> AtomicInteger(0); }
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> <span style=color:#00f>new</span> AtomicRunnableAddress&lt;T&gt;() {
</span></span><span style=display:flex><span>                <span style=color:green>// Our awesome little mailbox, free of blocking and evil
</span></span></span><span style=display:flex><span><span style=color:green></span>                <span style=color:#00f>final</span> ConcurrentLinkedQueue&lt;T&gt; mbox = <span style=color:#00f>new</span> ConcurrentLinkedQueue&lt;&gt;();
</span></span><span style=display:flex><span>                Behavior&lt;T&gt; behavior = initial.apply(<span style=color:#00f>this</span>);
</span></span><span style=display:flex><span>                <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> tell(T msg) { mbox.offer(msg); async(); }  <span style=color:green>// Enqueue the message onto the mailbox and try to schedule for execution
</span></span></span><span style=display:flex><span><span style=color:green></span>                <span style=color:green>// Switch ourselves off, and then see if we should be rescheduled for execution
</span></span></span><span style=display:flex><span><span style=color:green></span>                <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> run() {
</span></span><span style=display:flex><span>                    <span style=color:#00f>try</span> { <span style=color:#00f>if</span> (on.get() == 1) { T m = (T) mbox.poll(); <span style=color:#00f>if</span> (m != <span style=color:#00f>null</span>) behavior = behavior.apply(m).apply(behavior); }
</span></span><span style=display:flex><span>                    } <span style=color:#00f>finally</span> { on.set(0); async(); }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:green>// If there&#39;s something to process, and we&#39;re not already scheduled
</span></span></span><span style=display:flex><span><span style=color:green></span>                <span style=color:#2b91af>void</span> async() {
</span></span><span style=display:flex><span>                    <span style=color:#00f>if</span> (!mbox.isEmpty() &amp;&amp; on.compareAndSet(0, 1)) {
</span></span><span style=display:flex><span>                        <span style=color:green>// Schedule to run on the Executor and back out on failure
</span></span></span><span style=display:flex><span><span style=color:green></span>                        <span style=color:#00f>try</span> { executor.execute(<span style=color:#00f>this</span>); } <span style=color:#00f>catch</span> (Throwable t) { on.set(0); <span style=color:#00f>throw</span> t; }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>{: style=&ldquo;font-size: small&rdquo;}</p><h2 id=the-actor-model>The Actor Model <a href=#the-actor-model class=anchor>üîó</a></h2><p>In the <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>first part</a> we learned what the actor model is. Here is a refresher:
the Actor Model is a <em>concurrency model</em> where the unit of execution is called <em>an actor</em>. An actor <em>receives messages</em>.
In response to a message, an actor may (e.g. cf. <a href=https://en.wikipedia.org/wiki/Actor_model#Fundamental_concepts target=_blank rel=noopener>Wikipedia</a>):</p><ul><li>send a message to another actor</li><li>create new actors</li><li>transition to a new state, with a different <em>behavior</em>, to handle the next message</li></ul><p>In the following section, we will revisit basic concepts about actors. If you have
already read the previous posts in this series you will find yourself at home.</p><p>However, in this <em>typed</em> version I have revisited them, with new,
genericified type signatures.</p><h3 id=behaviors-and-effects>Behaviors and Effects <a href=#behaviors-and-effects class=anchor>üîó</a></h3><p>The <em>behavior</em> of an actor is just a <em>function</em> that, applied to a message,
returns another behavior.</p><p>Actors usually encapsulate <em>state</em>; thus, as a side-effect, the <em>behavior</em>
function usually updates the state of the actor; it may send other messages
to other actors, and creates new actors to handle new state.</p><p>For instance, you will have noticed how most web platforms allow
you to export the content you have created; but most of them
will start a background process and will notify you later when the archive
is ready; for instance, by sending a link to your e-mail address.</p><p>When the service receives your &ldquo;export&rdquo; request, an actor may be responsible
for acknowledging your request immediately; but it may spawn another actor
to process the request in the background.</p><div><img src=/assets/actor-3/diag-spawn.png alt="Diagram of an HTTP request actor"></div><p>At its core, an actor is just a routine paired with a message queue.
But instead of evaluating the routine as soon as a message is sent,
the system submits a message to the queue of the receiver.
Then, at some point, the system &ldquo;wakes up&rdquo; that actor: it takes
one message from the queue, and it applies the routine to that message.</p><p>The routine returns a description of the <em>next state</em> of the actor;
i.e. the routine that should be executed when a new message is evaluated.</p><p>Such a routine is called a <em>behavior</em>, and in code, the <code>Behavior</code> can be defined
as a function that takes a message of some type, and it returns a <em>transition</em>
between states that we call an <code>Effect</code>:</p><pre tabindex=0><code>Behavior : T ‚ü∂ Effect
</code></pre><p>where <code>T</code> is some known type.</p><p>An <code>Effect</code> describes a <em>transition</em> between two
states of the actor. It can be represented as a <em>function</em>
that takes the current <code>Behavior</code> and returns the next <code>Behavior</code>:</p><pre tabindex=0><code>Effect : Behavior ‚ü∂ Behavior
</code></pre><p>In code, we may write them as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Behavior</span>&lt;T&gt; <span style=color:#00f>extends</span> Function&lt;T, Effect&lt;T&gt;&gt; {}
</span></span><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Effect</span>&lt;T&gt; <span style=color:#00f>extends</span> Function&lt;Behavior&lt;T&gt;, Behavior&lt;T&gt;&gt; {}
</span></span></code></pre></div><p>The most basic <code>Effect</code>s (state transitions) are <code>Stay</code> and <code>Die</code>:</p><ul><li><code>Stay</code> means no behavioral change</li><li><code>Die</code> will effectively turn off the actor, making it inactive.</li></ul><p>For instance, this is a valid behavior for an actor that
starts, then waits for one message, then it dies: i.e.,
it will drop and ignore all subsequent messages and/or
the system may decide to collect it and throw it away.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Effect&lt;String&gt; receiveThenDie(String msg) {
</span></span><span style=display:flex><span>    out.println(<span style=color:#a31515>&#34;Got msg: &#39;&#34;</span> + msg + <span style=color:#a31515>&#34;&#39;; length: &#34;</span> + msg.length());
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> TypedActor.Die();
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>or written differently:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Behavior&lt;String&gt; receiveThenDie = msg -&gt; {
</span></span><span style=display:flex><span>    out.println(<span style=color:#a31515>&#34;Got msg &#39;&#34;</span> + msg + <span style=color:#a31515>&#34;&#39;; length: &#34;</span> + msg.length());
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> TypedActor.Die();
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=example-1-a-hello-world>Example 1: A Hello World <a href=#example-1-a-hello-world class=anchor>üîó</a></h3><blockquote><p>You can run the following example with:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>j! https://github.com/evacchi/min-java-actors/blob/main/src/main/java/io/github/evacchi/typed/examples/HelloWorld.java
</span></span></code></pre></div></blockquote><p>In this example we will create an actor system,
then spawn an actor that will process one message and then <code>Die</code>.
You will recognize the behavior <code>receiveThenDie</code> that we defined above.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// create an actor runtime (an actor &#34;system&#34;)
</span></span></span><span style=display:flex><span><span style=color:green></span>var actorSystem = <span style=color:#00f>new</span> Actor.System(Executors.newCachedThreadPool());
</span></span><span style=display:flex><span><span style=color:green>// create an actor
</span></span></span><span style=display:flex><span><span style=color:green></span>Address&lt;String&gt; actor = actorSystem.actorOf(self -&gt; msg -&gt; {
</span></span><span style=display:flex><span>    out.println(<span style=color:#a31515>&#34;self: &#34;</span> + self +<span style=color:#a31515>&#34;; got msg: &#39;&#34;</span> + msg + <span style=color:#a31515>&#34;&#39;; length: &#34;</span> + msg.length());
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> Actor.Die();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>The <code>actorOf</code> method returns an <code>Address&lt;T></code> which is defined as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Address</span>&lt;T&gt; { Address&lt;T&gt; tell(T msg); }
</span></span></code></pre></div><p>allowing us to write:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>actor.tell(<span style=color:#a31515>&#34;foo&#34;</span>);
</span></span><span style=display:flex><span>actor.tell(<span style=color:#a31515>&#34;bar&#34;</span>);
</span></span></code></pre></div><p>or just:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>actor.tell(<span style=color:#a31515>&#34;foo&#34;</span>).tell(<span style=color:#a31515>&#34;bar&#34;</span>);
</span></span></code></pre></div><p>which, when executed, prints the following:</p><pre tabindex=0><code>self: io.github.evacchi.TypedActor$System$1@24a95c2e; got msg &#39;foo&#39;; length, 3
Dropping msg [foo] due to severe case of death.
</code></pre><p>because the <code>"bar"</code> message was sent to a dead actor.</p><p>If we change the lambda to return <code>stay</code> instead:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Address&lt;String&gt; actor = actorSystem.actorOf(self -&gt; msg -&gt; {
</span></span><span style=display:flex><span>    out.println(<span style=color:#a31515>&#34;self: &#34;</span> + self +<span style=color:#a31515>&#34;; got msg: &#39;&#34;</span> + msg + <span style=color:#a31515>&#34;&#39;; length: &#34;</span> + msg.length());
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> Stay();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>then the output would read:</p><pre tabindex=0><code>self: io.github.evacchi.TypedActor$System$1@7519a17c; got msg: &#39;foo&#39;; length: 3
self: io.github.evacchi.TypedActor$System$1@7519a17c; got msg: &#39;bar&#39;; length: 3
</code></pre><p>You may define <code>Stay</code> as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> &lt;T&gt; Effect&lt;T&gt; Stay() { <span style=color:#00f>return</span> current -&gt; current; }
</span></span></code></pre></div><p>that is, a transition from the current behavior to the current behavior (i.e. it <em>stays</em>
in the same state.)</p><p><code>Die</code> is defined as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> &lt;T&gt; Effect&lt;T&gt; Die() { 
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> Become(msg -&gt; {
</span></span><span style=display:flex><span>        out.println(<span style=color:#a31515>&#34;Dropping msg [&#34;</span> + msg + <span style=color:#a31515>&#34;] due to severe case of death.&#34;</span>); 
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> Stay(); 
</span></span><span style=display:flex><span>    }); 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>where <code>Become</code> is:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Effect&lt;T&gt; Become(Behavior&lt;T&gt; next) { <span style=color:#00f>return</span> current -&gt; next; }
</span></span></code></pre></div><p>i.e. <code>Become</code> is a method, that, given a <code>Behavior</code> returns an <em>effect</em>.
And that effect is taking the <code>current</code> behavior and returning the <code>next</code> one.</p><p>Thus, <code>Die</code> is just an effect that takes the <code>prev</code> behavior and returns the behavior to drop
all messages, and then <code>Stay</code>s in that state.</p><p>With the exception of <code>Become</code>, which takes a parameter (<code>next</code>), you may be wondering
why <code>Stay</code> and <code>Die</code> are not constant fields:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Effect&lt;T&gt; Stay =  <span style=color:#00f>return</span> current -&gt; current; 
</span></span></code></pre></div><p>You may be wondering what <code>self</code> is.
<code>self</code> is a self-reference to the actor. It serves the same purpose as <code>this</code> in a class.
Because the behavior is written as a function, we need to &ldquo;seed&rdquo; a reference to
<code>this</code> into the function. But there is no <code>this</code> until
the actor is actually created by the runtime, so
we provide it in the closure, so that it may be filled lazily.</p><p>If this is not too clear, don&rsquo;t worry for now; we&rsquo;ll get to that later.</p><h4 id=use-of-types>Use of Types <a href=#use-of-types class=anchor>üîó</a></h4><p>If you are familiar with the <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>untyped version</a>, you&rsquo;ll remember that&rsquo;s how
we did it at that time. However, the key here is that little <code>&lt;T></code> up there. We have to use
a method to let the compiler infer the <code>T</code>.</p><p>Notice how that little <code>T</code> in the definition of <code>Behavior</code>
makes a huge difference: <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>an <em>untyped</em> actor system</a> would be defined as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Behavior</span> <span style=color:#00f>extends</span> Function&lt;Object, Effect&gt; {}
</span></span><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Effect</span> <span style=color:#00f>extends</span> Function&lt;Behavior, Behavior&gt; {}
</span></span><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Address</span> { Address tell(Object message); }
</span></span></code></pre></div><p>So the actor itself would be written:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Address actor = actorSystem.actorOf(self -&gt; msg -&gt; {
</span></span><span style=display:flex><span>    out.println(<span style=color:#a31515>&#34;self: &#34;</span> + self +<span style=color:#a31515>&#34;; got msg: &#39;&#34;</span> + msg + <span style=color:#a31515>&#34;&#39;; length: &#34;</span> + msg.length());
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> Actor.Die();
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This would not compile, because <code>msg</code> has now type <code>Object</code> and <code>length()</code> is
no longer a known method:</p><pre tabindex=0><code>  error: cannot find symbol
            out.println(&#34;self: &#34; + self +&#34;; got msg &#39;&#34; + msg + &#34;&#39;; length: &#34; + msg.length());
                                                                                  ^
  symbol:   method length()
  location: variable msg of type Object
</code></pre><p>unless you check its type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Behavior receiveThenDie = msg -&gt; {
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> (msg <span style=color:#00f>instanceof</span> String) {
</span></span><span style=display:flex><span>        var s = (String) msg;
</span></span><span style=display:flex><span>        out.println(<span style=color:#a31515>&#34;self: &#34;</span> + self +<span style=color:#a31515>&#34;; got msg: &#39;&#34;</span> + s + <span style=color:#a31515>&#34;&#39;; length: &#34;</span> + s.length());
</span></span><span style=display:flex><span>    } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>        <span style=color:green>// handle the non-String message
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> Actor.Die();
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>or, more concisely:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#00f>if</span> (msg <span style=color:#00f>instanceof</span> String s) {
</span></span><span style=display:flex><span>        out.println(<span style=color:#a31515>&#34;self: &#34;</span> + self +<span style=color:#a31515>&#34;; got msg: &#39;&#34;</span> + s + <span style=color:#a31515>&#34;&#39;; length: &#34;</span> + s.length());
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>The concise version uses Pattern Matching for <code>instanceof</code>, delivered in JDK 14 (<a href=https://openjdk.java.net/jeps/305 target=_blank rel=noopener>JEP-305</a>).
It allows you to check against a type, and get a typed variable out of it if the check passes, all in one line.</p><h3 id=example-2-ping-pong>Example 2: Ping Pong <a href=#example-2-ping-pong class=anchor>üîó</a></h3><blockquote><p>You can run the following example with:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>j! https://github.com/evacchi/min-java-actors/blob/main/src/main/java/io/github/evacchi/typed/examples/PingPong.java
</span></span></code></pre></div></blockquote><p>An actor routine usually accepts more than one type of messages. It is therefore
useful to match against all the accepted subtypes.</p><p>This is where <a href=https://openjdk.java.net/jeps/361 target=_blank rel=noopener><code>switch</code> expressions</a>,
<a href=https://openjdk.java.net/jeps/395 target=_blank rel=noopener>records</a> and <a href=https://openjdk.java.net/jeps/409 target=_blank rel=noopener>sealed types</a> are useful.</p><div style=float:right><img src=/assets/actor-3/pingpong.jpg alt="A drawing of two ping-pong rackets"></div><p>In a classic actor example, one actor sends a &ldquo;ping&rdquo; to another;
the second replies with a &ldquo;pong&rdquo;, and they go on back and forth.</p><p>In order to make this more interesting (and also not to loop indefinitely):</p><ul><li>one of the actors (the <code>ponger</code>) will receive <code>Ping</code> and reply with <code>Pong</code>;</li><li>it will also count 10 <code>Ping</code>s, then <code>Die</code>;</li><li>upon reaching 10 and before it <code>Die</code>s, the <code>pinger</code>
will also send a message (<code>DeadlyPong</code>) to the <code>ponger</code></li><li>the <code>pinger</code> receives <code>Ping</code> and replies with <code>Pong</code></li><li>when it receives a <code>DeadlyPong</code> it <code>Die</code>s.</li></ul><p>In the <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>untyped version</a> of this program, the messages do not need to be
defined in a hierarchy. But in the typed version, a tiny hierarchy of sealed records
will make the code shorter.</p><p>There is only one type of <code>Ping</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record Ping(Address&lt;Pong&gt; sender) {}
</span></span></code></pre></div><p>the <em>sender</em> of such messages is able to receive <code>Pong</code>s. Now, we said that there
are two types of <code>Pong</code>s:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record SimplePong(Address&lt;Ping&gt; sender) 
</span></span><span style=display:flex><span>record DeadlyPong(Address&lt;Ping&gt; sender) 
</span></span></code></pre></div><p>And they are in the same hierarchy, so let us define the interface <code>Pong</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>Pong</span> {}
</span></span><span style=display:flex><span>record SimplePong(Address&lt;Ping&gt; sender) <span style=color:#00f>implements</span> Pong {}
</span></span><span style=display:flex><span>record DeadlyPong(Address&lt;Ping&gt; sender) <span style=color:#00f>implements</span> Pong {}
</span></span></code></pre></div><p>Both messages are <em>sent</em> by the actor that is able to <em>receive</em> <code>Ping</code>s.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>void</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String... args) {
</span></span><span style=display:flex><span>    var actorSystem = <span style=color:#00f>new</span> TypedActor.System(Executors.newCachedThreadPool());
</span></span><span style=display:flex><span>    Address&lt;Ping&gt; ponger = actorSystem.actorOf(self -&gt; msg -&gt; pongerBehavior(self, msg, 0));
</span></span><span style=display:flex><span>    Address&lt;Pong&gt; pinger = actorSystem.actorOf(self -&gt; msg -&gt; pingerBehavior(self, msg));
</span></span><span style=display:flex><span>    ponger.tell(<span style=color:#00f>new</span> Ping(pinger));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>static</span> Effect&lt;Ping&gt; pongerBehavior(Address&lt;Ping&gt; self, Ping msg, <span style=color:#2b91af>int</span> counter) {
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> (counter &lt; 10) {
</span></span><span style=display:flex><span>        out.println(<span style=color:#a31515>&#34;ping! üëâ&#34;</span>);
</span></span><span style=display:flex><span>        msg.sender().tell(<span style=color:#00f>new</span> SimplePong(self));
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> Become(m -&gt; pongerBehavior(self, m, counter + 1));
</span></span><span style=display:flex><span>    } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>        out.println(<span style=color:#a31515>&#34;ping! üíÄ&#34;</span>);
</span></span><span style=display:flex><span>        msg.sender().tell(<span style=color:#00f>new</span> DeadlyPong(self));
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> Die();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>static</span> Effect&lt;Pong&gt; pingerBehavior(Address&lt;Pong&gt; self, Pong msg) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> SimplePong p -&gt; {
</span></span><span style=display:flex><span>            out.println(<span style=color:#a31515>&#34;pong! üëà&#34;</span>);
</span></span><span style=display:flex><span>            p.sender().tell(<span style=color:#00f>new</span> Ping(self));
</span></span><span style=display:flex><span>            yield Stay();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> DeadlyPong p -&gt; {
</span></span><span style=display:flex><span>            out.println(<span style=color:#a31515>&#34;pong! üòµ&#34;</span>);
</span></span><span style=display:flex><span>            p.sender().tell(<span style=color:#00f>new</span> Ping(self));
</span></span><span style=display:flex><span>            yield Die();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This prints the following:</p><pre tabindex=0><code>ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üëâ
pong! üëà
ping! üíÄ
pong! üòµ
Dropping msg [Ping[sender=io.github.evacchi.TypedActor$System$1@21198648]] due to severe case of death.
</code></pre><h4 id=use-of-types-1>Use of Types <a href=#use-of-types-1 class=anchor>üîó</a></h4><p>If you are familiar with the <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>untyped version</a>, you&rsquo;ll remember that the <code>pingerBehavior</code> needed
a <code>default</code> clause: that&rsquo;s because, as we learned previously, the signature for <code>Behavior</code> was
<code>Function&lt;Object,Effect></code>: we had to handle and <em>ignore</em> messages that were not <code>Pong</code>s!</p><p>Because the signature is now effectively <code>Function&lt;Pong, Effect&lt;Pong>></code>
the compiler <em>knows</em> that only messages from the <code>Pong</code> hierarchy may be received;
thus, we don&rsquo;t need to add a <code>default</code> clause!</p><p>Likewise <code>pongerBehavior</code> defined a <code>switch</code> expression too. In the typed version,
however, the <code>switch</code> is made entirely redundant:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>static</span> Effect&lt;Ping&gt; pongerBehavior(Address&lt;Ping&gt; self, Ping msg, <span style=color:#2b91af>int</span> counter) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> Ping p &amp;&amp; counter &lt; 10 -&gt; {
</span></span><span style=display:flex><span>            out.println(<span style=color:#a31515>&#34;ping! üëâ&#34;</span>);
</span></span><span style=display:flex><span>            p.sender().tell(<span style=color:#00f>new</span> SimplePong(self));
</span></span><span style=display:flex><span>            yield Become(m -&gt; pongerBehavior(self, m, counter + 1));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> Ping p -&gt; {
</span></span><span style=display:flex><span>            out.println(<span style=color:#a31515>&#34;ping! üíÄ&#34;</span>);
</span></span><span style=display:flex><span>            p.sender().tell(<span style=color:#00f>new</span> DeadlyPong(self));
</span></span><span style=display:flex><span>            yield Die();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>because the signature is <code>Function&lt;Ping, Effect&lt;Ping>></code> and we don&rsquo;t need a <code>default</code> clause,
both <code>case</code> clauses are matching against a <code>Ping</code>; thus, the entire switch
is effectively equivalent to a simple <code>if</code>/<code>else</code>!</p><h4 id=closures-vs-classes>Closures vs Classes <a href=#closures-vs-classes class=anchor>üîó</a></h4><p>Notice how the traditional way to increase a counter is to create a closure with the value:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>void</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String... args) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    var ponger = actorSystem.actorOf(self -&gt; msg -&gt; pongerBehavior(self, msg, 0));
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>static</span> Effect pongerBehavior(Address self, Ping msg, <span style=color:#2b91af>int</span> counter) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> <span style=color:#00f>switch</span> (msg) {
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> Ping p &amp;&amp; counter &lt; 10 -&gt; {
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            yield Become(m -&gt; pongerBehavior(self, m, counter + 1));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, a similar effect could be achieved with mutable state; this is perfectly acceptable,
because the state of an actor is guaranteed to execute in a thread-safe environment.
In this case we could have written:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>void</span> run() {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    var ponger = actorSystem.actorOf(StatefulPonger::<span style=color:#00f>new</span>);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>class</span> <span style=color:#2b91af>StatefulPonger</span> <span style=color:#00f>implements</span> Behavior&lt;Ping&gt; {
</span></span><span style=display:flex><span>    Address&lt;Ping&gt; self; <span style=color:#2b91af>int</span> counter = 0;
</span></span><span style=display:flex><span>    StatefulPonger(Address&lt;Ping&gt; self) { <span style=color:#00f>this</span>.self = self; }
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> Effect&lt;Ping&gt; apply(Ping msg) {
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> (counter &lt; 10) {
</span></span><span style=display:flex><span>            out.println(<span style=color:#a31515>&#34;ping! üëâ&#34;</span>);
</span></span><span style=display:flex><span>            msg.sender().tell(<span style=color:#00f>new</span> SimplePong(self));
</span></span><span style=display:flex><span>            <span style=color:#00f>this</span>.counter++;
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Stay();
</span></span><span style=display:flex><span>        } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>            out.println(<span style=color:#a31515>&#34;ping! üíÄ&#34;</span>);
</span></span><span style=display:flex><span>            msg.sender().tell(<span style=color:#00f>new</span> DeadlyPong(self));
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Die();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=example-3-a-vending-machine>Example 3: A Vending Machine <a href=#example-3-a-vending-machine class=anchor>üîó</a></h3><blockquote><p>You can run the following example with:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>j! https://github.com/evacchi/min-java-actors/blob/main/src/main/java/io/github/evacchi/typed/examples/VendingMachine.java
</span></span></code></pre></div></blockquote><div style=float:right><img src=/assets/actor-3/vending.jpg alt="A drawing of a vending machine"></div><p>In the previous example, we saw how we to use actors and <code>Become</code> to maintain mutable state (the counter).
In this example we will show how to use <code>Become</code> to change the behavior of an actor, realizing a *state machines.</p><p>A classic example of a state machine is the <em>vending machine</em>.</p><p>For instance, we may write a vending machine that requires you
to insert an amount of 100 before you can choose an item.</p><div><img src=/assets/actor-3/diag-vend.png alt="Diagram of the state machine"></div><p>We will define two actors, <code>vendingMachine</code> and <code>itemPicker</code>, to simulate
that, once the amount of 100 has been reached, and the customer has made their choice,
some subroutine will take care of the mechanical arm that selects the item
and dispenses it to them.</p><p>The messages:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>interface</span> <span style=color:#2b91af>VendMessage</span> {}
</span></span><span style=display:flex><span>record Coin(<span style=color:#2b91af>int</span> amount) <span style=color:#00f>implements</span> VendMessage {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> Coin {
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> (amount &lt; 1 &amp;&amp; amount &gt; 100)
</span></span><span style=display:flex><span>            <span style=color:#00f>throw</span> <span style=color:#00f>new</span> AssertionError(<span style=color:#a31515>&#34;1 &lt;= amount &lt; 100&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>record Choice(String product) <span style=color:#00f>implements</span> VendMessage {}
</span></span></code></pre></div><p>we use the record constructor to ensure that the invariant that <code>1 &lt;= amount &lt; 100</code> is respected.</p><p>There is also the message <code>Vended</code> that it is only for private communication between
the <code>itemPicker</code> and the <code>vendingMachine</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record Vended(String product) <span style=color:#00f>implements</span> VendMessage {}
</span></span></code></pre></div><p>it is meant for the <code>itemPicker</code> to notify when it is done releasing the item,
and the <code>vendingMachine</code> may return to its <code>initial</code> state.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>TypedActor.System sys = <span style=color:#00f>new</span> TypedActor.System(Executors.newCachedThreadPool());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Address&lt;VendMessage&gt; vendingMachine = sys.actorOf(self -&gt; initial(self));
</span></span><span style=display:flex><span>Address&lt;Choice&gt; itemPicker = sys.actorOf(self -&gt; msg -&gt; itemPicker(msg));
</span></span></code></pre></div><p>The behaviors may be defined as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Behavior&lt;VendMessage&gt; initial(Address&lt;VendMessage&gt; self) {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> message -&gt; {
</span></span><span style=display:flex><span>        <span style=color:#00f>if</span> (message <span style=color:#00f>instanceof</span> Coin c) {
</span></span><span style=display:flex><span>            out.printf(<span style=color:#a31515>&#34;Received first coin: %d\n&#34;</span>, c.amount());
</span></span><span style=display:flex><span>            <span style=color:#00f>return</span> Become(waitCoin(self, c.amount()));
</span></span><span style=display:flex><span>        } <span style=color:#00f>else</span> <span style=color:#00f>return</span> Stay(); <span style=color:green>// ignore message, stay in this state
</span></span></span><span style=display:flex><span><span style=color:green></span>    };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Behavior&lt;VendMessage&gt; waitCoin(Address&lt;VendMessage&gt; self, <span style=color:#2b91af>int</span> accumulator) {
</span></span><span style=display:flex><span>    out.printf(<span style=color:#a31515>&#34;Budget updated: %d\n&#34;</span>, accumulator);
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> m -&gt; <span style=color:#00f>switch</span> (m) {
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> Coin c &amp;&amp; accumulator + c.amount() &lt; 100 -&gt;
</span></span><span style=display:flex><span>                Become(waitCoin(self, accumulator + c.amount()));
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> Coin c -&gt;
</span></span><span style=display:flex><span>                Become(vend(self, accumulator + c.amount()));
</span></span><span style=display:flex><span>        <span style=color:#00f>default</span> -&gt; Stay();
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>Behavior&lt;VendMessage&gt; vend(Address&lt;VendMessage&gt; self, <span style=color:#2b91af>int</span> total) {
</span></span><span style=display:flex><span>    out.printf(<span style=color:#a31515>&#34;Pick an Item! (Budget: %d)\n&#34;</span>, total);
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> message -&gt; <span style=color:#00f>switch</span>(message) {
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> Choice c -&gt; {
</span></span><span style=display:flex><span>            itemPicker.tell(c);
</span></span><span style=display:flex><span>            releaseChange(total - 100);
</span></span><span style=display:flex><span>            yield Stay();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#00f>case</span> Vended v -&gt; Become(initial(self));
</span></span><span style=display:flex><span>        <span style=color:#00f>default</span> -&gt; Stay(); <span style=color:green>// ignore message, stay in this state
</span></span></span><span style=display:flex><span><span style=color:green></span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and the <code>itemPicker</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Effect&lt;Choice&gt; itemPicker(Choice message) {
</span></span><span style=display:flex><span>    vendProduct(message.product());
</span></span><span style=display:flex><span>    vendingMachine.tell(<span style=color:#00f>new</span> Vended(message.product()));
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> Stay();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>vendProduct</code> and <code>releaseChange</code> are just printing a message,
but we may imagine that they do something costly and complicated:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>void</span> vendProduct(String product) { out.printf(<span style=color:#a31515>&#34;VENDING: %s\n&#34;</span>, product); }
</span></span><span style=display:flex><span><span style=color:#2b91af>void</span> releaseChange(<span style=color:#2b91af>int</span> change) { out.printf(<span style=color:#a31515>&#34;CHANGE: %s\n&#34;</span>, %d); }
</span></span></code></pre></div><p>now, if we send a series of coins, and then our choice:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>vendingMachine.tell(<span style=color:#00f>new</span> Coin(50))
</span></span><span style=display:flex><span>              .tell(<span style=color:#00f>new</span> Coin(40))
</span></span><span style=display:flex><span>              .tell(<span style=color:#00f>new</span> Coin(30))
</span></span><span style=display:flex><span>              .tell(<span style=color:#00f>new</span> Choice(<span style=color:#a31515>&#34;Chocolate&#34;</span>));
</span></span></code></pre></div><p>We will read the following output:</p><pre tabindex=0><code>Received first coin: 50
Budget updated: 50
Budget updated: 90
Pick an Item! (Budget: 120)
VENDING: Chocolate
CHANGE: 20
</code></pre><h4 id=use-of-types-2>Use of Types <a href=#use-of-types-2 class=anchor>üîó</a></h4><p>Notice how we had to add a <code>default</code> clause in the <code>waitCoin</code> and <code>vend</code> states (the <code>initial</code> state had an <code>else</code> clause),
because, every behavior is of type <code>Behavior&lt;VendMessage></code>, which means we need to handle any message in the <code>VendMessage</code> hierarchy,
even when that does not make sense in that state. For instance, a <code>Coin</code> message does not make sense in the <code>vend</code> state.</p><p>However, the <code>itemPicker</code> has type <code>Address&lt;Choice></code> because that&rsquo;s the only type of message it will ever be able to receive.
This allows use to avoid <code>if</code>s or <code>switch</code>es!</p><h2 id=implementing-the-actor-system>Implementing The Actor System <a href=#implementing-the-actor-system class=anchor>üîó</a></h2><p>We are now ready to implement the actor system and execution environment. We define the <code>actorOf()</code> method on a <code>TypedActor.System</code> class.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>TypedActor</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>class</span> <span style=color:#2b91af>System</span> {
</span></span><span style=display:flex><span>        Executor executor;
</span></span><span style=display:flex><span>        <span style=color:#00f>public</span> System(Executor executor) { <span style=color:#00f>this</span>.executor = executor; }
</span></span><span style=display:flex><span>        <span style=color:#00f>public</span> Address actorOf(Function&lt;Address, Behavior&gt; initial) {
</span></span><span style=display:flex><span>           <span style=color:green>// ... references the executor ...
</span></span></span><span style=display:flex><span><span style=color:green></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, in order to keep the number of lines down, we can abuse the <code>record</code> construct so that we
don&rsquo;t have to write an explicit constructor:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record System(Executor executor) {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> &lt;T&gt; Address&lt;T&gt; actorOf(Function&lt;Address&lt;T&gt;, Behavior&lt;T&gt;&gt; initial) {
</span></span><span style=display:flex><span>        <span style=color:green>// ... references the executor ...
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We now need to define an anonymous class implementing both the <code>Address&lt;T></code> and the <code>Runnable</code> interface:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record System(Executor executor) {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> &lt;T&gt; Address&lt;T&gt; actorOf(Function&lt;Address&lt;T&gt;, Behavior&lt;T&gt;&gt; initial) {
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> <span style=color:#00f>new</span> Address&lt;T&gt;, Runnable {
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>however&mldr; that is not valid Java syntax!. What we can do instead, is leveraging another under-used feature of Java:
local classes; i.e. a class that is local to the <em>body</em> of a method:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>record System(Executor executor) {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> &lt;T&gt; Address&lt;T&gt; actorOf(Function&lt;Address&lt;T&gt;, Behavior&lt;T&gt;&gt; initial) {
</span></span><span style=display:flex><span>        <span style=color:#00f>abstract</span> <span style=color:#00f>class</span> <span style=color:#2b91af>AtomicRunnableAddress</span>&lt;T&gt; <span style=color:#00f>implements</span> Address&lt;T&gt;, Runnable
</span></span><span style=display:flex><span>            { AtomicInteger on = <span style=color:#00f>new</span> AtomicInteger(0); }
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> <span style=color:#00f>new</span> AtomicRunnableAddress&lt;&gt;() {
</span></span><span style=display:flex><span>            ...
</span></span></code></pre></div><p>which makes <code>AtomicRunnableAddress</code> private to that method (which is all we need). We will use the
<code>AtomicInteger</code> to turn on and off the actor; we now create our object:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>return</span> <span style=color:#00f>new</span> AtomicRunnableAddress() {
</span></span><span style=display:flex><span>    <span style=color:green>// the mailbox is just a concurrent queue
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>final</span> ConcurrentLinkedQueue&lt;T&gt; mbox = <span style=color:#00f>new</span> ConcurrentLinkedQueue&lt;&gt;();
</span></span><span style=display:flex><span>    <span style=color:green>// current behavior is a mutable field.  
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// the initial behavior applies the `initial` function to `this`, seeding `self` reference to the initial behavior
</span></span></span><span style=display:flex><span><span style=color:green></span>    Behavior behavior = initial.apply(<span style=color:#00f>this</span>);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Here is the reason why our actors are created with this strange curried function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>var actor = system.actorOf(self -&gt; msg -&gt; ...);
</span></span></code></pre></div><p>the signature for the initial behavior is really: <code>Function&lt;Address&lt;T>, Behavior&lt;T>></code> which &ldquo;expands&rdquo; to</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Function&lt;Address&lt;T&gt;, Function&lt;T, Effect&lt;T&gt;&gt;&gt;
</span></span></code></pre></div><p>or, to write it in a possibly more readable format:</p><pre tabindex=0><code>Address&lt;T&gt; -&gt; T -&gt; Effect&lt;T&gt;
// self -&gt; msg -&gt; ...
</code></pre><p>The reason why we write it this way is so that the <code>Function&lt;T, Effect&lt;T></code> (i.e. the <code>Behavior&lt;T></code>)
can reference <code>self</code>. As we saw in <a href=#example-2-ping-pong>Example 2: Ping Pong</a> this is often equivalent to writing a class
that takes an <code>Address&lt;T></code> in its constructor. And that is because <a href=http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html target=_blank rel=noopener>&ldquo;a closure is a poor man‚Äôs object; an object is a poor man‚Äôs closure‚Äù</a>.</p><p>When the actor starts we initialize the <code>Behavior&lt;T></code> to a reference to <code>this</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Behavior behavior = initial.apply(<span style=color:#00f>this</span>);
</span></span></code></pre></div><p>Let us now take a look at the <code>tell()</code> method; at its core we may write it as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> Address&lt;T&gt; tell(Object msg) {
</span></span><span style=display:flex><span>    <span style=color:green>// put message in the mailbox
</span></span></span><span style=display:flex><span><span style=color:green></span>    mb.offer(msg); 
</span></span><span style=display:flex><span>    async(); 
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> <span style=color:#00f>this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The async method verifies that the mbox contains an element and schedules the actor
for execution on the <code>Executor</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>void</span> async() {
</span></span><span style=display:flex><span>    <span style=color:green>// if the mbox is non-empty and the actor is active
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:#00f>if</span> (!mb.isEmpty() &amp;&amp; on.getAndSet(1) == 0)) {
</span></span><span style=display:flex><span>        <span style=color:green>// schedule to run on the Executor 
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:#00f>try</span> { executor.execute(<span style=color:#00f>this</span>); }
</span></span><span style=display:flex><span>        <span style=color:green>// in case of error deactivate the actor and rethrow the exception
</span></span></span><span style=display:flex><span><span style=color:green></span>        <span style=color:#00f>catch</span> (Throwable t) { on.set(0); <span style=color:#00f>throw</span> t; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order to be schedulable, the actor must be a <code>Runnable</code>, so here is the <code>run()</code> method:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> run() {
</span></span><span style=display:flex><span>        <span style=color:#00f>try</span> {
</span></span><span style=display:flex><span>          <span style=color:green>// if it is active 
</span></span></span><span style=display:flex><span><span style=color:green></span>          <span style=color:#00f>if</span> (on.get() == 1) 
</span></span><span style=display:flex><span>            behavior = 
</span></span><span style=display:flex><span>              behavior.apply(mbox.poll()) <span style=color:green>// apply the behavior to the top of the mailbox
</span></span></span><span style=display:flex><span><span style=color:green></span>                .apply(behavior); <span style=color:green>// as a result an Effect is returned: 
</span></span></span><span style=display:flex><span><span style=color:green></span>                                  <span style=color:green>// apply it to the current behavior
</span></span></span><span style=display:flex><span><span style=color:green></span>                                  <span style=color:green>// it returns the next behavior (which overwrites the old in the assignment) 
</span></span></span><span style=display:flex><span><span style=color:green></span>        } <span style=color:#00f>finally</span> { on.set(0); async(); } <span style=color:green>// deactivate and resume if necessary
</span></span></span><span style=display:flex><span><span style=color:green></span>    }
</span></span></code></pre></div><h3 id=use-of-types-3>Use of Types <a href=#use-of-types-3 class=anchor>üîó</a></h3><p>In the <a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>original version</a> we initialized the <code>self</code> address by <code>tell</code>ing the actor its own <code>Address</code>.
This is doable in this version too, and it&rsquo;s preferrable, because it allows the <code>initial</code> behavior to be run
asynchronously.</p><p>In this version, for simplicity, we are initializing the <code>Behavior&lt;T></code> immediately:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Behavior behavior = initial.apply(<span style=color:#00f>this</span>);
</span></span></code></pre></div><p>However, that also means that, if <code>initial</code> performs a costly operation, it will be executed at creation time; while,
in the original version]<a href=https://evacchi.github.io/java/records/jbang/2021/10/12/learn-you-an-actor-system-java-17-switch-expressions.html target=_blank rel=noopener>first-part</a>, it would be evaluated when the first message (the <code>Address</code>) would be initially received,
making it asynchronous.</p><p>However, in its simplest implementation, this requires an untyped mailbox (i.e. <code>ConcurrentLinkedQueue&lt;Object></code>),
which would then require nasty casts. Try developing your own version, limiting the amount of hacks!</p><h2 id=wrapping-it-up>Wrapping It Up <a href=#wrapping-it-up class=anchor>üîó</a></h2><p>I hope you liked this long blog post! Together we implemented a tiny typed actor system, and we saw how to realize a few smaller use cases.</p><p>If you have read this far, congratulations! You deserve some <a href=https://en.wikipedia.org/wiki/Panettone target=_blank rel=noopener>panettone</a> too!</p><p>If you would like to challenge yourself, try <a href=https://evacchi.github.io/java/records/jbang/2021/11/16/write-you-a-chat-java-17-actor.html target=_blank rel=noopener>implementing a tiny chat system by following along the <em>untyped</em> version</a>!</p></div><div class=tags><a href=/tags/java>Java</a>
<a href=/tags/records>Records</a>
<a href=/tags/jbang>JBang</a></div></section></main><footer id=footer><div class=social><a class="symbol _merge" href rel=me target=_blank></a><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2023
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>