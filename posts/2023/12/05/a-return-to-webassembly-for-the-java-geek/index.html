<!doctype html><html lang=en-us><head><title>A Return to WebAssembly for the Java Geek | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="
  


Update (Jun 20, 2025). This post was originally published at JVM Advent.

Welcome back, my dear¬†Java Geek!
Last year we compared WebAssembly and discussed in what ways it differs from the JVM. A lot of things have happened in the meantime. If you want to dive deeper into that kind of detail, I warmly suggest reading this beautiful blog series by Chris Dickinson.¬†
For this Java Advent, I wanted to get back to the topic from a different angle. Last year we saw that, because the JVM and WebAssembly are only shallowly similar, there is friction when it comes to putting the two together.¬†"><meta name=generator content="Hugo 0.148.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>A Return to WebAssembly for the Java Geek</h1><div class=tip><time datetime="2023-12-05 00:00:00 +0000 UTC">Dec 5, 2023</time>
<span class=split>¬∑
</span><span>4117 words
</span><span class=split>¬∑
</span><span>20 minute read</span></div><div class=content><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/java-geek-wasm-2.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/java-geek-wasm-2.png?resize=600%2C369&amp;ssl=1" alt></p></a></p><div style=padding:1em;background:#eee><b>Update (Jun 20, 2025)</b>. This post was originally published at <a href=https://www.javaadvent.com/2023/12/a-return-to-webassembly-for-the-java-geek.html>JVM Advent</a>.</div><p>Welcome back, my dear¬†<strong>Java Geek!</strong></p><p><a href=https://www.javaadvent.com/2022/12/webassembly-for-the-java-geek.html target=_blank rel=noopener>Last year we compared WebAssembly and discussed in what ways it differs from the JVM</a>. A lot of things have happened in the meantime. If you want to dive deeper into that kind of detail, I warmly suggest reading <a href=https://www.neversaw.us/2023/05/10/understanding-wasm/part1/virtualization/ target=_blank rel=noopener>this beautiful blog series by Chris Dickinson</a>.¬†</p><p>For this Java Advent, I wanted to get back to the topic <strong>from a different angle</strong>. Last year we saw that, because the JVM and WebAssembly are only shallowly similar, there is friction when it comes to putting the two together.¬†</p><p>But this is not just a matter of taste; a Wasm VM is generally <strong>simpler, smaller, and easier to embed than a full, modern JVM</strong>. This on the one hand, might <strong>allow JVM languages to run in spaces that they normally would not fit</strong> (for instance, in a plug-in system for a native executable); and, on the other hand, it might <strong>allow the JVM to host languages that normally would not be supported</strong> (by implementing Wasm support <em>on top</em> of a JVM).</p><p><a href=https://www.javaadvent.com/2022/12/webassembly-for-the-java-geek.html#java-support-on-webassembly target=_blank rel=noopener>Last year we listed a few projects</a> that were starting to approach the space of compiling JVM bytecode to Wasm bytecode, and a few others that were addressing hosting a Wasm binary on top of a JVM.</p><p>In this post, we will see <strong>what things have changed</strong> since last time, and we will <strong>revisit</strong> some of those projects. Has the ecosystem matured? And <strong>in what ways should you, the Java Geek, care?</strong></p><h2 id=whats-with-all-the-fuss><strong>What‚Äôs With All The Fuss?</strong> <a href=#whats-with-all-the-fuss class=anchor>üîó</a></h2><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/jdk-jre-wasm.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/jdk-jre-wasm.png?resize=600%2C439&amp;ssl=1" alt></p></a></p><p>Original: <a href=https://www.oracle.com/java/technologies/platform-glance.html target=_blank rel=noopener>Jave SE Platform at a Glance</a></p><p>In essence, you can think of a Wasm VM as a <strong>JDK without the class library,</strong> with no built-in way to interact with its surroundings, except <strong>importing and exporting functions.</strong> If some function you import is able to perform <strong>I/O,</strong> then <strong>great!</strong> you can actually do something useful, otherwise, you have got yourself a fancy calculator.</p><p>Then, if it is so <em>useless,</em> why are we interested in it <em>at all?</em> The Wasm VM is <em>small</em>, so it is relatively easy to implement, and thus, it is also easy to port to many platforms. An unmodified Wasm VM is able to run <em>in a browser</em> as well as <em>outside a browser</em>. And, if you remember, <strong><em>this</em> is the thing I am personally more excited about</strong>.</p><p>Now, in the last year, you might have heard that Wasm VMs are being proposed as an alternative to <strong>containers</strong> because you can produce a self-contained binary that will run in a <em>sandboxed</em> environment: this is an ambitious goal, and people are making some progress there.¬†</p><p>However, there is also another, much <em>less ambitious</em> use case, where I feel a greater potential lies: because Wasm VMs are relatively small and easy to <em>embed</em>, they are great for implementing <strong>sandboxed plug-in and extension systems.</strong></p><p>When a Wasm VM is embedded to provide a plug-in system, the Wasm VM is extended by providing a collection of functions that the Wasm binaries can invoke. A proposed standard called <a href=https://wasi.dev/ target=_blank rel=noopener><strong>WASI</strong></a> provides a set of functions that, if you squint enough, could be considered some sort of POSIX compatibility layer, or, more generally, a set of OS-like primitives to access things like the console, a file system and, in some cases, even the network. A subset of these APIs is often expected to be available, usually to be able to provide simple input and output capabilities (such as logging). Each language usually rebuilds its own standard library on top of these APIs, with the aim of making a port easier for the end-users.</p><p>Several projects have adopted Wasm as an extension language; for instance, the <a href=https://www.envoyproxy.io/ target=_blank rel=noopener><strong>Envoy proxy</strong></a> allows writing middleware through a Wasm interface; <a href=https://redpanda.com/ target=_blank rel=noopener><strong>Redpanda</strong></a> is a streaming platform implementing the Kafka protocol, that allows writing data transforms in-core using Wasm. The list could go on and it is always growing.</p><p>The <a href=https://extism.org/ target=_blank rel=noopener><strong>Extism</strong></a> project by <a href=https://dylibso.com/ target=_blank rel=noopener><strong>Dylibso</strong></a> is proposing a unified API to provide cross-platform extensions and plug-ins, regardless of the language: they provide a battery-included system to experiment with Wasm plug-ins. This includes the JVM, where the underlying VM is currently <a href=https://wasmtime.dev/ target=_blank rel=noopener><strong>Wasmtime</strong></a>, and Go, where the VM is <a href=https://wazero.io/ target=_blank rel=noopener><strong>wazero</strong></a>.</p><p>The JVM has always provided ways to load code dynamically. I think we could even dare to say that <strong>class loading is in fact a <em>defining feature</em> of a JVM,</strong> so, it is pretty easy to write a plug-in system that loads class files or jar files. However, as with any language VM, the JVM has always been limited to the languages that in fact support it.</p><p>As the Wasm landscape expands, more and more languages are deciding to target it. For instance, there is support for C, C++, Rust, Go, Python, Ruby just to name a few. Even the <a href="https://www.youtube.com/watch?v=jkve_v1Xxak" target=_blank rel=noopener>.NET ecosystem has added support to Wasm in its toolchain</a>. <a href=https://www.fermyon.com/wasm-languages/webassembly-language-support target=_blank rel=noopener>Fermyon keeps a list of languages with their degree of support</a>.¬†</p><p>So for a <strong>Java Geek</strong> there are two opportunities here:¬†</p><ol><li><strong>JVM languages can support Wasm as a compilation target</strong> so that they can be used to write Wasm binaries that will run outside a traditional JVM and inside a Wasm VM. This could be used to write software for the browser, as well as plug-ins for other software.</li><li><strong>JVM may run Wasm binaries to support languages</strong> that traditionally would not be available on a plain JVM.</li></ol><h2 id=what-has-changed-since-last-time><strong>What Has Changed Since Last Time?</strong> <a href=#what-has-changed-since-last-time class=anchor>üîó</a></h2><p>Quite a lot! First of all, let me talk just a little about my favorite topic in the whole world, i.e. <em><strong>myself</strong></em>. I am no longer at Red Hat, and I have joined <a href=https://tetrate.io/ target=_blank rel=noopener>Tetrate</a> to join the team of, guess what, <a href=https://wazero.io/ target=_blank rel=noopener>an open-source WebAssembly <strong>runtime</strong> that I mentioned earlier <strong>called wazero.</strong></a> In the process, I also had to switch to a different language in my day-to-day; that is, Go, since that‚Äôs wazero‚Äôs language.</p><p><em><strong>Burn in hell you, traitor! ‚Äî</strong></em> I hear you say. But, in my defense: first, I still hold the JVM dear to <a href="https://www.youtube.com/watch?v=byQIPdHMpjc" target=_blank rel=noopener>my achy-breaky heart</a>, and, second, I think getting exposed to a different ecosystem helps you to see the bigger picture. And in fact, there are a few things that all these ecosystems (JVM, Go, Wasm) could learn from each other.</p><p>But enough about me! While I was busy learning Go, the JVM space has also started to get more involved in Wasm. And, at the same time, Wasm <strong>has gained a few features that, in the future, might make it easier for JVM languages to target it</strong>. For instance, in the previous post, we mentioned the lack of support for <strong>threading, exception handling, and garbage collection</strong>. All these features <strong>made progress</strong>, and they are slowly starting to get experimental support in some languages.</p><h2 id=caffeinated-gophers><strong>Caffeinated Gophers</strong> <a href=#caffeinated-gophers class=anchor>üîó</a></h2><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/gojava.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/gojava.png?resize=600%2C395&amp;ssl=1" alt="Duke, the Java Mascot is next to a Gopher (the Go mascot) holding a cup of coffee which resembles the Java logo."></p></a></p><p>As surprising as it may sound, while working on <strong>wazero</strong> I have learned that <strong>there are in fact similarities between the Go and the Java runtime</strong> (at least in principle); for instance:</p><ul><li><strong>compiling Go and Java to a Wasm binary</strong> requires some <em><strong>massaging</strong></em>. But such a <em>massage</em> is not that different from building a native executable. We will see in what ways in the next section</li><li><strong>evaluating a Wasm binary on the JVM and the Go runtime can be</strong> achieved by implementing a Wasm runtime on top of them or depending on an existing runtime. Both the JVM and Go have similar caveats (we will see them later) when it comes to depending on a native library, so writing a Wasm VM specific to that language might be more convenient.</li></ul><p>Let us see both aspects in detail.</p><h2 id=compiling-jvm-software-into-wasm><strong>Compiling JVM Software into Wasm</strong> <a href=#compiling-jvm-software-into-wasm class=anchor>üîó</a></h2><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/12/java-on-wasm.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/12/java-on-wasm.png?resize=600%2C450&amp;ssl=1" alt></p></a>We already mentioned targeting the Wasm bytecode in its current version of the spec (2.0) is <strong>more similar to targeting a native platform</strong> than a high-level language VM like the JVM.¬†</p><p>It is not by chance that <strong>many of the languages that support Wasm as a compilation target are based on the</strong> <a href=https://llvm.org/ target=_blank rel=noopener><strong>LLVM toolchain</strong></a><strong>.</strong> Because the LLVM toolchain <strong>supports Wasm among its native targets, it is <em>relatively easy</em> to add support for it</strong>.</p><p>Thus, it is no surprise that C and C++ support Wasm via Clang/LLVM, that Rust supports Wasm, Zig supports Wasm, and that the <a href=https://tinygo.org/ target=_blank rel=noopener><strong>TinyGo</strong></a> flavor of the Go language gained support for Wasm relatively early on. Guess what common trait they all share? That‚Äôs right, they all leverage LLVM.¬†</p><h3 id=wasm-as-a-native-target><strong>Wasm as a Native Target</strong> <a href=#wasm-as-a-native-target class=anchor>üîó</a></h3><p>But in what ways does Wasm behave as a native target, rather than, more intuitively, as JavaScript?¬†</p><p>Well, for instance, Wasm 2.0 does not provide primitives to manipulate <strong>structured data</strong>. It only deals with <strong>numbers</strong> ‚Äì integers and floats (and 128-bit vectors, but that does not make much difference).¬†</p><p>So, what if you want to deal with <strong>fancy</strong> data structures such as ‚Äî <em>gasp!</em> ‚Äî <strong>arrays</strong>? Well, fear not: Wasm 2.0 provides to <em>each module</em> its own, <em>isolated</em> <strong>linear memory space;</strong> which is a cool way to call <strong>an array of unsigned bytes</strong> that your program will treat as if it were real operating system memory.¬† Thus, if you need to allocate an <strong>array</strong>, then you just reserve a <em>slice</em> of that larger array.¬†</p><p>And what if you need a <em><strong>fancier</strong></em> structure such as <em><strong>strings</strong></em>? Well, you just reserve a <em>slice</em> of that array for the characters, and then maybe some extra meta-data for the size (depending on how your language represents strings).¬†</p><p>And what if you need an even <em><strong>fancier</strong></em> data structure such as <strong>Point(int x, int y)</strong>? Well, <strong>you get the idea</strong>.</p><p>Now, as long as you only have to <em><strong>allocate</strong></em>, things will work out pretty well. You can just keep track of the last allocation you did; that is, <em>effectively</em> keeping an <em>index</em> into the array. Which is another way to say, err, <strong>a pointer</strong>. And every time you allocate more, you can just update that <em>pointer</em> I mean <em>index</em>.¬†</p><p>However, at some point, <strong>that memory space will finish</strong>. And obviously, we don‚Äôt want that to happen, so you also want to keep track of things you no longer need, and <em><strong>free</strong></em> that space. And you want to keep things neat and avoid fragmentation. And there you go: you got yourself a <strong><em>memory manager</em>.</strong> Or, as some runtimes call it, a <strong>garbage collector.</strong></p><p><strong>Note.</strong> It is worth mentioning that for all intents and purposes, the <em>linear memory space</em> can be thought about as real operating system memory: however, there is one big caveat that makes it quite different; such a memory space is <em>not shared across Wasm programs,</em> even within the same VM, and even across modules. Each module gets its own, <strong>isolated</strong> memory space, and the only way to pass structured data across modules is essentially to copy it over. This is a big difference that is often highlighted as one of the benefits of Wasm binaries over traditional, native binaries.</p><p>All of this might evolve in the future because <a href=https://v8.dev/blog/wasm-gc-porting target=_blank rel=noopener>the WasmGC spec has moved further</a> and the multiple memories and threading proposals have moved too. The WasmGC spec deals exactly with allocating and deallocating structured data and delegating memory management to the underlying runtime. The flat memory space will still be available, but a compiler may pick the allocation strategy that suits the language best. The ‚Äúmultiple memories‚Äù proposal allows modules to define different, isolated memory spaces, while the threading proposal includes a way to declare a memory space as <em>shared.</em> However, at the time of writing the WasmGC proposal is only supported in browsers, and the other two are not widely available yet; until all these proposals gain wider adoption, a bare-bone Wasm 2.0 runtime only provides a flat, linear memory space as described above.</p><p>So, from the JVM perspective, there are <strong>two strategies</strong> to target Wasm:¬†</p><ul><li>compiling a <strong>JVM</strong> into an executable and then letting it load and evaluate class files</li><li>compiling a JVM application into a self-contained executable, from <strong>bytecode</strong> similar to a <strong>native image</strong></li><li>compiling a JVM application into a self-contained executable, from <strong>source code</strong> with a <strong>language-specific</strong> compiler.</li></ul><h3 id=compiling-a-jvm-into-wasm><strong>Compiling a JVM into Wasm</strong> <a href=#compiling-a-jvm-into-wasm class=anchor>üîó</a></h3><p>In the first case, we are effectively <strong>porting and compiling <em>a JVM</em> into Wasm</strong>, and then we are <em>evaluating JVM bytecode inside such a JVM that runs inside a Wasm VM.</em> If this gives you a headache, that‚Äôs alright. It is a little mind-bending. However, this is a perfectly valid approach, and it is also the approach dynamic languages such as Ruby and Python are adopting. But <em>is this the <em>best</em> approach?</em> As usual, <em>it depends on your use case and your performance requirements.</em> This approach potentially allows for the largest degree of compatibility, with fewer limitations.¬†</p><p>There is at least one project that is doing exactly <em>that</em>: the fine people at <a href=https://leaningtech.com/ target=_blank rel=noopener>Leaning Technologies</a> are developing <a href=https://cheerpj.com/ target=_blank rel=noopener>a JVM that runs in-browser (CheerpJ)</a> that is especially well-suited to modernize legacy software that would require, say, an applet runtime (they also provide a <a href="https://chromewebstore.google.com/detail/cheerpj-applet-runner/bbmolahhldcbngedljfadjlognfaaein?pli=1" target=_blank rel=noopener>browser extension that does exactly that</a>).¬†</p><p>However, a modern <strong>JVM tends to be large</strong>; as such, a Wasm binary of this kind might not be well suited to write <em>tiny executables such as plug-ins and extensions.</em>¬†</p><h3 id=compiling-java-bytecode-into-wasm><strong>Compiling Java Bytecode into Wasm</strong> <a href=#compiling-java-bytecode-into-wasm class=anchor>üîó</a></h3><p>This is the most general approach. If you are able to compile Wasm into bytecode, then potentially all Java software can be compiled into Wasm. This is similar to the approach that GraalVM Native Image takes to produce a native executable. In fact, Native Image would be the most natural candidate, to the point that this was mentioned as a possibility <a href=https://medium.com/graalvm/graalvm-native-image-meets-risc-v-899be38eddd9 target=_blank rel=noopener>in the post about RISC-V support which, guess what, leveraged LLVM</a>.</p><p>Because it is the most general approach, just like the Native Image Builder: it should deal with all the worst cases, and cannot make any assumptions about the program that will be run.</p><ul><li>In order to preserve the semantics of your program, you will have to emulate most of the features of the JVM, including, in some form, reflection, and class loading (even if with some limitations, such as the infamous ‚Äúclosed world assumption‚Äù).</li><li><strong>you want to reduce the program surface as much as possible,</strong> just like GraalVM‚Äôs Native Image Builder does when it produces a native executable: this however may impose limitations on reflection and class loading (the infamous ‚Äúclosed world assumption‚Äù).</li><li>Then, just like the Native Image Builder, you will still have to <strong>ship a full-blown garbage collector.</strong></li><li>Finally, to keep your boot time low, you might want to move some computation at build time.</li></ul><p>At the time of writing, there are at least <strong>two projects</strong> that are able to compile class files into Wasm <a href=https://github.com/i-net-software/JWebAssembly target=_blank rel=noopener><strong>JWebAssembly</strong></a> and <a href=https://teavm.org/ target=_blank rel=noopener><strong>TeaVM</strong></a><strong>.</strong> However, if you want to produce a self-contained Wasm executable that runs <strong>outside the browser, TeaVM</strong> is the most promising project so far.¬†</p><p>If you are lazy like me, I found that in order to get started with <strong>TeaVM,</strong> the most effective way is to <a href=https://github.com/konsoletyper/teavm target=_blank rel=noopener><strong>clone the repository</strong></a>, build with ./gradlew publishToMavenLocal, and then try out the example under samples/pi which is already configured for <strong>WASI</strong> support. The program computes the first <strong>N</strong> digits of œÄ a given <strong>N,</strong>¬† supplied via command line argument, then prints them with the elapsed time., and, if the build was <strong>successful</strong> you will find a pre-built Wasm binary under samples/pi/build/libs/wasi/pi.wasm</p><p>You can test it out with your favorite Wasm runtime, that is, obviously <strong>wazero.</strong> Just kidding, obviously, the choice is relevant, the output will be always the same; that‚Äôs the point after all!</p><pre tabindex=0><code>‚ùØ wazero run build/libs/wasi/pi.wasm 3
314 ¬† ¬† ¬†  :3
Time in millis: 0

‚ùØ wazero run build/libs/wasi/pi.wasm 5
31415 ¬† ¬†  :5
Time in millis: 0


‚ùØ wazero run build/libs/wasi/pi.wasm 10
3141592653 :10
Time in millis: 0

‚ùØ wazero run build/libs/wasi/pi.wasm 100
3141592653 :10
5897932384 :20
6264338327 :30
9502884197 :40
1693993751 :50
0582097494 :60
4592307816 :70
4062862089 :80
9862803482 :90
5342117067 :100
Time in millis: 7
</code></pre><h4 id=appendix-does-it-really-boot-fast><em>Appendix: Does It Really Boot Fast?</em> <a href=#appendix-does-it-really-boot-fast class=anchor>üîó</a></h4><p>It is often claimed that <strong>Wasm VMs are super-fast to boot</strong>. This is not false, but the reason is <strong>kind of underwhelming</strong>; there is no secret sauce: <strong>they start fast because they don‚Äôt need to do much anyway</strong>. In a typical Java program, a <a href="https://www.youtube.com/watch?v=pGHN8a3VAeU" target=_blank rel=noopener>JVM might need to load and initialize thousands of classes before it reaches a steady state</a>. All these initializers add up, and that is the reason why the Native Image Builder makes the pragmatic choice of moving some of that computation at build time, taking a snapshot of that heap, and then restoring it at boot time to get reasonable startup performance.¬†</p><p>Even Wasm modules may define a startup function to perform initialization. Guess what you might need to do in Wasm too if you want to keep those precious milliseconds down?¬†</p><p>It is interesting how the Wasm community has already produced <a href=https://github.com/bytecodealliance/wizer target=_blank rel=noopener>a tool to perform build-time initialization called <strong>wizer</strong></a>. Instead of producing a native binary, <strong>wizer</strong> produces a new Wasm binary, that is, what <a href=https://openjdk.org/projects/leyden/notes/03-toward-condensers target=_blank rel=noopener>Project Leyden would call a <strong>condenser</strong></a><strong>.</strong></p><h3 id=compiling-source-code-into-wasm><strong>Compiling Source Code into Wasm</strong> <a href=#compiling-source-code-into-wasm class=anchor>üîó</a></h3><p>Some JVM languages have supported compiling to a different target for a long time. However, in my research, I have found that <em>in general</em> the primary target for these compilers is execution <em>in the browser</em>. I will still give a brief overview of these alternative compilers for completeness.</p><p>The <strong>Scala</strong> compiler gained soon support for targeting JavaScript with <a href=https://www.scala-js.org/ target=_blank rel=noopener>Scala,js</a>. And, later, the <a href=https://scala-native.org/en/stable/ target=_blank rel=noopener>Scala Native project</a> started to explore the space of native compilation through an <strong>LLVM-based backend</strong>. More recently this Native backend has experimented with <a href="https://www.youtube.com/watch?v=mrqKw1PeshI" target=_blank rel=noopener>adding support to target Wasm</a>. However, this experiment needs support for features such as automated garbage collection and exception handling, that are emulated via JavaScript shims (this is generated automatically by the <strong>Emscripten</strong> toolchain, that you can think of as an <em>extension to LLVM</em>).</p><p>The <strong>Kotlin</strong> compiler was born with multi-platform in mind: Kotlin supported a JavaScript output for front-end development since its very first versions. It is only natural to support Wasm with the same goal. The Kotlin compiler for Wasm (Kotlin/Wasm) originally was born as an extension to the Kotlin/Native backend (based on LLVM). The most recent version, however, targets Wasm <em>directly</em>, and, in particular, it leverages the WasmGC proposal, which, at the time of writing, has been enabled in Chrome <em>and</em> Firefox. <a href=https://webassembly.org/roadmap/ target=_blank rel=noopener>Node, being based on V8 like Chrome, it supports it behind a flag</a>, and <a href=https://twitter.com/bashorov/status/1728199701588304069 target=_blank rel=noopener>Deno has been reported to run Kotlin fine</a>.</p><p>The <strong>GWT compiler</strong> for Java evolved into the <a href=https://github.com/google/j2cl target=_blank rel=noopener><strong>J2CL</strong></a> <strong>compiler</strong> in recent years. Originally targeting Java source-to-JavaScript compilation, it has also become <a href=https://github.com/google/j2cl/blob/master/docs/getting-started-j2wasm.md target=_blank rel=noopener>a test bed for experimenting with the WasmGC spec</a>.</p><h2 id=evaluating-wasm-binaries-on-the-jvm><strong>Evaluating Wasm Binaries on the JVM</strong> <a href=#evaluating-wasm-binaries-on-the-jvm class=anchor>üîó</a></h2><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/12/wasm-on-java.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/12/wasm-on-java.png?resize=600%2C450&amp;ssl=1" alt></p></a></p><p>In the introduction, we briefly mentioned that Wasm might bring support to languages that otherwise would not be available on the JVM. But we have JRuby, we had Jython, and with Truffle we have other, state-of-the-art dynamic language implementations, including JavaScript: while these get best-in-class performance only when run on a GraalVM JDK, they are still portable and work on any JVM. So the question might be: why would you need Wasm, if you already have GraalVM?</p><p>For different reasons, <a href=https://www.javaadvent.com/2022/12/webassembly-for-the-java-geek.html#graalvm-one-vm-to-rule-them-all target=_blank rel=noopener>we briefly discussed GraalVM in the previous post</a>. While Truffle/GraalVM supports a number of languages with great performance it still requires implementing such language-specific support from scratch. There is one Python implementation, one Ruby implementation, one R implementation, one JavaScript implementation‚Ä¶ you get the idea.</p><p>But, as we have seen earlier, Wasm was designed as a <strong>compilation target</strong>, and a lot of compiler toolchains already support it. This means that with relatively few changes, it is often possible to bring Wasm support to <strong>first-party language implementations</strong>. For instance, the Python and the Ruby runtimes that run on Wasm are the traditional <a href=https://en.wikipedia.org/wiki/CPython target=_blank rel=noopener>CPython</a> and <a href=https://en.wikipedia.org/wiki/Ruby_MRI target=_blank rel=noopener>CRuby (Ruby MRI)</a> runtimes, with obvious compatibility benefits.</p><h3 id=picking-a-wasm-runtime-for-the-jvm><strong>Picking a Wasm Runtime for the JVM</strong> <a href=#picking-a-wasm-runtime-for-the-jvm class=anchor>üîó</a></h3><p>Assuming that we have now bought into Wasm as a way to host end-user extensions in our Java environment, the most complete and battle-tested implementations of a Wasm VM are written in languages such as C/C++ and Rust. These are native libraries that will require some form of <strong>integration</strong>.</p><p>Now, while Java is improving the developer experience <strong>over JNI</strong> with <a href=https://openjdk.org/jeps/454 target=_blank rel=noopener>**Project Panama (**finally being released with JDK 22)</a> linking against a native library still imposes a <strong>number of restrictions</strong>.</p><p><a href="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/gojni.png?ssl=1" target=_blank rel=noopener><p class=markdown-image><img src="https://i0.wp.com/www.javaadvent.com/content/uploads/2023/11/gojni.png?resize=600%2C465&amp;ssl=1" alt></p></a></p><p>Interestingly enough, <strong>this is another place where the Go runtime oddly behaves like a Java Runtime.</strong> While the developer experience for Go developers is probably better than JNI, linking against a non-Go, native binary requires a Go developer to reach for the <strong>Cgo</strong> system. This is completely transparent from a development perspective, as it is just a matter of importing the right library. But as you opt-in to CGo, under the hoods, the compilation pipeline changes dramatically: it requires your system to provide a C compiler, and cross-platform build capabilities that usually work out-of-the-box, will require much more work.</p><p>The restrictions imposed by both JNI/Panama and Cgo are essentially the same:¬†</p><ul><li><strong>There are portability concerns</strong>, because you will have to compile the native library for all the platforms you want to support, and this obviously hinders the portability of your code</li><li><strong>There is overhead crossing the boundary</strong> to and from the managed environment to ‚Äúnative code‚Äù</li><li><strong>There are security and safety implications</strong> because the native library has access to the entire space of the process memory</li><li><strong>There are runtime concerns</strong> because every native call hogs an operating system thread: this will not play nicely with <strong>virtual threads</strong> (i.e., in the case of Go, <strong>goroutines</strong>).</li></ul><p>This means that, while it is perfectly possible for a native Wasm runtime to be imported into a Java or Go application, this comes with costs that have to be carefully evaluated, and that may ultimately lead to avoiding adopting it altogether.</p><p>This is the reason for the <strong>wazero</strong> project: it is a <strong>zero-dependency WebAssembly runtime for Go,</strong> where zero means literally <em>no dependencies,</em> but <em>in particular</em>, zero <strong>Cgo</strong> dependencies. So, depending on it and using it, for a Go developer is a no-brainer: there is essentially no overhead, and you keep all the benefits of your Go runtime. So, what about Java? Is there anything similar?¬†</p><p>Indeed, there are. The <strong>GraalVM</strong> project already proved that it is possible to run a lower-level compilation target <em>on top of Truffle</em>: this is called Sulong, and it is an implementation of a runtime for the <strong>LLVM IR</strong>, that is, the <strong><em>I</em>ntermediate <em>R</em>epresentation</strong> that a compiler based on LLVM uses internally, that then, in the final stages of the compilation pipeline, gets translated into the target architecture.</p><p>So, there is an experimental <a href=https://www.graalvm.org/latest/reference-manual/wasm/ target=_blank rel=noopener>GraalVM Wasm language implementation for Truffle</a>. Obviously, besides this being experimental, it is also worth noticing that, as it is for all the Truffle-based language implementations, you will need a GraalVM JDK to get the best performance out of it.</p><p>I also wanted to mention another project that is being developed by some friends, and I‚Äôm keeping myself involved in it from afar, called <a href=https://github.com/dylibso/chicory target=_blank rel=noopener><strong>Chicory</strong></a>. <strong>Chicory</strong> is a Wasm VM implementation that aims to support the entire spec. It currently does not aim for best-in-class performance, but focuses on correctness, by implementing a <strong>Wasm interpreter</strong> <a href=https://github.com/WebAssembly/testsuite target=_blank rel=noopener>validated against the Wasm test suite</a>. Nonetheless, the people involved are already considering adding support for a bytecode translation layer, which potentially could provide reasonable performance. Chicory was initiated by one of the founders at <strong>Extism</strong> (the Wasm plug-in system), so one of the goals will be to rebase the Extism SDK for Java on top of it, once it is mature enough.</p><h2 id=conclusions><strong>Conclusions</strong> <a href=#conclusions class=anchor>üîó</a></h2><p>I could go on and on about Wasm and this article has reached a considerable length already. The space is always evolving and for a newcomer, it might be intimidating to get started. I mentioned all of the ways Wasm could be useful from the perspective of the Java Geek, but I also <strong>overlooked some important limitations</strong> that will need to be addressed before Wasm can expect to gain a wider adoption, beyond early adopters and enthusiasts.¬†</p><p>For instance, to this day, there are <strong>few options for debugging</strong> (especially dire is the landscape when it comes to stepwise debugging, where tooling is still dramatically limited ‚Äî <a href="https://www.youtube.com/watch?v=JqvwzkRatOg" target=_blank rel=noopener>see for instance this recent talk by Ashwin Kumar Uppala and Shivay Lamba</a>).</p><p>The work to stabilize the <strong>WASI</strong> set of APIs is also ongoing.¬†</p><p>Finally, there is a lot of buzz around the so-called <a href=https://component-model.bytecodealliance.org/ target=_blank rel=noopener><strong>Component Model</strong></a>. The component model aims to provide a polyglot system to define APIs and compose libraries together, while retaining the safe, isolated architecture of the Wasm VM (remember: memory is not shared by default). These are however early days and the work here is still in flux.</p><p>I still hope that this new article has caught your attention; in the meantime, enjoy your <em><strong>panettone</strong></em> and have a sip of <em><strong>spumante</strong></em>, and see you at some conference in <strong>2024</strong>!</p></div><div class=tags><a href=/tags/wasm>wasm</a>
<a href=/tags/java>java</a></div></section></main><footer id=footer><div class=social><a class="symbol bluesky" href=https://bsky.app/profile/evacchi.dev rel=me target=_blank></a><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2025
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg>
</span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>