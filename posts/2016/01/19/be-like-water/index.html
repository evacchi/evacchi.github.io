<!doctype html><html lang=en-us><head><title>Be Like Water | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Shapeless is a Scala library for generic programming. The name ‚ÄúShapeless‚Äù comes from a famous Bruce Lee quote:
Don&rsquo;t get set into one form, adapt it and build your own, and let it grow, be like water. Empty your mind, be formless, shapeless ‚Äî like water. Now you put water in a cup, it becomes the cup; You put water into a bottle it becomes the bottle; You put it in a teapot it becomes the teapot."><meta name=generator content="Hugo 0.108.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=http://evacchi.github.io/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Be Like Water</h1><div class=tip><time datetime="2016-01-19 12:00:00 +0000 UTC">Jan 19, 2016</time>
<span class=split>¬∑</span>
<span>5300 words</span>
<span class=split>¬∑</span>
<span>25 minute read</span></div><div class=content><p>Shapeless is a Scala library for <a href=https://en.wikipedia.org/wiki/Generic_programming target=_blank rel=noopener>generic programming</a>. The name ‚ÄúShapeless‚Äù comes from a famous Bruce Lee quote:</p><blockquote><p>Don&rsquo;t get set into one form, adapt it and build your own, and let it grow, be like water. Empty your mind, be formless, <strong>shapeless</strong> ‚Äî like water. Now you put water in a cup, it becomes the cup; You put water into a bottle it becomes the bottle; You put it in a teapot it becomes the teapot. Now water can flow or it can crash. Be water, my friend.</p></blockquote><p>There have been many blog posts
devoted to explaining the very basics of Shapeless, but, in my opinion, fewer posts show
how to truly <em>understand</em> how to <em>use</em> Shapeless. In this post I am trying to give an overview,
starting from a concrete situation. Hopefully, in the end, you will
have a better picture of how to read a piece of code that makes extensive use
of Shapeless and a Shapeless-like coding-style.</p><h4 id=table-of-contents>Table of Contents <a href=#table-of-contents class=anchor>üîó</a></h4><ul><li><a href=#running-example-stream-processing>Running Example: Stream Processing</a></li><li><a href=#abstracting-over-arity>Abstracting over Arity</a></li><li><a href=#hlists-and-product-types>HLists and Product Types</a></li><li><a href=#from-tuples-to-hlists-and-back-again>From Tuples to HLists and Back Again</a></li><li><a href=#the-generic-t-object>The <code>Generic[T]</code> object</a></li><li><a href=#the-fntoproduct-f-object>The <code>FnToProduct[F]</code> object</a></li><li><a href=#implicit-value-resolution>Implicit Value Resolution</a></li><li><a href=a-short-prolog-digression>A Short Prolog Digression</a></li><li><a href=#grandchild-in-scala>GrandChild In Scala</a></li><li><a href=#final-remarks>Final Remarks</a></li><li><a href=#understanding-applyproduct-evidences-and-typeclasses>Understanding <code>applyProduct</code> evidences and typeclasses</a></li><li><a href=#the-aux-pattern>The Aux Pattern</a></li><li><a href=#bonus-applyproduct-encoding-in-prolog>Bonus: <code>applyProduct</code> encoding in Prolog</a></li><li><a href=#conclusions-and-references>Conclusions and Reference</a></li></ul><h2 id=running-example-stream-processing>Running Example: Stream Processing <a href=#running-example-stream-processing class=anchor>üîó</a></h2><p><a href=http://reactive-streams.org target=_blank rel=noopener>Reactive stream</a> frameworks are a fancy new way to do <a href=https://en.wikipedia.org/wiki/Dataflow_programming target=_blank rel=noopener>Dataflow programming</a>, where
a computation is modeled after the flow of data through the nodes of a <em>pipeline</em>, or, more generally, of a <em>flow graph</em>.</p><p>Each <strong>node</strong> of this graph computes a function on the data that comes in, and returns a new value that will be written onto an output stream. In the simplest case of a pipeline,
each node has exactly one input and one output. That is, it computes a function <code>T => R</code>.</p><p>The initial and final nodes are an exception:</p><ul><li>the initial node <em>produces</em> data without an actual input (a function <code>() => R</code>);</li><li>the final node <em>consumes</em> input without producing output (a function <code>T => Unit</code>);</li></ul><p>Beside the initial and final nodes, which can be special-cased, the node of a pipeline may be generally described by the case class:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>case</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Node</span>[<span style=color:#2b91af>T</span>, <span style=color:#2b91af>R</span>](f<span style=color:#00f>:</span> <span style=color:#2b91af>T</span> =&gt; R)
</span></span></code></pre></div><p>But, in a stream processing framework, the more interesting case is that of <em>flow-graph</em>
rather than that of a simple pipeline. In this case, each node would compute a function
of <code>N>=1</code> parameters, where each parameter would be an in-edge into the node.
In pseudo-code:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>case</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Node</span>[<span style=color:#2b91af>T1</span>, <span style=color:#2b91af>T2</span>, <span style=color:#2b91af>...</span>, <span style=color:#2b91af>TK</span>, <span style=color:#2b91af>R</span>](f<span style=color:#00f>:</span> (<span style=color:#2b91af>T1</span>, <span style=color:#2b91af>T2</span>, ..., <span style=color:#2b91af>TK</span>) <span style=color:#00f>=&gt;</span> R)
</span></span></code></pre></div><p>The challenge now would be supporting K-ary function with arbitrary K, without writing K
different implementations. As you may know, tuples and functions in Scala
are implemented by explicitly defining 22 variants, with
up to 22 distinct type parameters, like so:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#2b91af>Function1</span>[<span style=color:#2b91af>T</span>,<span style=color:#2b91af>R</span>]                   
</span></span><span style=display:flex><span><span style=color:#2b91af>Function2</span>[<span style=color:#2b91af>T1</span>,<span style=color:#2b91af>T2</span>,<span style=color:#2b91af>R</span>]              <span style=color:#2b91af>Tuple2</span>[<span style=color:#2b91af>T1</span>,<span style=color:#2b91af>T2</span>]
</span></span><span style=display:flex><span>...                             ...
</span></span><span style=display:flex><span><span style=color:#2b91af>Function22</span>[<span style=color:#2b91af>T1</span>,<span style=color:#2b91af>T2</span>,<span style=color:#2b91af>...</span>,<span style=color:#2b91af>T22</span>,<span style=color:#2b91af>R</span>]     <span style=color:#2b91af>Tuple22</span>[<span style=color:#2b91af>T1</span>,<span style=color:#2b91af>T2</span>,<span style=color:#2b91af>...</span>,<span style=color:#2b91af>T22</span>]
</span></span></code></pre></div><p>The limit is known to be somewhat arbitrary, but we are not debating
this now. The point is, although the code for this could be
auto-generated, we would like to write this once and for all, and</p><ol><li>without resorting to meta-programming (macros and the like)</li><li>without needless code repetition</li></ol><p>In other words, we would like to be able to <em>abstract</em> over the arity (number of arguments) of a function.</p><h2 id=abstracting-over-arity>Abstracting over Arity <a href=#abstracting-over-arity class=anchor>üîó</a></h2><p>The <a href=https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#facilities-for-abstracting-over-arity target=_blank rel=noopener>Shapeless wiki</a> includes a single, interesting example that actually solves our problem.</p><blockquote><p>Conversions between tuples and HList&rsquo;s, and between ordinary Scala functions of
arbitrary arity and functions which take a single corresponding HList argument allow
higher order functions to abstract over the arity of the functions and values they are
passed</p></blockquote><p>The following incantation does the trick:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>import</span> syntax.std.function._
</span></span><span style=display:flex><span><span style=color:#00f>import</span> ops.function._
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>def</span> applyProduct[<span style=color:#2b91af>P</span> <span style=color:#00f>&lt;:</span> <span style=color:#2b91af>Product</span>, <span style=color:#2b91af>F</span>, <span style=color:#2b91af>L</span> <span style=color:#00f>&lt;:</span> <span style=color:#2b91af>HList</span>, <span style=color:#2b91af>R</span>](p<span style=color:#00f>:</span> <span style=color:#2b91af>P</span>)(f<span style=color:#00f>:</span> <span style=color:#2b91af>F</span>)
</span></span><span style=display:flex><span>  (<span style=color:#00f>implicit</span> gen<span style=color:#00f>:</span> <span style=color:#2b91af>Generic.Aux</span>[<span style=color:#2b91af>P</span>, <span style=color:#2b91af>L</span>], fp<span style=color:#00f>:</span> <span style=color:#2b91af>FnToProduct.Aux</span>[<span style=color:#2b91af>F</span>, <span style=color:#2b91af>L</span> <span style=color:#00f>=&gt;</span> <span style=color:#2b91af>R</span>]) <span style=color:#00f>=</span>
</span></span><span style=display:flex><span>    f.toProduct(gen.to(p))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>scala&gt; applyProduct(1, 2)((<span style=color:#00f>_:</span> <span style=color:#2b91af>Int</span>)+(<span style=color:#00f>_:</span> <span style=color:#2b91af>Int</span>))
</span></span><span style=display:flex><span>res0<span style=color:#00f>:</span> <span style=color:#2b91af>Int</span> = 3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>scala&gt; applyProduct(1, 2, 3)((<span style=color:#00f>_:</span> <span style=color:#2b91af>Int</span>)*(<span style=color:#00f>_:</span> <span style=color:#2b91af>Int</span>)*(<span style=color:#00f>_:</span> <span style=color:#2b91af>Int</span>))
</span></span><span style=display:flex><span>res1<span style=color:#00f>:</span> <span style=color:#2b91af>Int</span> = 6
</span></span></code></pre></div><p>Now, we <em>may</em> copy and paste the piece of code above and call it a day.
Instead, this entire post is devoted to achieve a more deep understanding of this short, but very dense snippet. First of all, let us rule out the <strong>type parameters</strong>. What is an HList?</p><h2 id=hlists-and-product-types>HLists and Product Types <a href=#hlists-and-product-types class=anchor>üîó</a></h2><p>Many blog posts have been devoted to describe the ins and the outs of HLists. This is <em>not</em> one such post. The point is, HLists are not that hard a construct to understand and even to implement. The neat part about Shapeless is that many operations on HLists are provided <em>out of the box</em>.</p><p>I want to refer you to the many posts that describe how HLists can be implemented in Scala to find more detail: see the <a href=#references>References</a> section at the bottom of this post for a list. In this section I will instead explain how Shapeless HLists can be used as a substitute for tuples. In order to understand what will follow, the simple mental model that equates HLists to an alternative tuple implementation should suffice.</p><p>HLists (short for <em>Heterogeneous List</em>) are lists of objects of arbitrary types, where the type information for each object is kept. In fact, in Scala, we may do:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>import</span> shapeless._
</span></span><span style=display:flex><span><span style=color:#00f>val</span> l <span style=color:#00f>=</span> 10 <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span>&#34;</span><span style=color:#2b91af>string</span><span>&#34;</span> <span style=color:#2b91af>::</span> <span>1</span><span style=color:#2b91af>.</span><span>0</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>Nil</span>
</span></span></code></pre></div><p>but the type of <code>l</code> then would be <code>List[Any]</code>, because the common super type of the elements there would be, in fact, only <code>Any</code>.
A <code>HList</code> is declared similarly to a <code>List</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> hl <span style=color:#00f>=</span> 10 <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span>&#34;</span><span style=color:#2b91af>string</span><span>&#34;</span> <span style=color:#2b91af>::</span> <span>1</span><span style=color:#2b91af>.</span><span>0</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span>
</span></span></code></pre></div><p>except for the terminator <code>HNil</code>. But the type of <code>hl</code> is actually <code>Int :: String :: Double :: HNil</code>.
As you can see, no type information is lost.</p><p>You can probably think of another family of types in vanilla Scala that act as a container for values of different types; these
types retain type information for each of their component, and the order in which they are declared: <em>tuples</em>.</p><p>HLists <em>can be seen</em> as an alternative implementation of the concept of Tuple. Or, more generally, of the concept of Product.
It is not by accident that Scala tuples all extend the <code>Product</code> trait (in fact, so do case classes; more on this later).
A <code>Product</code> is really just this: for some types <code>T1</code>, <code>T2</code>, &mldr; , <code>TN</code> (N>=1) the product type is the n-tuple <code>(v1, v2, ..., vN)</code> (with <code>v1</code> an instance of type <code>T1</code>, etc.). When each field is <em>named</em> then the tuple is called a <em>record</em> (in vanilla Scala, case classes could be seen as some sort of record).</p><p>You already know that Scala tuples are a first-class concept; tuples are constructed through convenient literal syntax <code>(v1, v2, ..., vN)</code>; using Shapeless, HLists are constructed using the syntax <code>v1 :: v2 :: ... :: vN :: HNil</code>.</p><p>The benefit of using <code>HLists</code> instead of tuples is that they can be used in all those situations where a tuple would work just as well, <strong>but</strong> <em>without</em> the 22-elements limit.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> t  <span style=color:#00f>=</span> (1,   <span style=color:#a31515>&#34;String&#34;</span>,   2.0)
</span></span><span style=display:flex><span><span style=color:#00f>val</span> hl <span style=color:#00f>=</span>  1 <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span>&#34;</span><span style=color:#2b91af>String</span><span>&#34;</span> <span style=color:#2b91af>::</span> <span>2</span><span style=color:#2b91af>.</span><span>0</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>val</span> (a,   b,   c)        <span style=color:#00f>=</span> t
</span></span><span style=display:flex><span><span style=color:#00f>val</span>  x <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span style=color:#2b91af>y</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>z</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> = hl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>t <span style=color:#00f>match</span> {
</span></span><span style=display:flex><span>  <span style=color:#00f>case</span> (1, s, <span style=color:#00f>_</span>) <span style=color:#00f>=&gt;</span> ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hl <span style=color:#00f>match</span> {
</span></span><span style=display:flex><span>  <span style=color:#00f>case</span> 1 <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span style=color:#2b91af>s</span> <span style=color:#2b91af>::</span> <span style=color:#00f>_</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> =&gt; ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Moreover, Shapeless <code>HLists</code> provide many of the operations that can be usually applied to <code>Lists</code> such as <code>map</code>, <code>flatMap</code> etc. But, as a simple substitute for tuples, HLists are already quite valuable; for instance, it is not necessary to know the size of an HList before being able to match against it, rendering possible to do things like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>hl <span style=color:#00f>match</span> {
</span></span><span style=display:flex><span>  <span style=color:#00f>case</span> 1 <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span style=color:#2b91af>rest</span> =&gt; ... <span style=color:green>// matches if first element 1, regardless the size of the list
</span></span></span><span style=display:flex><span><span style=color:green></span>                        <span style=color:green>// and binds the tail to `rest`
</span></span></span><span style=display:flex><span><span style=color:green></span>  <span style=color:#00f>case</span> x <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span style=color:#2b91af>y</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> =&gt; ... <span style=color:green>// matches when it is a pair
</span></span></span><span style=display:flex><span><span style=color:green></span>  <span style=color:green>// etc.                      
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><h2 id=from-tuples-to-hlists-and-back-again>From Tuples to HLists and Back Again <a href=#from-tuples-to-hlists-and-back-again class=anchor>üîó</a></h2><p>Because Tuples and HLists are essentially the implementation of a similar concept,
they are also <em>isomorphic</em> to eachother, that is, there is a <em>morphism</em> (a function)
to go back and forth between them.</p><p>The way we go <strong>from HLists to Tuples</strong> is through the <code>tupled</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>import</span> syntax.std.product._
</span></span><span style=display:flex><span><span style=color:#00f>val</span> hl  <span style=color:#00f>=</span> 1 <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span>&#34;</span><span style=color:#2b91af>String</span><span>&#34;</span> <span style=color:#2b91af>::</span> <span>2</span><span style=color:#2b91af>.</span><span>0</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span>
</span></span><span style=display:flex><span><span style=color:#00f>val</span>  t  <span style=color:#00f>=</span> hl.tupled
</span></span></code></pre></div><p>The way we go <strong>from Tuples to HLists</strong> is through the <code>productElements</code> method.
In fact, if <code>hl</code> is the HList, and <code>t</code> is the equivalent tuple, then it is always true that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>hl == t.productElements
</span></span></code></pre></div><p>Of course, a simple consequence is that you are able to abstract over the arity of <strong>tuples</strong> by <em>transforming them into HLists</em></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>aTuple.productElements <span style=color:#00f>match</span> {
</span></span><span style=display:flex><span>  <span style=color:#00f>case</span> a <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span style=color:#2b91af>b</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> =&gt; ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Whatsmore, because all tuples implement the <code>Product</code> trait
and <strong>case classes</strong> implement the <code>Product</code> trait, many of the operations
working for tuples also work for case classes.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>case</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Person</span>(name<span style=color:#00f>:</span> <span style=color:#2b91af>String</span>, age<span style=color:#00f>:</span> <span style=color:#2b91af>Int</span>)
</span></span><span style=display:flex><span><span style=color:#2b91af>Person</span>(<span style=color:#a31515>&#34;John&#34;</span>, 40).productElements <span style=color:#00f>match</span> {
</span></span><span style=display:flex><span>  <span style=color:#00f>case</span> name <span style=color:#00f>:</span><span style=color:#2b91af>:</span> <span style=color:#2b91af>age</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> =&gt; ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is even possible to create instances of a case class from an HList.
Let us see how.</p><h2 id=the-generict-object>The <code>Generic[T]</code> object <a href=#the-generict-object class=anchor>üîó</a></h2><p>A <code>Generic[T]</code> object implements the methods <code>to(T)</code> and <code>from(HList)</code> for a given product type <code>T</code> (usually, a case class or a tuple). For instance, the <code>Generic</code> object to convert back and forth between a <code>Person</code> and an <code>HList</code> is created and used as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> gp <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>Person</span>]
</span></span><span style=display:flex><span><span style=color:#00f>val</span> john <span style=color:#00f>=</span> <span style=color:#2b91af>Person</span>(<span style=color:#a31515>&#34;John&#34;</span>, 40)
</span></span><span style=display:flex><span><span style=color:#00f>val</span> hl<span style=color:#00f>:</span> <span style=color:#2b91af>String</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>Int</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> = gp.to(john)
</span></span><span style=display:flex><span><span style=color:#00f>val</span> p<span style=color:#00f>:</span> <span style=color:#2b91af>Person</span> = gp.from(hl)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert( john == p )
</span></span></code></pre></div><p>This is likewise true for tuples.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> gp <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>Tuple2</span>[<span style=color:#2b91af>String</span>,<span style=color:#2b91af>Int</span>]]
</span></span><span style=display:flex><span><span style=color:#00f>val</span> johnTuple <span style=color:#00f>=</span> (<span style=color:#a31515>&#34;John&#34;</span>, 40)
</span></span><span style=display:flex><span><span style=color:#00f>val</span> hl<span style=color:#00f>:</span> <span style=color:#2b91af>String</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>Int</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> = gp.to(johnTuple)
</span></span><span style=display:flex><span><span style=color:#00f>val</span> tp<span style=color:#00f>:</span> <span style=color:#2b91af>Tuple2</span>[<span style=color:#2b91af>String</span>,<span style=color:#2b91af>Int</span>] <span style=color:#00f>=</span> gp.from(hl)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert( johnTuple == tp )
</span></span></code></pre></div><p>In fact, the <code>t.productElements</code> method is really short-hand syntax for the code snippet above.</p><h2 id=the-fntoproductf-object>The <code>FnToProduct[F]</code> object <a href=#the-fntoproductf-object class=anchor>üîó</a></h2><p>Suppose you have function <code>f</code> that takes <code>K</code> arguments, and that you want to conflate
those arguments into one single product-type argument.</p><p>Scala provides <code>f.tupled</code> which turns a K-ary function into a unary function of one K-tuple argument. For instance:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> f <span style=color:#00f>=</span> (s<span style=color:#00f>:</span> <span style=color:#2b91af>String</span>, i<span style=color:#00f>:</span> <span style=color:#2b91af>Int</span>) <span style=color:#00f>=&gt;</span> <span style=color:#a31515>s&#34;</span><span style=color:#a31515>$s</span><span style=color:#a31515> </span><span style=color:#a31515>$i</span><span style=color:#a31515>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#00f>val</span> ft<span style=color:#00f>:</span> <span style=color:#2b91af>Tuple2</span>[<span style=color:#2b91af>String</span>, <span style=color:#2b91af>Int</span>] <span style=color:#00f>=&gt;</span> <span style=color:#2b91af>String</span> <span style=color:#00f>=</span> f.tupled
</span></span></code></pre></div><p>But then, again, as we have seen already, you are not really able to <em>abstract</em> over the arity of Scala tuples. However, we can import <code>FnToProduct[F]</code> to turn a K-ary function into a function of K-sized HList of the same argument types.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>import</span> ops.function._
</span></span><span style=display:flex><span><span style=color:#00f>val</span> fp <span style=color:#00f>=</span> <span style=color:#2b91af>FnToProduct</span>[(<span style=color:#2b91af>String</span>, <span style=color:#2b91af>Int</span>) <span style=color:#00f>=&gt;</span> <span style=color:#2b91af>String</span>]
</span></span><span style=display:flex><span><span style=color:#00f>val</span> fhl<span style=color:#00f>:</span> <span style=color:#2b91af>String::Int::HNil</span> =&gt; <span style=color:#2b91af>String</span> <span style=color:#00f>=</span> fp.apply(f) <span style=color:green>// or, equivalently, fp(f)
</span></span></span></code></pre></div><p>in fact, there is even syntactic sugar for this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>import</span> syntax.std.function._
</span></span><span style=display:flex><span><span style=color:#00f>val</span> fhl<span style=color:#00f>:</span> <span style=color:#2b91af>String::Int::HNil</span> =&gt; <span style=color:#2b91af>String</span> <span style=color:#00f>=</span> f.toProduct
</span></span></code></pre></div><p>So now we have already sufficient elements to understand the following line of the Shapeless wiki.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>f.toProduct(gen.to(p)) <span style=color:green>// could have been written as f.toProduct.apply(gen.to(p))
</span></span></span></code></pre></div><p>First of all, let us consider a special case;
imagine <code>f</code> is the function we have just defined above, and let <code>p = Person("John", 40)</code>.
Now, the line above is a bit terse. Let us expand it a little bit:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> gen <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>Person</span>]
</span></span><span style=display:flex><span><span style=color:#00f>val</span> fhl<span style=color:#00f>:</span> <span style=color:#2b91af>String</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>Int</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> =&gt; <span style=color:#2b91af>String</span> <span style=color:#00f>=</span> f.toProduct
</span></span><span style=display:flex><span><span style=color:#00f>val</span> hl<span style=color:#00f>:</span> <span style=color:#2b91af>String</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>Int</span> <span style=color:#2b91af>::</span> <span style=color:#2b91af>HNil</span> = gen.to(p)
</span></span><span style=display:flex><span>fhl(hl)
</span></span></code></pre></div><ul><li>we get <code>gen</code>, a <code>Generic[Person]</code> instance</li><li>we convert <code>f</code> to an HList-accepting function (<code>f.toProduct</code>);</li><li>we convert <code>p</code> to the HList <code>hl</code> by applying the <code>to(Person)</code> method of <code>gen</code></li></ul><p>There is still something missing, though. In the expanded version we have explicitly requested the
<code>Generic[Person]</code> instanced to be created.
The wiki uses <em>implicit parameters</em>. How do these <em>implicits</em> work?
What is their relation to <code>Generic</code> and <code>FnToProduct</code>? And, do we really need them there?</p><h2 id=implicit-value-resolution>Implicit Value Resolution <a href=#implicit-value-resolution class=anchor>üîó</a></h2><p>Implicits are a controversial feature of the Scala programming language.
They are hard to grasp for beginners, and they can be cause of headaches
even to the more experienced users. The choice of the word <em>implicit</em> is arguable. It
probably contributed to add to Scala&rsquo;s <em>black magic</em> fame.</p><p>You are probably already aware that <em>implicits</em> are values that, when <em>in scope</em>,
are automatically inserted as required by the compiler.
When one such <em>implicit value</em> is in scope, then the implicit arguments
can be completely omitted by who is writing the code. For instance:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>implicit</span> <span style=color:#00f>val</span> implicitJohn <span style=color:#00f>=</span> <span style=color:#2b91af>Person</span>(<span style=color:#a31515>&#34;John&#34;</span>, 40)
</span></span><span style=display:flex><span><span style=color:#00f>def</span> somePersonString(<span style=color:#00f>implicit</span> p<span style=color:#00f>:</span> <span style=color:#2b91af>Person</span>) <span style=color:#00f>=</span> p.toString
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>somePersonString <span style=color:green>// returns &#34;Person(John, 40)&#34;
</span></span></span></code></pre></div><p>Implicits can be brought into scope by explicitly declaring them, as in the example
above, by <em>importing</em> them from a library.
The most simple use case for implicits is to provide <em>fallback values</em>,
but they can be exploited for other advanced use, such as validating nontrivial
constraints. An example of this is the encoding of
<a href=http://rnduja.github.io/2015/10/07/scala-dependent-types/ target=_blank rel=noopener><em>dependent types</em></a>.</p><p><code>implicit def</code>s can be used to <em>generate</em> implicit values as needed.
The most simple use for implicit defs is to provide <em>implicit type conversions</em>
that are often used to define <a href=https://en.wikipedia.org/wiki/Extension_method target=_blank rel=noopener>extension methods</a>.
Implicit defs are also used when implicit parameters of a function are being resolved
to see if a matching value can be <em>generated</em> on-the-fly.</p><p>For instance, consider this example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>implicit</span> <span style=color:#00f>def</span> personProvider <span style=color:#00f>=</span> <span style=color:#2b91af>Person</span>(<span style=color:#a31515>&#34;Random Guy&#34;</span>, (math.random * 100).toInt)
</span></span><span style=display:flex><span><span style=color:#00f>def</span> somePersonString(<span style=color:#00f>implicit</span> p<span style=color:#00f>:</span> <span style=color:#2b91af>Person</span>) <span style=color:#00f>=</span> p.toString
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; somePersonString <span style=color:green>// Person(&#34;Random Guy&#34;, and a random integer between 0 and 100)
</span></span></span></code></pre></div><p>Let me repeat this once again: implicit parameter <strong>resolution</strong> is a compile-time
procedure that does not affects run-time performance. Implicit values
that are generated by implicit defs, on the other hand, may obviously affect
run-time since they are instances of classes which may have arbitrary code in
their constructors; on the other hand, the JVM is pretty good
at optimizing out final classes, singletons and the like,
but be advised that a matching implicit def is code that
<em>will actually execute</em> at run time!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>implicit</span> <span style=color:#00f>def</span> aSlowPersonProvider <span style=color:#00f>=</span> {
</span></span><span style=display:flex><span>	<span style=color:#2b91af>Thread</span>.sleep(3000) <span style=color:green>// faking a slow computation here
</span></span></span><span style=display:flex><span><span style=color:green></span>	<span style=color:#2b91af>Person</span>(<span style=color:#a31515>&#34;Random Guy&#34;</span>, (math.random * 100).toInt)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#00f>def</span> somePersonString(<span style=color:#00f>implicit</span> p<span style=color:#00f>:</span> <span style=color:#2b91af>Person</span>) <span style=color:#00f>=</span> p.toString
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; somePersonString <span style=color:green>// sits 3 secs, then returns the Person instance
</span></span></span></code></pre></div><p>Implicit parameter resolution can be twisted
to enforce stronger constraints than simple type-checking. Parameterized types
such as <code>Generic.Aux[P,L]</code> in the Shapeless wiki
can be used to encode <em>predicates</em> about types, and <em>relations</em> between them.
Your compiler checks for conformity to type signatures when
you invoke methods or create class instances.
In the case of implicits, though, the compiler
<em>attempts</em> to fill in the voids <em>automatically</em>.
The voids will be filled <em>if and only if</em> these relations hold.</p><p>In the previous example, we were asking the compiler to
execute method <code>somePersonString</code> <strong>if and only if</strong> a value
of type <code>Person</code> could be brought into scope. To put it in another way,
we wanted the method invocation to compile <strong>if and only if</strong>
the compiler could <em>prove</em> that a matching value (a value of that type)
<em>may exist</em>.</p><p>When I saw this, I had one of those &ldquo;aha!"-moments. The key to
understanding implicit resolution in Scala, to me, was finding the parallel that exist
with the evaluation of a program in a logic programming language such as <em>Prolog</em>.</p><h3 id=a-short-prolog-digression>A Short Prolog Digression <a href=#a-short-prolog-digression class=anchor>üîó</a></h3><p>In the Prolog programming language you may state <em>facts</em> and provide <em>rules</em>
to derive new facts. These facts and rules are kept in a space called a <em>knowledge base</em> (or <em>KB</em>),
a database of all the facts and rules that have been defined.</p><p>The knowledge base, can be <em>queried</em>, like you would do on a SQL database, although
with a different query language. And, like in any other query language,
the execution of a Prolog program consists in solving the constraints
that are found in the query.</p><p>For instance, let us say that John, Carl and Tom are all persons. We do this by writing the Prolog listing:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>person(<span style=color:#a31515>john</span>).
</span></span><span style=display:flex><span>person(<span style=color:#a31515>carl</span>).
</span></span><span style=display:flex><span>person(<span style=color:#a31515>tom</span>).
</span></span></code></pre></div><p>These are all <em>facts</em> that we are stating about the atomic values john, carl, and tom (notice that they are all in small-letters; capitals are reserved to variables).
You can now check whether <code>john</code> is a person with the query</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a31515>?-</span> person(<span style=color:#a31515>john</span>).
</span></span><span style=display:flex><span><span style=color:#a31515>true</span>
</span></span></code></pre></div><p>You can also get all the persons in the KB:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a31515>?-</span> person(X).
</span></span></code></pre></div><p>Where <code>X</code> is a <em>free variable</em> (Prolog use capitals to denote variables), that is, a <em>fresh</em> variable that is not bound to any value.
In this case we are asking the interpreter to find a <em>concrete proof</em> (or <em>evidence</em> or <em>witness</em>)
that the condition holds in the KB. In other words, we want to find <em>at least</em> one binding of <code>X</code> for which <code>person(X)</code> is true;
By hitting <code>;</code> we can request the next binding.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a31515>?-</span> person(X).
</span></span><span style=display:flex><span>X = <span style=color:#a31515>john</span> ;
</span></span><span style=display:flex><span>X = <span style=color:#a31515>carl</span> ;
</span></span><span style=display:flex><span>X = <span style=color:#a31515>tom</span>
</span></span></code></pre></div><p>Let us now provide relations; that is K-ary facts about these persons.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>child(<span style=color:#a31515>john</span>, <span style=color:#a31515>carl</span>).
</span></span><span style=display:flex><span>child(<span style=color:#a31515>carl</span>, <span style=color:#a31515>tom</span>).
</span></span></code></pre></div><p>we can now instruct Prolog on how to <em>derive</em> further relations between these persons using <em>rules</em>. For instance, let us define the <code>grandchild</code> rule.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>grandchild(A, B) :-
</span></span><span style=display:flex><span>	child(A, X),
</span></span><span style=display:flex><span>	child(X, B).
</span></span></code></pre></div><p>That is, <code>A</code> and <code>B</code> are in a grandchild relation if <code>A</code> is child of some <code>X</code>
and <code>X</code> is a child of <code>B</code>. A rule describes an implication relation, in fact, this, in logic may be written as:</p><pre tabindex=0><code>‚àÄ A, B, X: child(A,X) ‚àß child(X,B) ‚Üí grandchild(A,B)
</code></pre><p>Notice that the implication is written in reverse, compared to the Prolog version.
The Prolog version results more readable in code, because it makes more
prominent the fact that the implication will derive.
The interpreter can be queried in a number of ways. Again, small letters
denote atoms, while capitals indicate free variables, we can choose any combination of the two
to produce different results.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:green>% find the pair(s) X,Y for which the grandchild relation holds</span>
</span></span><span style=display:flex><span><span style=color:#a31515>?-</span> grandchild(X, Y).
</span></span><span style=display:flex><span>X = <span style=color:#a31515>john</span>
</span></span><span style=display:flex><span>Y = <span style=color:#a31515>tom</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>% find the john&#39;s grandchildren</span>
</span></span><span style=display:flex><span><span style=color:#a31515>?-</span> grandchild(<span style=color:#a31515>john</span>, Y).
</span></span><span style=display:flex><span>Y = <span style=color:#a31515>tom</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>% find tom&#39;s grandparents</span>
</span></span><span style=display:flex><span><span style=color:#a31515>?-</span> grandchild(X, <span style=color:#a31515>tom</span>).
</span></span><span style=display:flex><span>X = <span style=color:#a31515>john</span>
</span></span></code></pre></div><p>The system will also fail in <em>impossible</em> cases, that is, when we try to find
something that is not derivable in the knowledge base.
For instance, looking for someone who is his/her own grandchild</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a31515>?-</span> grandchild(X, X)
</span></span><span style=display:flex><span><span style=color:#a31515>no</span>
</span></span></code></pre></div><p>or looking for someone who is grandchild of tom (who has no grandchildren)</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a31515>?-</span> grandchild(<span style=color:#a31515>tom</span>, X)
</span></span><span style=display:flex><span><span style=color:#a31515>no</span>
</span></span></code></pre></div><p>or looking for the granparent of john, which is unknown in this knowledge base</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a31515>?-</span> grandchild(X, <span style=color:#a31515>john</span>)
</span></span><span style=display:flex><span><span style=color:#a31515>no</span>
</span></span></code></pre></div><h3 id=grandchild-in-scala>GrandChild In Scala <a href=#grandchild-in-scala class=anchor>üîó</a></h3><p>In order to better understand the relation between Prolog and Scala, let us first
introduce a dialect of Scala that we will call <em>Logic Scala</em>.</p><p><em>Logic Scala</em> is a superset of Scala where two new keywords are introduced:</p><ul><li><code>fact</code></li><li><code>rule</code></li></ul><p>Let us see how an implementation of the <code>grandchild</code> example may look in Logic Scala.
First, we have to introduce facts about children. The relation may be declared
as a parameterized type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>B</span>] <span style=color:green>// notice that a class would work as well
</span></span></span></code></pre></div><p>where A,B will be substituted by atoms. Atoms are, again, types, so we may declare them as follows</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>John</span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>Carl</span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>Tom</span>
</span></span></code></pre></div><p>We can now declare <em>facts</em> (remember, this is <em>Logic Scala</em>):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>fact johncarl <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>John</span>,<span style=color:#2b91af>Carl</span>]{} <span style=color:green>// an instance of type Child
</span></span></span><span style=display:flex><span><span style=color:green></span>fact carltom  <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>Carl</span>,<span style=color:#2b91af>Tom</span> ]{}
</span></span></code></pre></div><p>The rule for <code>grandchild</code> is made of two parts. The type declaration,</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>B</span>]
</span></span></code></pre></div><p>and the semantics of the rule, which is given using the <code>rule</code> construct.
Just like in Prolog, our imaginary Scala dialect would describe how to derive
new instances of the type <code>GrandChild[A,B]</code> from facts that are found (or that can
be derived) in the current knowledge base. A <code>rule</code> is written similarly to
a <code>def</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>rule grandChild[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>B</span>,<span style=color:#2b91af>X</span>](  
</span></span><span style=display:flex><span>	facts
</span></span><span style=display:flex><span>		xy<span style=color:#00f>:</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>X</span>],
</span></span><span style=display:flex><span>		yz<span style=color:#00f>:</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>B</span>]
</span></span><span style=display:flex><span>	) <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>B</span>] {}
</span></span></code></pre></div><p>Notice that, because a <code>rule</code> declaration is syntactically similar to a <code>def</code> declaration, it is written in the same order of the abstract logic declaration, while the Prolog version is written in reverse. However, if we remove the syntactic noise, this is really stating the same:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>rule[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>B</span>,<span style=color:#2b91af>X</span>](<span style=color:#2b91af>Child</span>[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>X</span>], <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>B</span>])<span style=color:#00f>:</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>A</span>,<span style=color:#2b91af>B</span>]
</span></span></code></pre></div><p>that is, for some A, B, X, <em>if</em> there exist <code>Child[A,X]</code>, <code>Child[X,B]</code>, <em>then</em>
a <code>GrandChild[A,B]</code> can be derived.</p><p>we can now write a query. The query will compile if and only if the
compiler is able to satisfy the contraints using the facts and the rules in the knowledge base.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; query[ <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>John</span>, <span style=color:#2b91af>Tom</span>] ]
</span></span><span style=display:flex><span><span style=color:green>// (compiles; returns the fact instance)
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>&gt; query[ <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>John</span>, <span style=color:#2b91af>Carl</span>] ]
</span></span><span style=display:flex><span><span style=color:#2b91af>Compilation</span> <span style=color:#2b91af>Failed</span>
</span></span></code></pre></div><p>You should now be more convinced that there is a strong correspondence between
the Logic Scala version and the Prolog version. Truth is, the only difference between Logic Scala and real-world Scala is that we renamed a few keywords. The code and machinery are actually the same!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>John</span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>Carl</span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>Tom</span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>T</span>,<span style=color:#2b91af>U</span>]
</span></span><span style=display:flex><span><span style=color:#2b91af>implicit</span> <span style=color:#00f>val</span> john_carl <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>John</span>,<span style=color:#2b91af>Carl</span>]{}
</span></span><span style=display:flex><span><span style=color:#00f>implicit</span> <span style=color:#00f>val</span> carl_tom  <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>Carl</span>,<span style=color:#2b91af>Tom</span> ]{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>T</span>,<span style=color:#2b91af>U</span>]
</span></span><span style=display:flex><span><span style=color:#2b91af>implicit</span> <span style=color:#00f>def</span> grandChild[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>Y</span>,<span style=color:#2b91af>Z</span>](
</span></span><span style=display:flex><span>	<span style=color:#00f>implicit</span>
</span></span><span style=display:flex><span>		xy<span style=color:#00f>:</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>Y</span>],
</span></span><span style=display:flex><span>		yz<span style=color:#00f>:</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>Y</span>,<span style=color:#2b91af>Z</span>]
</span></span><span style=display:flex><span>	) <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>Z</span>] {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; implicitly[ <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>John</span>, <span style=color:#2b91af>Tom</span>] ]
</span></span><span style=display:flex><span><span style=color:green>// (compiles; returns the fact instance)
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>&gt; implicitly[ <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>John</span>, <span style=color:#2b91af>Carl</span>] ]
</span></span><span style=display:flex><span><span style=color:#2b91af>Compilation</span> <span style=color:#2b91af>Failed</span>
</span></span></code></pre></div><p>You should now be convinced that there is a correspondence between the way logic
programs are evaluated and the way implicits are resolved at compile-time.
In fact,</p><ul><li><strong>implicit vals</strong> can be seen as <strong>facts</strong></li><li><strong>implicit defs</strong> can be seen as <strong>rules</strong></li><li><strong>type parameters</strong> in a <strong>def</strong> correspond to <strong>variables</strong> in a rule definition</li><li><strong>implicit parameter lists</strong> are bodies of a rule</li></ul><h3 id=final-remarks>Final Remarks <a href=#final-remarks class=anchor>üîó</a></h3><p>Please recall that in Prolog we could even write</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span><span style=color:#a31515>?-</span> grandchild(<span style=color:#a31515>john</span>, Y).
</span></span></code></pre></div><p>The query above is asking for <em>evidence</em> that there exist a granchild of John in the KB.
The interpreter would return the <code>Y</code> binding for which the condition holds; i.e., <code>Y=tom</code>.
Something similar can be achieved in Scala through <em>existential types</em>.
The query above could be encoded as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>&gt; <span style=color:#a31515>implicitly</span> [ GrandChild[John, Y <span style=color:#a31515>forSome</span> { <span style=color:#a31515>type</span> Y }] ]
</span></span></code></pre></div><p>this encodes <em>exactly</em> the same query: find <em>evidence</em> (an object instance)
that there exist <code>Y</code> such that <code>GrandChild[John, Y]</code> is a valid statement (a concrete type).</p><p>This can be also more concisely expressed as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>&gt; <span style=color:#a31515>implicitly</span> [ GrandChild[John, <span style=color:#00f>_</span>] ]
</span></span></code></pre></div><p>There are caveats, though.</p><p>First of all, Scala will not return the actual binding for which the condition holds.
In fact, this does not make sense, because, in general, when you write <code>GrandChild[John, _]</code>
you are <em>representing the type</em> of something that is in a <code>GrandChild</code> relation with John. It may be
an instance of <code>GrandChild[John, Tom]</code>, but there might be others at some point in time. You do not
want <code>GrandChild[John, _]</code> to <em>always</em> be an alias for <code>GrandChild[John, Tom]</code></p><p>Second, the symmetric query <code>GrandChild[_, Tom]</code> will not work in this case. The deep reasons for which
are a bit technical and would go beyond the scope of this essay. In short, Scala evaluates
the implicit parameters in the <code>def</code> signature in the order they are defined; thus, when you write <code>GrandChild[_, Tom]</code>
the system looks for an implicit instance of <code>Child[_,Y]</code>, but this cannot be derived, because <code>Y</code> is still
unknown at that time. In fact, if we define another <code>implicit def</code> where the implicit values are re-ordered:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>implicit</span> <span style=color:#00f>def</span> grandChildReordered[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>Y</span>,<span style=color:#2b91af>Z</span>](
</span></span><span style=display:flex><span>	<span style=color:#00f>implicit</span>
</span></span><span style=display:flex><span>	    yz<span style=color:#00f>:</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>Y</span>,<span style=color:#2b91af>Z</span>],
</span></span><span style=display:flex><span>	    xy<span style=color:#00f>:</span> <span style=color:#2b91af>Child</span>[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>Y</span>]
</span></span><span style=display:flex><span>	) <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>X</span>,<span style=color:#2b91af>Z</span>] {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; implicitly[ <span style=color:#2b91af>GrandChild</span>[<span style=color:#00f>_</span>, <span style=color:#2b91af>Tom</span>] ]
</span></span><span style=display:flex><span><span style=color:green>// compiles
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>&gt; implicitly[ <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>John</span>, <span style=color:#00f>_</span>] ]
</span></span><span style=display:flex><span><span style=color:green>// compiles
</span></span></span></code></pre></div><p><code>GrandChild[_,_]</code> will only work if you explicitly &ldquo;assert&rdquo; it:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>implicit</span> <span style=color:#00f>val</span> fallback<span style=color:#00f>:</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#00f>_</span>,<span style=color:#00f>_</span>] <span style=color:#00f>=</span> <span style=color:#00f>new</span> <span style=color:#2b91af>GrandChild</span>[<span style=color:#2b91af>Nothing</span>,<span style=color:#2b91af>Nothing</span>]{}
</span></span><span style=display:flex><span>&gt; implicitly[ <span style=color:#2b91af>GrandChild</span>[<span style=color:#00f>_</span>, <span style=color:#00f>_</span>] ]
</span></span></code></pre></div><p>We are now ready to understand how type parameter inference and implicit resolution work in <code>applyProduct</code>.</p><h2 id=understanding-applyproduct-evidences-and-typeclasses>Understanding <code>applyProduct</code>: evidences and typeclasses <a href=#understanding-applyproduct-evidences-and-typeclasses class=anchor>üîó</a></h2><p>We already saw what the <em>body</em> of the <code>applyProduct</code> function did; we left for later the description of the
implicit parameters. Because now we have found the parallel between Scala and Prolog, we can easily describe
what is happening in the function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>def</span> applyProduct[<span style=color:#2b91af>P</span> <span style=color:#00f>&lt;:</span> <span style=color:#2b91af>Product</span>, <span style=color:#2b91af>F</span>, <span style=color:#2b91af>L</span> <span style=color:#00f>&lt;:</span> <span style=color:#2b91af>HList</span>, <span style=color:#2b91af>R</span>](p<span style=color:#00f>:</span> <span style=color:#2b91af>P</span>)(f<span style=color:#00f>:</span> <span style=color:#2b91af>F</span>)
</span></span><span style=display:flex><span>  (<span style=color:#00f>implicit</span>
</span></span><span style=display:flex><span>  	 gen<span style=color:#00f>:</span> <span style=color:#2b91af>Generic.Aux</span>[<span style=color:#2b91af>P</span>, <span style=color:#2b91af>L</span>],
</span></span><span style=display:flex><span>  	 fp<span style=color:#00f>:</span> <span style=color:#2b91af>FnToProduct.Aux</span>[<span style=color:#2b91af>F</span>, <span style=color:#2b91af>L</span> <span style=color:#00f>=&gt;</span> <span style=color:#2b91af>R</span>]
</span></span><span style=display:flex><span>  ) <span style=color:#00f>=</span> f.toProduct(gen.to(p))
</span></span></code></pre></div><ul><li>Let be <code>P</code> a <code>Product</code>, that is, a tuple or a case class</li><li>Let be <code>F</code> an unconstrained type parameter</li><li>Let be <code>L</code> an <code>HList</code></li><li>Let be <code>R</code> an unconstrained type parameter</li></ul><p>then,</p><ul><li>For a given product of type <code>P</code></li><li>For a given object of type <code>F</code> (the function)</li></ul><p>we can invoke <code>applyProduct</code> if the following relations hold:</p><ul><li><code>Generic.Aux[P, L]</code>; this is the built-in ‚Äúpredicate‚Äù that Shapeless provides
to encode the relation between a product type <code>P</code> and an HList <code>L</code>. It holds
when it is possible to derive a <code>Generic[P]</code> instance that converts <code>P</code> into <code>L</code></li><li><code>FnToProduct.Aux[F, L => R]</code>; is he built-in ‚Äúpredicate‚Äù that Shapeless provides
to encode the relation that holds when <code>F</code> can be converted into a function from HList <code>L</code> to return type <code>R</code>;
it holds when it is possible to derive an <code>FnToProduct[F]</code> instance called that converts <code>F</code> into <code>L => R</code></li></ul><p>Congratulations, you have just learned how to use <strong>typeclasses</strong> !
In fact, the values <code>gen</code> and <code>fp</code> are <em>instances</em> of the <code>Generic[P]</code> and <code>FnToProduct[F]</code> <em>typeclasses</em>.</p><p>As we saw in the previous section, the value of an implicit parameter can be seen as <em>evidence</em> that a <em>predicate</em> holds.
In Scala, we implement predicates through <em>types</em>, and <em>evidences</em> are object instances. If these object instances
provide methods, then they are called <em>typeclasses</em>.</p><p>For instance, we saw before that <code>Generic[P]</code> provides the methods <code>to(P)</code> and <code>from(HList)</code>.</p><h3 id=the-aux-pattern>The Aux Pattern <a href=#the-aux-pattern class=anchor>üîó</a></h3><p>We have left only one little detail. Why are the predicates called <code>Generic.Aux</code> and <code>FnToProduct.Aux</code>
but the type classes are just <code>Generic</code>¬†and <code>FnToProduct</code> ?
Again, this is a bit technical.</p><p><code>Generic.Aux</code> and <code>FnToProduct.Aux</code> are actually <em>type aliases</em>. You may know that scala includes a
<em>type alias</em> feature. Type aliases are also called <em>type members</em> because, just like properties
and methods, they occur as <em>members</em> of another type. For instance, the <code>Generic[P]</code> trait:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>trait</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>P</span>] {
</span></span><span style=display:flex><span>  <span style=color:#00f>type</span> <span style=color:#2b91af>Out</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The type alias <code>Generic.Aux</code> is defined in the companion object of <code>Generic</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>object</span> <span style=color:#2b91af>Generic</span> {
</span></span><span style=display:flex><span>  <span style=color:#00f>type</span> <span style=color:#2b91af>Aux</span>[<span style=color:#2b91af>P</span>,<span style=color:#2b91af>L</span>] <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>P</span>] { <span style=color:#00f>type</span> <span style=color:#2b91af>Out</span> = L }  
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and it reads as follows:
<code>Generic.Aux[P,L]</code> is the type of <code>Generic[P]</code> when the type alias <code>Generic.Out</code> within it equals to <code>L</code>.
Again, this is a <em>predicate</em>. When we write <code>(implicit gen: Generic.Aux[P,L])</code>
or equivalently <code>(implicit gen: Generic[P] { type Out = L })</code>; we want the compiler to <em>prove</em>
that there exists (or that it can be derived) in current scope an <em>evidence</em> that
<code>Generic[P] { type Out = L }</code>; in particular, in the case <code>Generic.Aux[Person, L]</code>
we want proof that there exist some HList <code>L</code> such that <code>Person</code> can be converted into <code>L</code>.</p><p>But then, you may ask, why can we just write <code>Generic[P,L]</code>, and be done with it ?
Recall that in one of our first examples we wanted to convert a <code>Person(String,Int)</code> into the corresponding HList:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> gen <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>Person</span>]
</span></span><span style=display:flex><span><span style=color:#00f>val</span> hl <span style=color:#00f>=</span> gen.to(p)
</span></span></code></pre></div><p>If <code>L</code> were part of the type signature of <code>Generic</code> then we would need to write:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>val</span> gen <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>Person</span>, <span style=color:#2b91af>L</span>]
</span></span></code></pre></div><p>but then <code>L</code> would be a fresh type parameter, which cannot occur in that position!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>scala&gt; <span style=color:#00f>val</span> gen <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>Person</span>, <span style=color:#2b91af>L</span>]
</span></span><span style=display:flex><span>&lt;console<span style=color:#00f>&gt;:</span>19<span style=color:#00f>:</span> <span style=color:#2b91af>error:</span> <span style=color:#2b91af>not</span> <span style=color:#2b91af>found:</span> <span style=color:#00f>type</span> <span style=color:#2b91af>L</span>
</span></span><span style=display:flex><span>       <span style=color:#00f>val</span> gen <span style=color:#00f>=</span> <span style=color:#2b91af>Generic</span>[<span style=color:#2b91af>Person</span>, <span style=color:#2b91af>L</span>]
</span></span><span style=display:flex><span>                                 ^
</span></span></code></pre></div><p>The type member trick is useful to ‚Äúhide‚Äù the type parameter in those situations where it is not only unnecessary (the type <code>L</code> of the HList is <strong>univocally</strong> determined by <code>Person</code>) but also a problem, because we would now be required to explicitly give the HList type
for all the <code>Generic</code> instances we wanted to create!</p><p>This is what we usually mean when we say that <em>type members</em> can be used to <em>hold the result</em> of a <em>type-level computation</em>;
in this case type member <code>Generic.Out</code> contained the result of <em>automaticaly deriving</em> <code>L</code> from <code>Person</code>.</p><p>Visavis, <code>Generic.Aux[P,L]</code> is sometimes called a <em>type extractor</em> because it <em>extracts</em> the type member value <code>Generic.Out</code>
by raising it into the signature of type <code>Generic.Aux</code>.</p><h3 id=bonus-applyproduct-encoding-in-prolog>Bonus: <code>applyProduct</code> encoding in Prolog <a href=#bonus-applyproduct-encoding-in-prolog class=anchor>üîó</a></h3><p>We will show how the <code>applyProduct</code> works by encoding it in Prolog.</p><p>The type-level constraints of our running example can be re-implemented in Prolog.
A tuple can be defined just like in Scala:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>(<span style=color:#a31515>arg_type1</span>, <span style=color:#a31515>arg_type2</span>, ..., <span style=color:#a31515>arg_typeN</span>)
</span></span></code></pre></div><p>Since we know that in Scala we can always transform a <code>FunctionN</code> into a <code>Function1</code> of a <code>TupleN</code> for all <code>N>1</code>, we can represent a function type as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>fn((<span style=color:#a31515>arg_type1</span>, <span style=color:#a31515>arg_type2</span>, ..., <span style=color:#a31515>arg_typeN</span>), <span style=color:#a31515>ret_type</span>)
</span></span></code></pre></div><p>and, when there is only one arg, simply:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>fn(<span style=color:#a31515>arg_type1</span>, <span style=color:#a31515>ret_type</span>)
</span></span></code></pre></div><p>for instance, the type signature for function <code>def stringify(s: Any): String</code>
could be represented by <code>fn(any, string)</code></p><p>Now, let us try and translate the constraints in the signature of <code>applyProduct</code> into Prolog predicates.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f>def</span> applyProduct[<span style=color:#2b91af>P</span> <span style=color:#00f>&lt;:</span> <span style=color:#2b91af>Product</span>, <span style=color:#2b91af>F</span>, <span style=color:#2b91af>L</span> <span style=color:#00f>&lt;:</span> <span style=color:#2b91af>HList</span>, <span style=color:#2b91af>R</span>](p<span style=color:#00f>:</span> <span style=color:#2b91af>P</span>)(f<span style=color:#00f>:</span> <span style=color:#2b91af>F</span>)
</span></span><span style=display:flex><span>  (<span style=color:#00f>implicit</span>
</span></span><span style=display:flex><span>  	 gen<span style=color:#00f>:</span> <span style=color:#2b91af>Generic.Aux</span>[<span style=color:#2b91af>P</span>, <span style=color:#2b91af>L</span>],
</span></span><span style=display:flex><span>  	 fp<span style=color:#00f>:</span> <span style=color:#2b91af>FnToProduct.Aux</span>[<span style=color:#2b91af>F</span>, <span style=color:#2b91af>L</span> <span style=color:#00f>=&gt;</span> <span style=color:#2b91af>R</span>]
</span></span><span style=display:flex><span>  ) <span style=color:#00f>=</span> ...
</span></span></code></pre></div><p>In the previous section we saw that type parameters in a <code>def</code> can be seen as the variables in a Prolog rule,
while the rule body can be expressed using type parameters.</p><p>We may define a <code>can_apply_product(P,F,L,R)</code> predicate as follows:</p><ul><li><p><code>P</code> must be a <code>Product</code>. So, let us define the <code>product</code> predicate which holds
when <code>P</code> is a Product.</p><p>For instance, in the case of a pair:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>product(X):- X = (<span style=color:#00f>_</span>,<span style=color:#00f>_</span>).
</span></span></code></pre></div><p>Or, in short:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>product((<span style=color:#00f>_</span>,<span style=color:#00f>_</span>)).
</span></span><span style=display:flex><span>product((<span style=color:#00f>_</span>,<span style=color:#00f>_</span>,<span style=color:#00f>_</span>)).
</span></span><span style=display:flex><span>... <span style=color:green>% for &gt;3 tuples</span>
</span></span></code></pre></div></li><li><p><code>F</code> is unconstrained (in the sense that there is no unary predicate on F)</p></li><li><p><code>L</code> must be an <code>HList</code>, which in Prolog we can represent as a list.
We can define the predicate <code>hlist</code>, which holds when <code>L</code> is a list.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>hlist(X):- X = [<span style=color:#00f>_</span>|<span style=color:#00f>_</span>]. <span style=color:green>% [Head | Tail]</span>
</span></span><span style=display:flex><span>product([<span style=color:#00f>_</span>|<span style=color:#00f>_</span>]). <span style=color:green>% in short.</span>
</span></span></code></pre></div></li><li><p><code>R</code> is unconstrained (in the sense that there is no unary predicate on F)</p></li><li><p><code>Generic.Aux[P,L]</code> puts in relation product <code>P</code> with HList <code>L</code>. In Prolog, this would a predicate. Let us see it for the case of a pair <code>P</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>generic(P, L) :-
</span></span><span style=display:flex><span>    product(P),
</span></span><span style=display:flex><span>	(X, Y) = P,  <span style=color:green>% deconstruct P into X and Y (the correct term is ¬´unify¬ª)</span>
</span></span><span style=display:flex><span>	hlist(L),
</span></span><span style=display:flex><span>	[X, Y] = L.  <span style=color:green>% deconstruct L into X and Y</span>
</span></span></code></pre></div><p>But, really, in Prolog we can drop the <code>product</code> and <code>hlist</code> constraints, because
they are really implied by the syntax <code>(X,Y)</code> and <code>[X,Y]</code>, respectively. So this can be further shortened:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>generic((X,Y), [X,Y]).
</span></span></code></pre></div></li><li><p><code>FnToProduct.Aux[F, L => R]</code> puts in relation the type parameter <code>F</code> with the function type <code>L => R</code>. In Prolog, this could be described as the predicate</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>fn_to_product(F, fn(L, R))<span style=color:#a31515>:</span>
</span></span></code></pre></div></li></ul><p>in fact, we decided to represent any <code>T => R</code> function type using <code>fn(T,R)</code>.
The <code>fn_to_product</code> predicate shall hold when</p><ol><li><code>F</code> is a function</li><li>the tuple of the types of the arguments of <code>F</code> can be converted into a (h)list</li></ol><p>This can be written as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>fn_to_product(F, fn(L, R)) :-
</span></span><span style=display:flex><span>   fn(Args,R) = F,
</span></span><span style=display:flex><span>   generic(Args, L).    
</span></span></code></pre></div><p>or, in short:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>fn_to_product(fn(Args,R), L, R) :-
</span></span><span style=display:flex><span>   generic(Args, L).    
</span></span></code></pre></div><p>The <code>can_apply_product</code> predicate, which encodes all of the type constraints
in the <code>applyProduct</code> Scala function, puts in relation:</p><ul><li>the product <code>P</code></li><li>the function <code>F</code></li><li>the list <code>L</code> of the arg types of <code>F</code></li><li>the return type <code>R</code> of <code>F</code></li></ul><p>Let&rsquo;s see Prolog and Scala side-by-side:</p><table><tr><td><code><pre>
can_apply_product(P, F, L, R) :-
<pre><code>generic(P,L),
fn_to_product(F, fn(L, R)).
</code></pre><p></pre></code></p></td><td><code><pre>
def applyProduct[P <: Product, F, L <: HList, R](p: P)(f: F)
  (implicit
  	 gen: Generic.Aux[P, L],
  	 fp: FnToProduct.Aux[F, L => R])
</pre></code></td></tr></table><p>So, let&rsquo;s see it as a whole:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-prolog data-lang=prolog><span style=display:flex><span>generic((X,Y), [X,Y]).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fn_to_product(fn(Args,R), L, R) :-
</span></span><span style=display:flex><span>    generic(Args, L).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>can_apply_product(P, F, L, R) :-
</span></span><span style=display:flex><span>    generic(P,L),
</span></span><span style=display:flex><span>	fn_to_product(F, fn(L, R)).
</span></span></code></pre></div><h2 id=conclusions-and-references>Conclusions and References <a href=#conclusions-and-references class=anchor>üîó</a></h2><p>This long blog post has only scratched the surface of Shapeless. If this has whetted your appetite, then I suggest you to delve further into Shapeless&rsquo;s inner guts. I have compiled for you a short list of resources that you may want to have a look at.</p><h3 id=longer-essays>Longer Essays <a href=#longer-essays class=anchor>üîó</a></h3><ul><li><a href=http://rnduja.github.io/2015/10/07/scala-dependent-types/ target=_blank rel=noopener>Our own Andrea Ferretti&rsquo;s step-by step introduction to dependent types</a> encoded in Scala&rsquo;s type system</li><li><a href=https://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/ target=_blank rel=noopener>Mark Harrah&rsquo;s series</a> on type-level programming on <em>ApocaLisp</em> blog</li></ul><h3 id=slides-and-courses>Slides and Courses <a href=#slides-and-courses class=anchor>üîó</a></h3><ul><li><a href=http://slick.typesafe.com/talks/scalaio2014/Type-Level_Computations.pdf target=_blank rel=noopener>Stefan Zeiger&rsquo;s slides on Type-level Computations</a></li><li><a href=https://github.com/fommil/shapeless-for-mortals target=_blank rel=noopener>Sam Halliday&rsquo;s Shapeless For Mortals</a> workshop material on GitHub (slides, videos, sources)</li><li><a href="https://www.youtube.com/watch?v=GDbNxL8bqkY" target=_blank rel=noopener>Miles Sabin&rsquo;s introductory talks</a> Video on YouTube</li></ul><h3 id=misc-resources>Misc. Resources <a href=#misc-resources class=anchor>üîó</a></h3><ul><li><a href=http://stackoverflow.com/questions/34544660/why-is-the-aux-technique-required-for-type-level-computations target=_blank rel=noopener>Why is the Aux technique required for type-level computations?</a> on StackOverflow</li><li><a href=https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0 target=_blank rel=noopener>Shapeless Wiki</a></li><li><a href=https://github.com/milessabin/shapeless/tree/master/examples/src/main/scala/shapeless/examples target=_blank rel=noopener>Shapeless Examples</a></li><li><a href=http://eed3si9n.com/herding-cats/ target=_blank rel=noopener>More on typeclasses in Eugene Yokota&rsquo;s ‚ÄúHerding Cats‚Äù</a></li></ul></div><div class=tags><a href=http://evacchi.github.io/tags/scala>Scala</a>
<a href=http://evacchi.github.io/tags/type-level-programming>Type-level Programming</a></div></section></main><footer id=footer><div class=social><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2022
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>