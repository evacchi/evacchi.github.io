<!doctype html><html lang=en-us><head><title>Quarking Drools | Middle of Nowhere</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The question of whether a computer can think is no more interesting than the question of whether a submarine can swim. (Edsger W. Dijkstra)
Motivation üîóRule-based artificial intelligence (AI) is often overlooked, possibly because people think it‚Äôs only useful in heavyweight enterprise software products. However, that‚Äôs not necessarily true. Simply put, a rule engine is just a piece of software that allows you to separate domain and business-specific constraint from the main application flow."><meta name=generator content="Hugo 0.111.3"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-JEBNMYFPPB"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JEBNMYFPPB")</script></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>Quarking Drools</h1><div class=tip><time datetime="2019-03-15 00:00:00 +0000 UTC">Mar 15, 2019</time>
<span class=split>¬∑</span>
<span>2513 words</span>
<span class=split>¬∑</span>
<span>12 minute read</span></div><div class=content><blockquote><p>The question of whether a computer can think is no more interesting
than the question of whether a submarine can swim. (<em>Edsger W.
Dijkstra</em>)</p></blockquote><h2 id=motivation>Motivation <a href=#motivation class=anchor>üîó</a></h2><p>Rule-based artificial intelligence (AI) is often overlooked, possibly because people think it‚Äôs only useful in heavyweight enterprise software products. However, that‚Äôs not necessarily true. Simply put, a rule engine is just a piece of software that allows you to separate domain and business-specific constraint from the main application flow. We are part of the team developing and maintaining Drools‚Äîthe world‚Äôs most popular open source rule engine and part of Red Hat‚Äîand, in this article, we will describe how we are changing Drools to make it part of the cloud and serverless revolution.</p><h2 id=technical-overview>Technical Overview <a href=#technical-overview class=anchor>üîó</a></h2><p>Our main goal was to make the core of the rule engine lighter, isolated,
easily portable across different platforms, and well-suited to run in a
container. The software development landscape has changed a lot in the
last 20 years. We are moving more and more towards a polyglot world, and
this is one of the reasons why we are working towards making our
technology work across a lot of different platforms. This is one of the
reasons why we also started looking into
<a href=https://www.graalvm.org/ target=_blank rel=noopener><em>GraalVM</em></a>, the new Oracle Labs polyglot
virtual machine ecosystem consisting of</p><ul><li>A polyglot VM runtime, alternative to the JVM with a just-in-time
(JIT) compiler that improves efficiency and speed of applications
over traditional HotSpot. This is also the &ldquo;proper&rdquo; GraalVM</li><li>A framework to write efficient dynamic programming languages such as
JavaScript, Python, and R and mix and match them together (Truffle)</li><li>A tool to compile programs ahead-of-time (AOT) into a native
executable</li></ul><p>Meanwhile at Red Hat, another team was already experimenting with
GraalVM and native binary generation for application development. This
effort has been realized in a new project you may have already heard of
called <a href=http://quarkus.io/ target=_blank rel=noopener><em>Quarkus</em></a>. The Quarkus project is a
best-of-breed Java stack that works on good ol&rsquo; JVM, but it is also
especially tailored for GraalVM, native binary compilation and
cloud-native application development.</p><p>Now, GraalVM is an amazing tool but it also come with a number of
(understandable)
<a href=https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md target=_blank rel=noopener><em>limitations</em></a><a href=https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md target=_blank rel=noopener>.
T</a>herefore,
not only is Quarkus designed to integrate seamlessly with GraalVM and
native image generation, but it also provides useful utilities to
overcome any related limitations. In particular, Drools used to make
extensive use of dynamic class generation, class-loading, and quite a
bit of reflection. In order to produce fast, efficient and small native
executable, Graal performs aggressive inlining and dead-code
elimination, and it operates under a <strong>closed-world assumption</strong>; that
is, the compiler removes any references to class and methods that cannot
be statically reachable in the code. In other words, unrestricted
reflective calls and dynamic class loading are a no-go. Although this
may first sound like a showstopper, in the next 2 sections we will
document in detail how we modified the core of Drools to overcome such
limitations, and we will explain why such limitations are not evil and
actually liberating.</p><h2 id=the-executable-model>The Executable Model <a href=#the-executable-model class=anchor>üîó</a></h2><p>In a rule engine, <strong>facts</strong> are inserted into a <strong>working memory.</strong>
<strong>Rules</strong> describe <strong>actions</strong> to take when certain <strong>constraints</strong> over
the facts that are inserted into the working memory become <strong>true</strong>. For
instance, the sentence &ldquo;<strong>when</strong> *the sun goes down ***: **<em>turn on the
lights</em>&rdquo; expresses a rule over the sun. The <em>fact</em> is that the sun is
going down. The <em>action</em> is to turn on the lights. In a rule engine we
*insert *the &ldquo;sun is going down&rdquo; fact inside the working memory. When we
<em>fire</em> the rules the action of <em>turning on the lights</em> will execute.</p><p>A rule definition has the form</p><pre tabindex=0><code>      &lt;constraints&gt; ‚Üí &lt;consequence&gt;
</code></pre><p>the <em>constraints</em> part, also called the *left-hand side *of the rule,
describes the constraints that activate the rule and make it ready to
<em>fire</em>; the <em>consequence</em> part, also called the <em>right-hand side</em> of the
rule, contains the action that rule will take when the rule is fired.</p><p>In Drools, a rule is written using the Drools Rule Language (in short,
DRL), and it has the form:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>rule R1 when
</span></span><span style=display:flex><span>  $r : Result()                                <span style=color:green>// constraints
</span></span></span><span style=display:flex><span><span style=color:green></span>  $p : Person( age &gt;= 18 )    
</span></span><span style=display:flex><span>then
</span></span><span style=display:flex><span>  $r.setValue( $p.getName() + <span style=color:#a31515>&#34; can drink&#34;</span>);   <span style=color:green>// consequence
</span></span></span><span style=display:flex><span><span style=color:green></span>end
</span></span></code></pre></div><p>Constraints are written using a form of pattern-matching over the data
(Java objects) that is inserted into the working memory. Actions are
basically a block of Java code with a few Drools-specific extensions.</p><p>Historically, the DRL used to be a dynamic language that was interpreted
at runtime by the Drools engine. In particular, the pattern matching
syntax had a major drawback: it made extensive use of reflection unless
the engine detected a pattern was &ldquo;hot&rdquo; enough for further optimization;
that is, if it had evaluated a certain number of times; in that case the
engine would compile it into bytecode on-the-fly.</p><p>About one year ago, for performance reasons, we decided to go away with
runtime reflection and dynamic code generation and completed the
implementation of what we called the <a href=http://blog.athico.com/2018/02/the-drools-executable-model-is-alive.html target=_blank rel=noopener><em>Drools Executable
Model</em></a>,
providing a pure Java-based representation of a rule set, together with
a convenient Java DSL to programmatically define such model.</p><p>To give an idea of how this Java API looks like let‚Äôs consider again the
simple Drools rule reported above. The rule will fire if the working
memory contains any Result instance, and instance of Person where the
age field is greater or equal to 18. The consequence is to set the value
of the Result object to a String saying that the person can drink. The
equivalent rule expressed with the executable model API looks like it
follows (pretty-printed for readability):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>var r = declarationOf(Result.class, <span style=color:#a31515>&#34;$r&#34;</span>);
</span></span><span style=display:flex><span>var p = declarationOf(Person.class, <span style=color:#a31515>&#34;$p&#34;</span>);
</span></span><span style=display:flex><span>var rule = 
</span></span><span style=display:flex><span>  rule(<span style=color:#a31515>&#34;com.example&#34;</span>, <span style=color:#a31515>&#34;R1&#34;</span>).build(
</span></span><span style=display:flex><span>    pattern(r),
</span></span><span style=display:flex><span>    pattern(p).expr(<span style=color:#a31515>&#34;e&#34;</span>, p -&gt; p.getAge() &gt;= 18),
</span></span><span style=display:flex><span>    alphaIndexedBy(<span style=color:#2b91af>int</span>.class, GREATER<span>\</span>_OR<span>\</span>_EQUAL, 1, <span style=color:#00f>this</span>::getAge, 18),
</span></span><span style=display:flex><span>    reactOn(<span style=color:#a31515>&#34;age&#34;</span>)),
</span></span><span style=display:flex><span>    on(p, r).execute(($p, $r) -&gt; 
</span></span><span style=display:flex><span>      $r.setValue($p.getName() + <span style=color:#a31515>&#34; can drink&#34;</span>)));
</span></span></code></pre></div><p>As you can see this representation is more verbose and harder to
understand, partially for the Java syntax, but mostly because it
explicitly contains lots of details, like the specification of how
Drools should internally index a given constraint, that were implicit in
the corresponding DRL. We did this on purpose because we wanted a
totally explicit rule representation that did not require any convoluted
inference or reflection sorcery. However we knew that it would have been
crazy to ask users to be aware of all such intricate details and that‚Äôs
why we wrote a compiler to translate DRL into the equivalent Java code.
We achieved this using <a href=http://javaparser.org/ target=_blank rel=noopener><em>JavaParser</em></a>, a really
nice open-source library that allows to parse, modify and generate any
Java source code through a convenient API.</p><p>In all honesty when we designed and implemented the executable model we
didn‚Äôt have strictly GraalVM in mind. We simply wanted an intermediate
and pure Java representation of the rule that could be efficiently
interpreted and executed by the engine. Yet, by completely avoiding
reflection and dynamic code generation, the executable model was key to
allow us to support native binary generation with Graal. For instance,
because the new model expresses all constraints as lambda predicates, we
don‚Äôt need to optimize the constraints evaluators through bytecode
generation and dynamic classloading which are totally forbidden in
native image generation.</p><p>The design and implementation of executable model taught us an important
lesson in the process of making Drools compatible with native binary
generation: any limitation can be overcome with a sufficient amount of
code generation. We will further discuss this in the next section.</p><h2 id=overcoming-other-graal-limitations>Overcoming other Graal limitations <a href=#overcoming-other-graal-limitations class=anchor>üîó</a></h2><p>Having a plain Java model of a Drools rule base was a very good starting
point, but there was still some work to be done to make our project
compatible with native binary generation.</p><p>The executable model makes reflection largely unnecessary; however, our
engine still needs reflection for one last feature called<a href=http://docs.jboss.org/drools/release/7.17.0.Final/drools-docs/html_single/#_fine_grained_property_change_listeners target=_blank rel=noopener>
</a><a href=http://docs.jboss.org/drools/release/7.17.0.Final/drools-docs/html_single/#_fine_grained_property_change_listeners target=_blank rel=noopener><em>property
reactivity</em></a>.
Our plans are to get rid of reflection altogether, but because the
change is nontrivial, for this time we resorted to a handy feature of
the binary image compiler, which* does* support a form of reflection,
provided that we can declare upfront the classes we will need to reflect
upon at runtime. This can be supplied by providing a<a href=https://github.com/oracle/graal/blob/master/substratevm/REFLECTION.md#manual-configuration target=_blank rel=noopener>
</a><a href=https://github.com/oracle/graal/blob/master/substratevm/REFLECTION.md#manual-configuration target=_blank rel=noopener><em>JSON
descriptor</em></a>
file to the compiler, or, if you are using Quarkus, you can just<a href=https://quarkus.io/guides/rest-json-guide target=_blank rel=noopener>
</a><a href=https://quarkus.io/guides/rest-json-guide target=_blank rel=noopener><em>annotate the domain
classes</em></a>. For instance, in
the rule that we have shown above, our domain classes would be Result
and Person. Then we may write:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>  &#34;name&#34; : <span style=color:#a31515>&#34;org.drools.simple.project.Person&#34;</span>,
</span></span><span style=display:flex><span>  &#34;allPublicMethods&#34; : <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>  &#34;name&#34; : <span style=color:#a31515>&#34;org.drools.simple.project.Result&#34;</span>,
</span></span><span style=display:flex><span>  &#34;allPublicMethods&#34; : <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>and then instruct the native binary compiler with the flag</p><pre tabindex=0><code>    -H:ReflectionConfigurationFiles=reflection.json
</code></pre><p>We segregated other redundant reflection trickery to a <em>dynamic</em> module,
and implemented an alternative <em>static</em> version of the same components
that users can choose to import in their project. This is especially
useful for binary image generation, but it has benefits for regular use
cases as well, in particular, avoiding reflection and dynamic loading
can result in faster startup time and improved run-time.</p><p>At startup time, Drools projects read an XML descriptor called the
<em>kmodule</em>, where the user declaratively defines the configuration of the
project. Usually we parse this XML file and load it into memory, but our
current XStream-based parser uses a lot of reflection; first of all we
can load the XML with an alternative strategy that avoids reflection;
but we can go further: if we can guarantee that the in-memory
representation of the XML will never change across runs, and we can
afford to run a quick code-generation phase before repackaging a project
for deployment, we can avoid loading the XML at each boot-up altogether.
In fact, we are now able to translate the XML file into a class file
that will be loaded at startup time, like any other hand-coded class.
Here&rsquo;s a comparison of the XML with a snippet of the generated code
(again, pretty-printed for readability). The generated code is more
verbose because it makes explicit all the configuration defaults.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span>&lt;kbase name=<span style=color:#a31515>&#34;simpleKB&#34;</span> packages=<span style=color:#a31515>&#34;org.drools.simple.project&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;ksession name=<span style=color:#a31515>&#34;simpleKS&#34;</span> default=<span style=color:#a31515>&#34;true&#34;</span>/&gt;
</span></span><span style=display:flex><span>&lt;/kbase&gt;
</span></span></code></pre></div><p>vs.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>var m = KieServices.get().newKieModuleModel();
</span></span><span style=display:flex><span>var kb = m.newKieBaseModel(<span style=color:#a31515>&#34;simpleKB&#34;</span>);
</span></span><span style=display:flex><span>kb.setEventProcessingMode(CLOUD);
</span></span><span style=display:flex><span>kb.addPackage(<span style=color:#a31515>&#34;org.drools.simple.project&#34;</span>);
</span></span><span style=display:flex><span>var ks = kb.newKieSessionModel(<span style=color:#a31515>&#34;simpleKS&#34;</span>);
</span></span><span style=display:flex><span>ks.setDefault(<span style=color:#00f>true</span>);
</span></span><span style=display:flex><span>ks.setType(STATEFUL);
</span></span><span style=display:flex><span>ks.setClockType(ClockTypeOption.get(<span style=color:#a31515>&#34;realtime&#34;</span>));
</span></span></code></pre></div><p>Another issue with startup time, is dynamic classpath scanning. Drools
supports alternate ways to take <em>decisions</em> other than DRL-based rules,
such as *decision-tables, *the *Decision Model and Notation (DMN) *or
*predictive models *using the *Predictive Model Markup Language
*(<em>PMML</em>). Such extensions are implemented as dynamically loadable
modules, that are hooked into the core engine by scanning the classpath
at boot-time. Although this is extremely flexible, it is not essential:
even in this case, we can avoid runtime classpath scanning and provide
*static *wiring of the required components either by generating code at
build-time, or by providing an explicit API to end users to hook
components manually. We resorted to provide a pre-built static module
with a minimal core.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>private</span> Map&lt;Class&lt;?&gt;, Object&gt; serviceMap = <span style=color:#00f>new</span> HashMap&lt;&gt;();
</span></span><span style=display:flex><span><span style=color:#00f>private</span> <span style=color:#2b91af>void</span> wireServices() {
</span></span><span style=display:flex><span>  serviceMap.put(ServiceInterface.class,
</span></span><span style=display:flex><span>  Class.forName(<span style=color:#a31515>&#34;org.drools.ServiceImpl&#34;</span>).newInstance());
</span></span><span style=display:flex><span>  <span style=color:green>// ‚Ä¶ more services here
</span></span></span><span style=display:flex><span><span style=color:green></span>}
</span></span></code></pre></div><p>Please notice that, although here we are using Class.forName(), the
compiler is smart enough to recognize the constant, and substitute it
with an actual constructor. Of course it is possible to simplify this
further by generating a chain of <strong>if</strong> statements.</p><p>Finally, we tied everything together by getting rid of the last few
pre-executable model leftovers: the legacy Drools class-loader. This was
the culprit behind to this apparently cryptic error message:</p><pre tabindex=0><code>
Error: unsupported features in 2 methods
Detailed message:
Error: com.oracle.graal.pointsto.constraints.UnsupportedFeatureException: Unsupported method java.lang.ClassLoader.defineClass(String, byte[], int, int, ProtectionDomain) is reachable: The declaring class of this element has been substituted, but this element is not present in the substitution class
To diagnose the issue, you can add the option --report-unsupported-elements-at-runtime. The unsupported element is then reported at run time when it is accessed the first time.
Trace:
        at parsing org.drools.dynamic.common.DynamicComponentsSupplier$DefaultByteArrayClassLoader.defineClass(DynamicComponentsSupplier.java:49)
Call path from entry point to org.drools.dynamic.common.DynamicComponentsSupplier$DefaultByteArrayClassLoader.defineClass(String, byte[], ProtectionDomain):
</code></pre><p>But really, the message is pretty clear: our custom class-loader is able
to dynamically <em>define</em> a class; this is useful when you generate
bytecode at <em>run-time.</em> But if the codebase relies completely on the
executable model then we can avoid this altogether, so we isolated the
legacy class-loader into the *dynamic *module.</p><p>This is the last thing that was necessary to successfully generate a
native image of our simple test project and the results exceeded our
expectations confirming that the time and efforts we spent in this
experiment were well invested. Indeed, executing the main class of our
test case with a normal JVM takes 43 milliseconds with a occupation of
73M of memory. The corresponding native image generated by Graal is
timed at less than 1 millisecond and uses only 21M of memory.</p><h2 id=integrating-with-quarkus>Integrating with Quarkus <a href=#integrating-with-quarkus class=anchor>üîó</a></h2><p>Once we had a first version of Drools compatible with Graal native
binary generation, the next natural step was to start leveraging the
features provided by Quarkus and try to create a simple web service with
it. The first thing that we noticed is that Quarkus offers a different
and simpler mechanism to let the compiler know that we need reflection
on a specific class. In fact, instead of having to declare this in a
JSON file like we did before, it is enough to annotate the class of your
domain model as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@RegisterForReflection
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Person</span> { <span>‚Ä¶</span> }
</span></span></code></pre></div><p>We also decided to go one small step forward with our code generation
machinery. In particular we added one small interface to Drools code</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>KieRuntimeBuilder</span> {
</span></span><span style=display:flex><span>  KieSession newKieSession();
</span></span><span style=display:flex><span>  KieSession newKieSession(String sessionName);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>so that when the Drools compiler creates the executable model from the
DRL files it also generates an implementation of this class. This
implementation has the purpose of supplying a Drools session
automatically configured with the rules and the parameters defined by
the user.</p><p>After that we were ready to put both dependency injection and REST
support provided by Quarkus at work and developed a simple web service
exercising the Drools runtime.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@Path(<span style=color:#a31515>&#34;/candrink/{name}/{age}&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>CanDrinkResource</span> {
</span></span><span style=display:flex><span>  @Inject
</span></span><span style=display:flex><span>  KieRuntimeBuilder runtimeBuilder;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  @GET
</span></span><span style=display:flex><span>  @Produces(MediaType.TEXT_PLAIN)
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> String canDrink( 
</span></span><span style=display:flex><span>    @PathParam(<span style=color:#a31515>&#34;name&#34;</span>) String name, 
</span></span><span style=display:flex><span>    @PathParam(<span style=color:#a31515>&#34;age&#34;</span>) <span style=color:#2b91af>int</span> age ) {
</span></span><span style=display:flex><span>    KieSession ksession = runtimeBuilder.newKieSession();
</span></span><span style=display:flex><span>    Result result = <span style=color:#00f>new</span> Result();
</span></span><span style=display:flex><span>    ksession.insert(result);
</span></span><span style=display:flex><span>    ksession.insert(<span style=color:#00f>new</span> Person( name, age ));
</span></span><span style=display:flex><span>    ksession.fireAllRules();
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> result.toString();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The example is straightforward enough to not require any further
explanation and is fully deployable as a microservice in an OpenShift
cluster. Thanks to the extremely low startup time, due to the work we
did on Drools and Quarkus&rsquo; low overhead, this microservice is fast
enough to be deployable in a
<a href=https://cloud.google.com/knative/ target=_blank rel=noopener><em>KNative</em></a> cloud. You can find the
full source code on
<a href=https://github.com/kiegroup/submarine-examples target=_blank rel=noopener><em>GitHub</em></a>.</p><h2 id=introducing-submarine>Introducing Submarine <a href=#introducing-submarine class=anchor>üîó</a></h2><p>These days, rule engines are seldom a matter of discussion. This is
because they <em>just work</em>. A rule engine is not necessarily antithetical
to a cloud environment, but work might be needed to fit the new
paradigm. This was the story of our journey. We started with courage and
curiosity. In the next few months we will push this forward to become
more than a simple prototype, to realize a complete suite of business
automation tools, ready for the cloud. The name of the initiative is
**Submarine, **from the famous Dijkstra quote. So, sit tight, and get
ready to dive in.</p></div><div class=tags><a href=/tags/drools>Drools</a>
<a href=/tags/quarkus>Quarkus</a>
<a href=/tags/kogito>Kogito</a></div></section></main><footer id=footer><div class=social><a class="symbol github" href=https://github.com/evacchi rel=me target=_blank></a><a class="symbol linkedin" href=https://linkedin.com/in/edoardovacchi rel=me target=_blank></a><a class="symbol mastodon" href=https://mastodon.social/@evacchi rel=me target=_blank></a><a class="symbol twitter" href=https://twitter.com/evacchi rel=me target=_blank></a></div><div class=copyright>¬© Copyright
2023
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Edoardo Vacchi</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>