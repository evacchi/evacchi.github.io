<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Compilers on Middle of Nowhere</title><link>/tags/compilers/</link><description>Recent content in Compilers on Middle of Nowhere</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 23 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/compilers/index.xml" rel="self" type="application/rss+xml"/><item><title>A History of WebAssembly</title><link>/posts/2022/11/23/a-history-of-webassembly/</link><pubDate>Wed, 23 Nov 2022 00:00:00 +0000</pubDate><guid>/posts/2022/11/23/a-history-of-webassembly/</guid><description>&lt;img src="https://i.imgur.com/JnJO7HZ.jpg" style="float:right" width=400/&gt;
&lt;p&gt;Lately there have been quite a few announcements around WebAssembly, such as the &lt;a href="https://www.docker.com/blog/docker-wasm-technical-preview/" target="_blank" rel="noopener"&gt;Docker+Wasm Technical Preview&lt;/a&gt;. You may have started to wonder whether this technology is something you should care about.&lt;/p&gt;
&lt;p&gt;In this blog post, we will lightheartedly explore the history of Wasm. I will not make any claim about correctness: I may have made mistakes; in that case, feel free to contact me! I will try to motivate how we came to defining the WebAssembly standard and VM, and how they are all about providing a multi-platform, portable low-level &lt;strong&gt;compilation target&lt;/strong&gt; for multiple programming languages. In fact, a history of WebAssembly really is&amp;hellip;&lt;/p&gt;</description></item><item><title>Kogito: A Modular Codegen Design Proposal</title><link>/posts/2020/04/23/kogito-a-modular-codegen-design-proposal/</link><pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate><guid>/posts/2020/04/23/kogito-a-modular-codegen-design-proposal/</guid><description>&lt;p&gt;My favorite topic of discussion last year was &lt;em&gt;moving computations to compile-time&lt;/em&gt;.&lt;/p&gt;
&lt;div style="float:right"&gt;
&lt;img src="https://i.imgur.com/cHmSoB8.png" title="Reflection" /&gt;
&lt;/div&gt;
&lt;p&gt;In fact, I went to &lt;a href="https://youtu.be/TWfigR9wGsA" target="_blank" rel="noopener"&gt;a few&lt;/a&gt; &lt;a href="https://www.youtube.com/watch?v=BUrY6On1SxM" target="_blank" rel="noopener"&gt;conferences&lt;/a&gt; explaining how &lt;strong&gt;moving processing out of your run-time and into build-time&lt;/strong&gt;, is a &lt;strong&gt;conceptually simple&lt;/strong&gt; but &lt;strong&gt;extremely effective way&lt;/strong&gt; to make your applications lighter. This was sometimes received with &lt;strong&gt;little enthusiasm&lt;/strong&gt;: the idea itself is in fact far from new. Yet, it is key to a lot of the most interesting recent innovations in the Java ecosystem.&lt;/p&gt;</description></item></channel></rss>